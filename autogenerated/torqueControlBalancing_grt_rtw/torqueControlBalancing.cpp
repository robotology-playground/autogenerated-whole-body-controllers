/*
 * torqueControlBalancing.cpp
 *
 * Non-Degree Granting Education License -- for use at non-degree
 * granting, nonprofit, educational organizations only. Not for
 * government, commercial, or other organizational use.
 *
 * Code generation for model "torqueControlBalancing".
 *
 * Model version              : 1.3504
 * Simulink Coder version : 8.14 (R2018a) 06-Feb-2018
 * C++ source code generated on : Sat Mar 21 21:12:50 2020
 *
 * Target selection: grt.tlc
 * Note: GRT includes extra infrastructure and instrumentation for prototyping
 * Embedded hardware selection: 32-bit Generic
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "torqueControlBalancing.h"
#include "torqueControlBalancing_private.h"

/* Forward declaration for local functions */
static void torque_rollPitchYawFromRotation(const real_T R[9], real_T rollPitchYaw[3]);
static void torqueControlBalancing_xgetrf(real_T A[16], int32_T ipiv[4], int32_T* info);
static void torqueControlBalancing_mldivide(const real_T A[16], real_T B[16]);

/*
 * System initialize for atomic system:
 *    '<S59>/MATLAB Function'
 *    '<S96>/MATLAB Function'
 */
void torqueContr_MATLABFunction_Init(DW_MATLABFunction_torqueContr_T* localDW)
{
    localDW->state_not_empty = false;
}

/*
 * Output and update for atomic system:
 *    '<S59>/MATLAB Function'
 *    '<S96>/MATLAB Function'
 */
void torqueControlBal_MATLABFunction(const real_T rtu_s[23],
                                     B_MATLABFunction_torqueContro_T* localB,
                                     DW_MATLABFunction_torqueContr_T* localDW)
{
    /* MATLAB Function 'Utilities/holder /MATLAB Function': '<S61>:1' */
    if (!localDW->state_not_empty) {
        /* '<S61>:1:5' */
        /* '<S61>:1:6' */
        memcpy(&localDW->state[0], &rtu_s[0], 23U * sizeof(real_T));
        localDW->state_not_empty = true;
    }

    /* '<S61>:1:9' */
    memcpy(&localB->s0[0], &localDW->state[0], 23U * sizeof(real_T));
}

/* Function for MATLAB Function: '<S70>/Get Base Rotation From IMU' */
static void torque_rollPitchYawFromRotation(const real_T R[9], real_T rollPitchYaw[3])
{
    if (R[2] < 1.0) {
        if (R[2] > -1.0) {
            rollPitchYaw[1] = std::asin(-R[2]);
            rollPitchYaw[2] = atan2(R[1], R[0]);
            rollPitchYaw[0] = atan2(R[5], R[8]);
        }
        else {
            rollPitchYaw[1] = 1.5707963267948966;
            rollPitchYaw[2] = -atan2(-R[7], R[4]);
            rollPitchYaw[0] = 0.0;
        }
    }
    else {
        rollPitchYaw[1] = -1.5707963267948966;
        rollPitchYaw[2] = atan2(-R[7], R[4]);
        rollPitchYaw[0] = 0.0;
    }
}

/* Function for MATLAB Function: '<S70>/Get Base Rotation From IMU' */
static void torqueControlBalancing_xgetrf(real_T A[16], int32_T ipiv[4], int32_T* info)
{
    int32_T j;
    int32_T c;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T k;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    ipiv[0] = 1;
    ipiv[1] = 2;
    ipiv[2] = 3;
    ipiv[3] = 4;
    *info = 0;
    for (j = 0; j < 3; j++) {
        c = j * 5;
        iy = 0;
        ix = c;
        smax = std::abs(A[c]);
        for (k = 2; k <= 4 - j; k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                iy = k - 1;
                smax = s;
            }
        }

        if (A[c + iy] != 0.0) {
            if (iy != 0) {
                iy += j;
                ipiv[j] = iy + 1;
                smax = A[j];
                A[j] = A[iy];
                A[iy] = smax;
                ix = j + 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
                ix += 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
                ix += 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
            }

            iy = (c - j) + 4;
            for (ix = c + 1; ix < iy; ix++) {
                A[ix] /= A[c];
            }
        }
        else {
            *info = j + 1;
        }

        iy = c;
        ix = c + 4;
        for (k = 1; k <= 3 - j; k++) {
            smax = A[ix];
            if (A[ix] != 0.0) {
                c_ix = c + 1;
                d = (iy - j) + 8;
                for (ijA = 5 + iy; ijA < d; ijA++) {
                    A[ijA] += A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 4;
            iy += 4;
        }
    }

    if ((*info == 0) && (!(A[15] != 0.0))) {
        *info = 4;
    }
}

/* Function for MATLAB Function: '<S70>/Get Base Rotation From IMU' */
static void torqueControlBalancing_mldivide(const real_T A[16], real_T B[16])
{
    real_T temp;
    int32_T ip;
    real_T b_A[16];
    int32_T ipiv[4];
    int32_T info;
    int32_T i;
    memcpy(&b_A[0], &A[0], sizeof(real_T) << 4U);
    torqueControlBalancing_xgetrf(b_A, ipiv, &info);
    for (info = 0; info < 3; info++) {
        if (info + 1 != ipiv[info]) {
            ip = ipiv[info] - 1;
            temp = B[info];
            B[info] = B[ip];
            B[ip] = temp;
            temp = B[info + 4];
            B[info + 4] = B[ip + 4];
            B[ip + 4] = temp;
            temp = B[info + 8];
            B[info + 8] = B[ip + 8];
            B[ip + 8] = temp;
            temp = B[info + 12];
            B[info + 12] = B[ip + 12];
            B[ip + 12] = temp;
        }
    }

    for (info = 0; info < 4; info++) {
        ip = info << 2;
        if (B[ip] != 0.0) {
            for (i = 1; i + 1 < 5; i++) {
                B[i + ip] -= B[ip] * b_A[i];
            }
        }

        if (B[1 + ip] != 0.0) {
            for (i = 2; i + 1 < 5; i++) {
                B[i + ip] -= B[1 + ip] * b_A[i + 4];
            }
        }

        if (B[2 + ip] != 0.0) {
            for (i = 3; i + 1 < 5; i++) {
                B[i + ip] -= B[2 + ip] * b_A[i + 8];
            }
        }
    }

    for (info = 0; info < 4; info++) {
        ip = info << 2;
        if (B[3 + ip] != 0.0) {
            B[3 + ip] /= b_A[15];
            for (i = 0; i < 3; i++) {
                B[i + ip] -= B[3 + ip] * b_A[i + 12];
            }
        }

        if (B[2 + ip] != 0.0) {
            B[2 + ip] /= b_A[10];
            for (i = 0; i < 2; i++) {
                B[i + ip] -= B[2 + ip] * b_A[i + 8];
            }
        }

        if (B[1 + ip] != 0.0) {
            B[1 + ip] /= b_A[5];
            for (i = 0; i < 1; i++) {
                B[i + ip] -= B[1 + ip] * b_A[i + 4];
            }
        }

        if (B[ip] != 0.0) {
            B[ip] /= b_A[0];
        }
    }
}

/*
 * Output and update for atomic system:
 *    '<S70>/Get Base Rotation From IMU'
 *    '<S71>/Get Base Rotation From IMU'
 */
void torqueCo_GetBaseRotationFromIMU(const real_T rtu_imu_H_fixedLink[16],
                                     const real_T rtu_imu_H_fixedLink_0[16],
                                     const real_T rtu_fixedLink_H_base[16],
                                     const real_T rtu_rpyFromIMU_0[3],
                                     const real_T rtu_rpyFromIMU[3],
                                     const real_T rtu_neck_pos[3],
                                     B_GetBaseRotationFromIMU_torq_T* localB,
                                     P_torqueControlBalancing_T* torqueControlBalancing_P)
{
    real_T wImu_H_wImuAssumingNeckToZero[16];
    real_T wImu_H_base[16];
    real_T wImu_H_fixedLink_0[16];
    real_T wImu_R_fixedLink_0[9];
    real_T rollPitchYaw_fixedLink[3];
    real_T R[9];
    real_T b_R[9];
    real_T c_R[9];
    real_T d_R[9];
    real_T e_R[9];
    real_T f_R[9];
    int32_T ipiv[4];
    int32_T info;
    int32_T jBcol;
    int32_T jAcol;
    int32_T kBcol;
    static const int8_T b[4] = {0, 0, 0, 1};

    static const real_T B[16] = {-1.0,
                                 1.2246467991473532E-16,
                                 -1.2246467991473532E-16,
                                 0.0,
                                 -1.2246467991473532E-16,
                                 -6.1232339957367648E-17,
                                 1.0,
                                 0.0,
                                 1.2246467991473532E-16,
                                 1.0,
                                 6.123233995736766E-17,
                                 0.0,
                                 -0.018499999999999985,
                                 0.12029999999999999,
                                 0.0066000000000000043,
                                 1.0};

    static const real_T b_b[16] = {1.0,
                                   0.0,
                                   0.0,
                                   0.0,
                                   -0.0,
                                   6.123233995736766E-17,
                                   1.0,
                                   0.0,
                                   0.0,
                                   -1.0,
                                   6.123233995736766E-17,
                                   0.0,
                                   0.0,
                                   0.0,
                                   0.0066,
                                   1.0};

    static const real_T c[4] = {0.0, -1.0, 6.123233995736766E-17, 0.1108};

    real_T tmp[3];
    real_T R_0[9];
    real_T d_R_0[9];
    real_T d_R_1[9];
    real_T R_1[9];
    real_T R_2[9];
    real_T R_3[16];
    real_T tmp_0[16];
    real_T tmp_1[16];
    real_T tmp_2[16];
    real_T tmp_3[16];
    real_T rollPitchYaw_filtered_idx_2;
    real_T rollPitchYaw_filtered_idx_1;
    real_T rollPitchYaw_filtered_idx_0;
    real_T R_tmp;
    real_T R_tmp_0;
    int32_T wImu_R_fixedLink_0_tmp;

    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Robot State and References/Compute base to
     * fixed link transform/LFoot to base link transform /Get Base Rotation From IMU': '<S76>:1' */
    /* '<S76>:1:3' */
    /* '<S76>:1:5' */
    rollPitchYaw_fixedLink[0] = rtu_rpyFromIMU[0] * 3.1415926535897931 / 180.0;
    rollPitchYaw_filtered_idx_0 = rtu_rpyFromIMU_0[0] * 3.1415926535897931 / 180.0;
    rollPitchYaw_fixedLink[1] = rtu_rpyFromIMU[1] * 3.1415926535897931 / 180.0;
    rollPitchYaw_filtered_idx_1 = rtu_rpyFromIMU_0[1] * 3.1415926535897931 / 180.0;
    rollPitchYaw_fixedLink[2] = rtu_rpyFromIMU[2] * 3.1415926535897931 / 180.0;
    rollPitchYaw_filtered_idx_2 = rtu_rpyFromIMU_0[2] * 3.1415926535897931 / 180.0;
    memset(&R[0], 0, 9U * sizeof(real_T));
    memset(&b_R[0], 0, 9U * sizeof(real_T));
    memset(&c_R[0], 0, 9U * sizeof(real_T));
    memset(&d_R[0], 0, 9U * sizeof(real_T));
    memset(&e_R[0], 0, 9U * sizeof(real_T));
    memset(&f_R[0], 0, 9U * sizeof(real_T));
    R[8] = 1.0;
    R_tmp_0 = std::cos(rollPitchYaw_fixedLink[2]);
    R[0] = R_tmp_0;
    R_tmp = std::sin(rollPitchYaw_fixedLink[2]);
    R[3] = -R_tmp;
    R[1] = R_tmp;
    R[4] = R_tmp_0;
    b_R[4] = 1.0;
    R_tmp_0 = std::cos(rollPitchYaw_fixedLink[1]);
    b_R[0] = R_tmp_0;
    R_tmp = std::sin(rollPitchYaw_fixedLink[1]);
    b_R[6] = R_tmp;
    b_R[2] = -R_tmp;
    b_R[8] = R_tmp_0;
    c_R[0] = 1.0;
    R_tmp_0 = std::cos(rollPitchYaw_fixedLink[0]);
    c_R[4] = R_tmp_0;
    R_tmp = std::sin(rollPitchYaw_fixedLink[0]);
    c_R[7] = -R_tmp;
    c_R[5] = R_tmp;
    c_R[8] = R_tmp_0;
    d_R[8] = 1.0;
    R_tmp_0 = std::cos(rollPitchYaw_filtered_idx_2);
    d_R[0] = R_tmp_0;
    rollPitchYaw_filtered_idx_2 = std::sin(rollPitchYaw_filtered_idx_2);
    d_R[3] = -rollPitchYaw_filtered_idx_2;
    d_R[1] = rollPitchYaw_filtered_idx_2;
    d_R[4] = R_tmp_0;
    e_R[4] = 1.0;
    rollPitchYaw_filtered_idx_2 = std::cos(rollPitchYaw_filtered_idx_1);
    e_R[0] = rollPitchYaw_filtered_idx_2;
    rollPitchYaw_filtered_idx_1 = std::sin(rollPitchYaw_filtered_idx_1);
    e_R[6] = rollPitchYaw_filtered_idx_1;
    e_R[2] = -rollPitchYaw_filtered_idx_1;
    e_R[8] = rollPitchYaw_filtered_idx_2;
    f_R[0] = 1.0;
    rollPitchYaw_filtered_idx_1 = std::cos(rollPitchYaw_filtered_idx_0);
    f_R[4] = rollPitchYaw_filtered_idx_1;
    rollPitchYaw_filtered_idx_0 = std::sin(rollPitchYaw_filtered_idx_0);
    f_R[7] = -rollPitchYaw_filtered_idx_0;
    f_R[5] = rollPitchYaw_filtered_idx_0;
    f_R[8] = rollPitchYaw_filtered_idx_1;
    for (info = 0; info < 3; info++) {
        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            d_R_0[jAcol] = 0.0;
            d_R_0[jAcol] = d_R_0[3 * jBcol + info] + e_R[3 * jBcol] * d_R[info];
            d_R_0[jAcol] = e_R[3 * jBcol + 1] * d_R[info + 3] + d_R_0[3 * jBcol + info];
            d_R_0[jAcol] = e_R[3 * jBcol + 2] * d_R[info + 6] + d_R_0[3 * jBcol + info];
        }

        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            d_R_1[jAcol] = 0.0;
            d_R_1[jAcol] = d_R_1[3 * jBcol + info] + f_R[3 * jBcol] * d_R_0[info];
            d_R_1[jAcol] = f_R[3 * jBcol + 1] * d_R_0[info + 3] + d_R_1[3 * jBcol + info];
            d_R_1[jAcol] = f_R[3 * jBcol + 2] * d_R_0[info + 6] + d_R_1[3 * jBcol + info];
        }

        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            wImu_R_fixedLink_0[jAcol] = 0.0;
            R_1[jAcol] = 0.0;
            wImu_R_fixedLink_0_tmp = 3 * jBcol + info;
            wImu_R_fixedLink_0[jAcol] = wImu_R_fixedLink_0[wImu_R_fixedLink_0_tmp]
                                        + rtu_imu_H_fixedLink_0[jBcol << 2] * d_R_1[info];
            R_1[jAcol] = R_1[wImu_R_fixedLink_0_tmp] + b_R[3 * jBcol] * R[info];
            wImu_R_fixedLink_0[jAcol] = rtu_imu_H_fixedLink_0[(jBcol << 2) + 1] * d_R_1[info + 3]
                                        + wImu_R_fixedLink_0[3 * jBcol + info];
            R_1[jAcol] = b_R[3 * jBcol + 1] * R[info + 3] + R_1[3 * jBcol + info];
            wImu_R_fixedLink_0[jAcol] = rtu_imu_H_fixedLink_0[(jBcol << 2) + 2] * d_R_1[info + 6]
                                        + wImu_R_fixedLink_0[3 * jBcol + info];
            R_1[jAcol] = b_R[3 * jBcol + 2] * R[info + 6] + R_1[3 * jBcol + info];
        }

        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            R_2[jAcol] = 0.0;
            R_2[jAcol] = R_2[3 * jBcol + info] + c_R[3 * jBcol] * R_1[info];
            R_2[jAcol] = c_R[3 * jBcol + 1] * R_1[info + 3] + R_2[3 * jBcol + info];
            R_2[jAcol] = c_R[3 * jBcol + 2] * R_1[info + 6] + R_2[3 * jBcol + info];
        }

        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            R_0[jAcol] = 0.0;
            R_0[jAcol] = R_0[3 * jBcol + info] + rtu_imu_H_fixedLink[jBcol << 2] * R_2[info];
            R_0[jAcol] =
                rtu_imu_H_fixedLink[(jBcol << 2) + 1] * R_2[info + 3] + R_0[3 * jBcol + info];
            R_0[jAcol] =
                rtu_imu_H_fixedLink[(jBcol << 2) + 2] * R_2[info + 6] + R_0[3 * jBcol + info];
        }
    }

    torque_rollPitchYawFromRotation(R_0, rollPitchYaw_fixedLink);
    rollPitchYaw_filtered_idx_2 = rollPitchYaw_fixedLink[2];
    if (torqueControlBalancing_P->Config.FILTER_IMU_YAW) {
        torque_rollPitchYawFromRotation(wImu_R_fixedLink_0, tmp);
        rollPitchYaw_filtered_idx_2 = tmp[2];
    }

    memset(&R[0], 0, 9U * sizeof(real_T));
    memset(&b_R[0], 0, 9U * sizeof(real_T));
    memset(&c_R[0], 0, 9U * sizeof(real_T));
    R[8] = 1.0;
    R_tmp_0 = std::cos(rollPitchYaw_filtered_idx_2);
    R[0] = R_tmp_0;
    R_tmp = std::sin(rollPitchYaw_filtered_idx_2);
    R[3] = -R_tmp;
    R[1] = R_tmp;
    R[4] = R_tmp_0;
    b_R[4] = 1.0;
    b_R[0] = std::cos(rollPitchYaw_fixedLink[1]);
    b_R[6] = std::sin(rollPitchYaw_fixedLink[1]);
    b_R[2] = -std::sin(rollPitchYaw_fixedLink[1]);
    b_R[8] = std::cos(rollPitchYaw_fixedLink[1]);
    c_R[0] = 1.0;
    c_R[4] = std::cos(rollPitchYaw_fixedLink[0]);
    c_R[7] = -std::sin(rollPitchYaw_fixedLink[0]);
    c_R[5] = std::sin(rollPitchYaw_fixedLink[0]);
    c_R[8] = std::cos(rollPitchYaw_fixedLink[0]);
    for (info = 0; info < 3; info++) {
        wImu_H_fixedLink_0[info << 2] = wImu_R_fixedLink_0[3 * info];
        wImu_H_fixedLink_0[1 + (info << 2)] = wImu_R_fixedLink_0[3 * info + 1];
        wImu_H_fixedLink_0[2 + (info << 2)] = wImu_R_fixedLink_0[3 * info + 2];
        wImu_H_fixedLink_0[12 + info] = 0.0;
    }

    wImu_H_fixedLink_0[3] = 0.0;
    wImu_H_fixedLink_0[7] = 0.0;
    wImu_H_fixedLink_0[11] = 0.0;
    wImu_H_fixedLink_0[15] = 1.0;
    for (info = 0; info < 3; info++) {
        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            R_0[jAcol] = 0.0;
            R_0[jAcol] = R_0[3 * jBcol + info] + b_R[3 * jBcol] * R[info];
            R_0[jAcol] = b_R[3 * jBcol + 1] * R[info + 3] + R_0[3 * jBcol + info];
            R_0[jAcol] = b_R[3 * jBcol + 2] * R[info + 6] + R_0[3 * jBcol + info];
        }

        for (jBcol = 0; jBcol < 3; jBcol++) {
            jAcol = info + 3 * jBcol;
            R_1[jAcol] = 0.0;
            R_1[jAcol] = R_1[3 * jBcol + info] + c_R[3 * jBcol] * R_0[info];
            R_1[jAcol] = c_R[3 * jBcol + 1] * R_0[info + 3] + R_1[3 * jBcol + info];
            R_1[jAcol] = c_R[3 * jBcol + 2] * R_0[info + 6] + R_1[3 * jBcol + info];
        }
    }

    for (info = 0; info < 3; info++) {
        R_3[info << 2] = R_1[3 * info];
        R_3[1 + (info << 2)] = R_1[3 * info + 1];
        R_3[2 + (info << 2)] = R_1[3 * info + 2];
        R_3[12 + info] = 0.0;
    }

    R_3[3] = 0.0;
    R_3[7] = 0.0;
    R_3[11] = 0.0;
    R_3[15] = 1.0;
    for (info = 0; info < 4; info++) {
        for (jBcol = 0; jBcol < 4; jBcol++) {
            wImu_H_base[jBcol + (info << 2)] = 0.0;
            wImu_H_base[jBcol + (info << 2)] += rtu_fixedLink_H_base[info << 2] * R_3[jBcol];
            wImu_H_base[jBcol + (info << 2)] +=
                rtu_fixedLink_H_base[(info << 2) + 1] * R_3[jBcol + 4];
            wImu_H_base[jBcol + (info << 2)] +=
                rtu_fixedLink_H_base[(info << 2) + 2] * R_3[jBcol + 8];
            wImu_H_base[jBcol + (info << 2)] +=
                rtu_fixedLink_H_base[(info << 2) + 3] * R_3[jBcol + 12];
        }
    }

    memcpy(&localB->w_H_b[0], &wImu_H_base[0], sizeof(real_T) << 4U);
    torqueControlBalancing_mldivide(wImu_H_fixedLink_0, localB->w_H_b);

    /* '<S76>:1:5' */
    if (torqueControlBalancing_P->Config.CORRECT_NECK_IMU) {
        /* '<S76>:1:8' */
        /* '<S76>:1:10' */
        memcpy(&R_3[0], &B[0], sizeof(real_T) << 4U);
        torqueControlBalancing_xgetrf(R_3, ipiv, &info);
        rollPitchYaw_filtered_idx_0 = std::cos(rtu_neck_pos[0] + 1.5707963267948966);
        tmp_0[0] = rollPitchYaw_filtered_idx_0;
        rollPitchYaw_filtered_idx_1 = std::sin(rtu_neck_pos[0] + 1.5707963267948966);
        tmp_0[4] = -rollPitchYaw_filtered_idx_1 * 6.123233995736766E-17;
        tmp_0[8] = rollPitchYaw_filtered_idx_1;
        tmp_0[12] = rollPitchYaw_filtered_idx_0 * 0.0095;
        tmp_0[1] = rollPitchYaw_filtered_idx_1;
        tmp_0[5] = rollPitchYaw_filtered_idx_0 * 6.123233995736766E-17;
        tmp_0[9] = -rollPitchYaw_filtered_idx_0;
        tmp_0[13] = rollPitchYaw_filtered_idx_1 * 0.0095;
        rollPitchYaw_filtered_idx_0 = std::cos(rtu_neck_pos[1] - 1.5707963267948966);
        tmp_1[0] = rollPitchYaw_filtered_idx_0;
        rollPitchYaw_filtered_idx_1 = std::sin(rtu_neck_pos[1] - 1.5707963267948966);
        tmp_1[4] = -rollPitchYaw_filtered_idx_1 * 6.123233995736766E-17;
        tmp_1[8] = -rollPitchYaw_filtered_idx_1;
        tmp_1[12] = 0.0;
        tmp_1[1] = rollPitchYaw_filtered_idx_1;
        tmp_1[5] = rollPitchYaw_filtered_idx_0 * 6.123233995736766E-17;
        tmp_1[9] = -(-rollPitchYaw_filtered_idx_0);
        tmp_1[13] = 0.0;
        tmp_0[2] = 0.0;
        tmp_0[3] = 0.0;
        tmp_1[2] = 0.0;
        tmp_1[3] = 0.0;
        tmp_0[6] = 1.0;
        tmp_0[7] = 0.0;
        tmp_1[6] = -1.0;
        tmp_1[7] = 0.0;
        tmp_0[10] = 6.123233995736766E-17;
        tmp_0[11] = 0.0;
        tmp_1[10] = 6.123233995736766E-17;
        tmp_1[11] = 0.0;
        tmp_0[14] = 0.0;
        tmp_0[15] = 1.0;
        tmp_1[14] = 0.0;
        tmp_1[15] = 1.0;
        rollPitchYaw_filtered_idx_0 = std::cos(rtu_neck_pos[2] + 1.5707963267948966);
        tmp_3[0] = rollPitchYaw_filtered_idx_0;
        rollPitchYaw_filtered_idx_1 = std::sin(rtu_neck_pos[2] + 1.5707963267948966);
        tmp_3[4] = -rollPitchYaw_filtered_idx_1 * 6.123233995736766E-17;
        tmp_3[8] = -rollPitchYaw_filtered_idx_1;
        tmp_3[12] = rollPitchYaw_filtered_idx_0 * 0.0185;
        tmp_3[1] = rollPitchYaw_filtered_idx_1;
        tmp_3[5] = rollPitchYaw_filtered_idx_0 * 6.123233995736766E-17;
        tmp_3[9] = -(-rollPitchYaw_filtered_idx_0);
        tmp_3[13] = rollPitchYaw_filtered_idx_1 * 0.0185;
        for (info = 0; info < 4; info++) {
            for (jBcol = 0; jBcol < 4; jBcol++) {
                tmp_2[info + (jBcol << 2)] = 0.0;
                tmp_2[info + (jBcol << 2)] += tmp_1[jBcol << 2] * tmp_0[info];
                tmp_2[info + (jBcol << 2)] += tmp_1[(jBcol << 2) + 1] * tmp_0[info + 4];
                tmp_2[info + (jBcol << 2)] += tmp_1[(jBcol << 2) + 2] * tmp_0[info + 8];
                tmp_2[info + (jBcol << 2)] += tmp_1[(jBcol << 2) + 3] * tmp_0[info + 12];
            }

            tmp_3[2 + (info << 2)] = c[info];
            tmp_3[3 + (info << 2)] = b[info];
        }

        for (info = 0; info < 4; info++) {
            for (jBcol = 0; jBcol < 4; jBcol++) {
                tmp_0[info + (jBcol << 2)] = 0.0;
                tmp_0[info + (jBcol << 2)] += tmp_3[jBcol << 2] * tmp_2[info];
                tmp_0[info + (jBcol << 2)] += tmp_3[(jBcol << 2) + 1] * tmp_2[info + 4];
                tmp_0[info + (jBcol << 2)] += tmp_3[(jBcol << 2) + 2] * tmp_2[info + 8];
                tmp_0[info + (jBcol << 2)] += tmp_3[(jBcol << 2) + 3] * tmp_2[info + 12];
            }

            for (jBcol = 0; jBcol < 4; jBcol++) {
                wImu_H_wImuAssumingNeckToZero[info + (jBcol << 2)] = 0.0;
                wImu_H_wImuAssumingNeckToZero[info + (jBcol << 2)] += b_b[jBcol << 2] * tmp_0[info];
                wImu_H_wImuAssumingNeckToZero[info + (jBcol << 2)] +=
                    b_b[(jBcol << 2) + 1] * tmp_0[info + 4];
                wImu_H_wImuAssumingNeckToZero[info + (jBcol << 2)] +=
                    b_b[(jBcol << 2) + 2] * tmp_0[info + 8];
                wImu_H_wImuAssumingNeckToZero[info + (jBcol << 2)] +=
                    b_b[(jBcol << 2) + 3] * tmp_0[info + 12];
            }
        }

        for (info = 0; info < 4; info++) {
            jBcol = info << 2;
            jAcol = info << 2;
            for (wImu_R_fixedLink_0_tmp = 1; wImu_R_fixedLink_0_tmp <= info;
                 wImu_R_fixedLink_0_tmp++) {
                kBcol = (wImu_R_fixedLink_0_tmp - 1) << 2;
                if (R_3[(wImu_R_fixedLink_0_tmp + jAcol) - 1] != 0.0) {
                    wImu_H_wImuAssumingNeckToZero[jBcol] -=
                        R_3[(wImu_R_fixedLink_0_tmp + jAcol) - 1]
                        * wImu_H_wImuAssumingNeckToZero[kBcol];
                    wImu_H_wImuAssumingNeckToZero[1 + jBcol] -=
                        R_3[(wImu_R_fixedLink_0_tmp + jAcol) - 1]
                        * wImu_H_wImuAssumingNeckToZero[1 + kBcol];
                    wImu_H_wImuAssumingNeckToZero[2 + jBcol] -=
                        R_3[(wImu_R_fixedLink_0_tmp + jAcol) - 1]
                        * wImu_H_wImuAssumingNeckToZero[2 + kBcol];
                    wImu_H_wImuAssumingNeckToZero[3 + jBcol] -=
                        R_3[(wImu_R_fixedLink_0_tmp + jAcol) - 1]
                        * wImu_H_wImuAssumingNeckToZero[3 + kBcol];
                }
            }

            rollPitchYaw_filtered_idx_0 = 1.0 / R_3[info + jAcol];
            wImu_H_wImuAssumingNeckToZero[jBcol] *= rollPitchYaw_filtered_idx_0;
            wImu_H_wImuAssumingNeckToZero[1 + jBcol] *= rollPitchYaw_filtered_idx_0;
            wImu_H_wImuAssumingNeckToZero[2 + jBcol] *= rollPitchYaw_filtered_idx_0;
            wImu_H_wImuAssumingNeckToZero[3 + jBcol] *= rollPitchYaw_filtered_idx_0;
        }

        for (info = 3; info >= 0; info--) {
            jBcol = info << 2;
            jAcol = (info << 2) - 1;
            for (wImu_R_fixedLink_0_tmp = info + 2; wImu_R_fixedLink_0_tmp < 5;
                 wImu_R_fixedLink_0_tmp++) {
                kBcol = (wImu_R_fixedLink_0_tmp - 1) << 2;
                if (R_3[wImu_R_fixedLink_0_tmp + jAcol] != 0.0) {
                    wImu_H_wImuAssumingNeckToZero[jBcol] -=
                        R_3[wImu_R_fixedLink_0_tmp + jAcol] * wImu_H_wImuAssumingNeckToZero[kBcol];
                    wImu_H_wImuAssumingNeckToZero[1 + jBcol] -=
                        R_3[wImu_R_fixedLink_0_tmp + jAcol]
                        * wImu_H_wImuAssumingNeckToZero[1 + kBcol];
                    wImu_H_wImuAssumingNeckToZero[2 + jBcol] -=
                        R_3[wImu_R_fixedLink_0_tmp + jAcol]
                        * wImu_H_wImuAssumingNeckToZero[2 + kBcol];
                    wImu_H_wImuAssumingNeckToZero[3 + jBcol] -=
                        R_3[wImu_R_fixedLink_0_tmp + jAcol]
                        * wImu_H_wImuAssumingNeckToZero[3 + kBcol];
                }
            }
        }

        for (info = 2; info >= 0; info--) {
            if (info + 1 != ipiv[info]) {
                jBcol = ipiv[info] - 1;
                rollPitchYaw_filtered_idx_0 = wImu_H_wImuAssumingNeckToZero[info << 2];
                wImu_H_wImuAssumingNeckToZero[info << 2] =
                    wImu_H_wImuAssumingNeckToZero[jBcol << 2];
                wImu_H_wImuAssumingNeckToZero[jBcol << 2] = rollPitchYaw_filtered_idx_0;
                rollPitchYaw_filtered_idx_0 = wImu_H_wImuAssumingNeckToZero[(info << 2) + 1];
                wImu_H_wImuAssumingNeckToZero[1 + (info << 2)] =
                    wImu_H_wImuAssumingNeckToZero[(jBcol << 2) + 1];
                wImu_H_wImuAssumingNeckToZero[1 + (jBcol << 2)] = rollPitchYaw_filtered_idx_0;
                rollPitchYaw_filtered_idx_0 = wImu_H_wImuAssumingNeckToZero[(info << 2) + 2];
                wImu_H_wImuAssumingNeckToZero[2 + (info << 2)] =
                    wImu_H_wImuAssumingNeckToZero[(jBcol << 2) + 2];
                wImu_H_wImuAssumingNeckToZero[2 + (jBcol << 2)] = rollPitchYaw_filtered_idx_0;
                rollPitchYaw_filtered_idx_0 = wImu_H_wImuAssumingNeckToZero[(info << 2) + 3];
                wImu_H_wImuAssumingNeckToZero[3 + (info << 2)] =
                    wImu_H_wImuAssumingNeckToZero[(jBcol << 2) + 3];
                wImu_H_wImuAssumingNeckToZero[3 + (jBcol << 2)] = rollPitchYaw_filtered_idx_0;
            }
        }

        /* '<S76>:1:11' */
        /* '<S76>:1:12' */
        for (info = 0; info < 4; info++) {
            for (jBcol = 0; jBcol < 4; jBcol++) {
                localB->w_H_b[jBcol + (info << 2)] = 0.0;
                localB->w_H_b[jBcol + (info << 2)] +=
                    wImu_H_base[info << 2] * wImu_H_wImuAssumingNeckToZero[jBcol];
                localB->w_H_b[jBcol + (info << 2)] +=
                    wImu_H_base[(info << 2) + 1] * wImu_H_wImuAssumingNeckToZero[jBcol + 4];
                localB->w_H_b[jBcol + (info << 2)] +=
                    wImu_H_base[(info << 2) + 2] * wImu_H_wImuAssumingNeckToZero[jBcol + 8];
                localB->w_H_b[jBcol + (info << 2)] +=
                    wImu_H_base[(info << 2) + 3] * wImu_H_wImuAssumingNeckToZero[jBcol + 12];
            }
        }

        torqueControlBalancing_mldivide(wImu_H_fixedLink_0, localB->w_H_b);
    }
}

/*
 * System initialize for atomic system:
 *    '<S77>/MATLAB Function'
 *    '<S87>/MATLAB Function'
 */
void torqueCon_MATLABFunction_i_Init(DW_MATLABFunction_torqueCon_m_T* localDW)
{
    localDW->state_not_empty = false;
}

/*
 * Output and update for atomic system:
 *    '<S77>/MATLAB Function'
 *    '<S87>/MATLAB Function'
 */
void torqueControlB_MATLABFunction_i(const real_T rtu_s[16],
                                     B_MATLABFunction_torqueCont_m_T* localB,
                                     DW_MATLABFunction_torqueCon_m_T* localDW)
{
    /* MATLAB Function 'Utilities/holder /MATLAB Function': '<S81>:1' */
    if (!localDW->state_not_empty) {
        /* '<S81>:1:5' */
        /* '<S81>:1:6' */
        memcpy(&localDW->state[0], &rtu_s[0], sizeof(real_T) << 4U);
        localDW->state_not_empty = true;
    }

    /* '<S81>:1:9' */
    memcpy(&localB->s0[0], &localDW->state[0], sizeof(real_T) << 4U);
}

/*
 * System initialize for atomic system:
 *    '<S78>/MATLAB Function'
 *    '<S88>/MATLAB Function'
 */
void torqueCon_MATLABFunction_g_Init(DW_MATLABFunction_torqueCon_p_T* localDW)
{
    localDW->state_not_empty = false;
}

/*
 * Output and update for atomic system:
 *    '<S78>/MATLAB Function'
 *    '<S88>/MATLAB Function'
 */
void torqueControlB_MATLABFunction_o(const real_T rtu_s[12],
                                     B_MATLABFunction_torqueCont_p_T* localB,
                                     DW_MATLABFunction_torqueCon_p_T* localDW)
{
    /* MATLAB Function 'Utilities/holder /MATLAB Function': '<S83>:1' */
    if (!localDW->state_not_empty) {
        /* '<S83>:1:5' */
        /* '<S83>:1:6' */
        memcpy(&localDW->state[0], &rtu_s[0], 12U * sizeof(real_T));
        localDW->state_not_empty = true;
    }

    /* '<S83>:1:9' */
    memcpy(&localB->s0[0], &localDW->state[0], 12U * sizeof(real_T));
}

/*
 * Output and update for atomic system:
 *    '<S105>/MATLAB Function1'
 *    '<S105>/MATLAB Function2'
 */
void torqueControlBa_MATLABFunction1(const real_T rtu_d[3], B_MATLABFunction1_torqueContr_T* localB)
{
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Robot State and References/Update Gains and
     * References/Reshape Gains Matrices/MATLAB Function1': '<S109>:1' */
    /* '<S109>:1:3' */
    memset(&localB->D[0], 0, 9U * sizeof(real_T));
    localB->D[0] = rtu_d[0];
    localB->D[4] = rtu_d[1];
    localB->D[8] = rtu_d[2];
}

/* Function for MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
void torqueControlBalancingModelClass::torqueControlBalancing_xswap(real_T x[529],
                                                                    int32_T ix0,
                                                                    int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 23; k++) {
        temp = x[ix];
        x[ix] = x[iy];
        x[iy] = temp;
        ix += 23;
        iy += 23;
    }
}

/* Function for MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
void torqueControlBalancingModelClass::torqueControlBalancing_xgetrf_e(real_T A[529],
                                                                       int32_T ipiv[23],
                                                                       int32_T* info)
{
    int32_T j;
    int32_T c;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T k;
    int32_T jA;
    int32_T b_ix;
    int32_T d;
    int32_T ijA;
    for (j = 0; j < 23; j++) {
        ipiv[j] = 1 + j;
    }

    *info = 0;
    for (j = 0; j < 22; j++) {
        c = j * 24;
        jA = 1;
        ix = c;
        smax = std::abs(A[c]);
        for (k = 2; k <= 23 - j; k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                jA = k;
                smax = s;
            }
        }

        if (A[(c + jA) - 1] != 0.0) {
            if (jA - 1 != 0) {
                ipiv[j] = j + jA;
                torqueControlBalancing_xswap(A, j + 1, j + jA);
            }

            jA = (c - j) + 23;
            for (ix = c + 1; ix < jA; ix++) {
                A[ix] /= A[c];
            }
        }
        else {
            *info = j + 1;
        }

        jA = c;
        ix = c + 23;
        for (k = 1; k <= 22 - j; k++) {
            smax = A[ix];
            if (A[ix] != 0.0) {
                b_ix = c + 1;
                d = (jA - j) + 46;
                for (ijA = 24 + jA; ijA < d; ijA++) {
                    A[ijA] += A[b_ix] * -smax;
                    b_ix++;
                }
            }

            ix += 23;
            jA += 23;
        }
    }

    if ((*info == 0) && (!(A[528] != 0.0))) {
        *info = 23;
    }
}

/* Function for MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
void torqueControlBalancingModelClass::torqueControlBalancing_xtrsm(const real_T A[529],
                                                                    real_T B[529])
{
    real_T temp;
    int32_T jBcol;
    int32_T jAcol;
    int32_T kBcol;
    int32_T j;
    int32_T k;
    int32_T i;
    int32_T tmp;
    for (j = 0; j < 23; j++) {
        jBcol = 23 * j;
        jAcol = 23 * j;
        for (k = 1; k <= j; k++) {
            kBcol = (k - 1) * 23;
            if (A[(k + jAcol) - 1] != 0.0) {
                for (i = 0; i < 23; i++) {
                    tmp = i + jBcol;
                    B[tmp] -= A[(k + jAcol) - 1] * B[i + kBcol];
                }
            }
        }

        temp = 1.0 / A[j + jAcol];
        for (jAcol = 0; jAcol < 23; jAcol++) {
            tmp = jAcol + jBcol;
            B[tmp] *= temp;
        }
    }
}

/* Function for MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
void torqueControlBalancingModelClass::torqueControlBalancing_xtrsm_i(const real_T A[529],
                                                                      real_T B[529])
{
    int32_T jAcol;
    int32_T jBcol;
    int32_T kBcol;
    int32_T j;
    int32_T k;
    int32_T i;
    int32_T tmp;
    for (j = 22; j >= 0; j--) {
        jBcol = 23 * j;
        jAcol = 23 * j - 1;
        for (k = j + 2; k < 24; k++) {
            kBcol = (k - 1) * 23;
            if (A[k + jAcol] != 0.0) {
                for (i = 0; i < 23; i++) {
                    tmp = i + jBcol;
                    B[tmp] -= A[k + jAcol] * B[i + kBcol];
                }
            }
        }
    }
}

/* Function for MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
void torqueControlBalancingModelClass::torqueControlBalancing_mrdivide(const real_T A[529],
                                                                       const real_T B[529],
                                                                       real_T y[529])
{
    int32_T jp;
    int32_T ipiv[23];
    int32_T info;
    real_T temp;
    int32_T xi;
    memcpy(&torqueControlBalancing_B.b_A_c[0], &B[0], 529U * sizeof(real_T));
    torqueControlBalancing_xgetrf_e(torqueControlBalancing_B.b_A_c, ipiv, &info);
    memcpy(&y[0], &A[0], 529U * sizeof(real_T));
    torqueControlBalancing_xtrsm(torqueControlBalancing_B.b_A_c, y);
    torqueControlBalancing_xtrsm_i(torqueControlBalancing_B.b_A_c, y);
    for (info = 21; info >= 0; info--) {
        if (info + 1 != ipiv[info]) {
            jp = ipiv[info] - 1;
            for (xi = 0; xi < 23; xi++) {
                temp = y[23 * info + xi];
                y[xi + 23 * info] = y[23 * jp + xi];
                y[xi + 23 * jp] = temp;
            }
        }
    }
}

/* Function for MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
void torqueControlBalancingModelClass::t_computeMotorsReflectedInertia(const real_T Gamma[529],
                                                                       const real_T T[529],
                                                                       const real_T I_m[529],
                                                                       real_T reflectedInertia[529])
{
    static const real_T b[529] = {
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};

    int32_T i;
    int32_T i_0;
    int32_T i_1;
    int32_T T_tmp;
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            T_tmp = i + 23 * i_0;
            torqueControlBalancing_B.T[T_tmp] = 0.0;
            for (i_1 = 0; i_1 < 23; i_1++) {
                torqueControlBalancing_B.T[T_tmp] = T[23 * i_1 + i] * Gamma[23 * i_0 + i_1]
                                                    + torqueControlBalancing_B.T[23 * i_0 + i];
            }
        }
    }

    torqueControlBalancing_mrdivide(
        b, torqueControlBalancing_B.T, torqueControlBalancing_B.invTGamma);
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            T_tmp = i_0 + 23 * i;
            torqueControlBalancing_B.T[T_tmp] = 0.0;
            for (i_1 = 0; i_1 < 23; i_1++) {
                torqueControlBalancing_B.T[T_tmp] = T[23 * i_1 + i] * Gamma[23 * i_0 + i_1]
                                                    + torqueControlBalancing_B.T[23 * i + i_0];
            }
        }
    }

    torqueControlBalancing_mrdivide(
        b, torqueControlBalancing_B.T, torqueControlBalancing_B.invTGamma_t);
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            T_tmp = i_0 + 23 * i;
            torqueControlBalancing_B.T[T_tmp] = 0.0;
            for (i_1 = 0; i_1 < 23; i_1++) {
                torqueControlBalancing_B.T[T_tmp] =
                    torqueControlBalancing_B.invTGamma_t[23 * i_1 + i_0] * I_m[23 * i + i_1]
                    + torqueControlBalancing_B.T[23 * i + i_0];
            }
        }

        for (i = 0; i < 23; i++) {
            T_tmp = i_0 + 23 * i;
            reflectedInertia[T_tmp] = 0.0;
            for (i_1 = 0; i_1 < 23; i_1++) {
                reflectedInertia[T_tmp] = torqueControlBalancing_B.T[23 * i_1 + i_0]
                                              * torqueControlBalancing_B.invTGamma[23 * i + i_1]
                                          + reflectedInertia[23 * i + i_0];
            }
        }
    }
}

void rt_mldivided4x4(const real_T u0[16], const real_T u1[16], real_T y[16])
{
    real_T temp;
    real_T A[16];
    int8_T ipiv[4];
    int32_T j;
    int32_T ix;
    real_T s;
    int32_T iy;
    int32_T j_0;
    int32_T ijA;
    int32_T jBcol;
    int32_T kAcol;
    int32_T k;
    memcpy(&A[0], &u0[0], sizeof(real_T) << 4U);
    ipiv[0] = 1;
    ipiv[1] = 2;
    ipiv[2] = 3;
    ipiv[3] = 4;
    for (j = 0; j < 3; j++) {
        jBcol = j * 5 + 2;
        kAcol = j * 5;
        iy = 1;
        ix = jBcol - 2;
        temp = std::abs(A[kAcol]);
        for (k = 2; k <= 4 - j; k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > temp) {
                iy = k;
                temp = s;
            }
        }

        if (A[(jBcol + iy) - 3] != 0.0) {
            if (iy - 1 != 0) {
                iy += j;
                ipiv[j] = (int8_T) iy;
                iy--;
                temp = A[j];
                A[j] = A[iy];
                A[iy] = temp;
                ix = j + 4;
                iy += 4;
                temp = A[ix];
                A[ix] = A[iy];
                A[iy] = temp;
                ix += 4;
                iy += 4;
                temp = A[ix];
                A[ix] = A[iy];
                A[iy] = temp;
                ix += 4;
                iy += 4;
                temp = A[ix];
                A[ix] = A[iy];
                A[iy] = temp;
            }

            k = jBcol - j;
            for (ix = jBcol - 1; ix < k + 2; ix++) {
                A[ix] /= A[kAcol];
            }
        }

        iy = kAcol;
        kAcol += 4;
        for (j_0 = 1; j_0 <= 3 - j; j_0++) {
            if (A[kAcol] != 0.0) {
                temp = -A[kAcol];
                ix = jBcol - 1;
                k = iy - j;
                for (ijA = 5 + iy; ijA < k + 8; ijA++) {
                    A[ijA] += A[ix] * temp;
                    ix++;
                }
            }

            kAcol += 4;
            iy += 4;
        }
    }

    memcpy(&y[0], &u1[0], sizeof(real_T) << 4U);
    for (j = 0; j < 3; j++) {
        if (j + 1 != ipiv[j]) {
            jBcol = ipiv[j] - 1;
            temp = y[j];
            y[j] = y[jBcol];
            y[jBcol] = temp;
            temp = y[j + 4];
            y[j + 4] = y[jBcol + 4];
            y[jBcol + 4] = temp;
            temp = y[j + 8];
            y[j + 8] = y[jBcol + 8];
            y[jBcol + 8] = temp;
            temp = y[j + 12];
            y[j + 12] = y[jBcol + 12];
            y[jBcol + 12] = temp;
        }
    }

    for (j = 0; j < 4; j++) {
        jBcol = j << 2;
        if (y[jBcol] != 0.0) {
            for (ix = 1; ix + 1 < 5; ix++) {
                y[ix + jBcol] -= y[jBcol] * A[ix];
            }
        }

        if (y[1 + jBcol] != 0.0) {
            for (ix = 2; ix + 1 < 5; ix++) {
                y[ix + jBcol] -= y[1 + jBcol] * A[ix + 4];
            }
        }

        if (y[2 + jBcol] != 0.0) {
            for (ix = 3; ix + 1 < 5; ix++) {
                y[ix + jBcol] -= y[2 + jBcol] * A[ix + 8];
            }
        }
    }

    for (j = 0; j < 4; j++) {
        jBcol = j << 2;
        if (y[3 + jBcol] != 0.0) {
            y[3 + jBcol] /= A[15];
            for (ix = 0; ix < 3; ix++) {
                y[ix + jBcol] -= y[3 + jBcol] * A[ix + 12];
            }
        }

        if (y[2 + jBcol] != 0.0) {
            y[2 + jBcol] /= A[10];
            for (ix = 0; ix < 2; ix++) {
                y[ix + jBcol] -= y[2 + jBcol] * A[ix + 8];
            }
        }

        if (y[1 + jBcol] != 0.0) {
            y[1 + jBcol] /= A[5];
            for (ix = 0; ix < 1; ix++) {
                y[ix + jBcol] -= y[1 + jBcol] * A[ix + 4];
            }
        }

        if (y[jBcol] != 0.0) {
            y[jBcol] /= A[0];
        }
    }
}

/* Function for MATLAB Function: '<S64>/STATE MACHINE' */
void torqueControlBalancingModelClass::torqueControlBalancing_xgetrf_a(real_T A[16],
                                                                       int32_T ipiv[4],
                                                                       int32_T* info)
{
    int32_T j;
    int32_T c;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T k;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    ipiv[0] = 1;
    ipiv[1] = 2;
    ipiv[2] = 3;
    ipiv[3] = 4;
    *info = 0;
    for (j = 0; j < 3; j++) {
        c = j * 5;
        iy = 0;
        ix = c;
        smax = std::abs(A[c]);
        for (k = 2; k <= 4 - j; k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                iy = k - 1;
                smax = s;
            }
        }

        if (A[c + iy] != 0.0) {
            if (iy != 0) {
                iy += j;
                ipiv[j] = iy + 1;
                smax = A[j];
                A[j] = A[iy];
                A[iy] = smax;
                ix = j + 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
                ix += 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
                ix += 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
            }

            iy = (c - j) + 4;
            for (ix = c + 1; ix < iy; ix++) {
                A[ix] /= A[c];
            }
        }
        else {
            *info = j + 1;
        }

        iy = c;
        ix = c + 4;
        for (k = 1; k <= 3 - j; k++) {
            smax = A[ix];
            if (A[ix] != 0.0) {
                c_ix = c + 1;
                d = (iy - j) + 8;
                for (ijA = 5 + iy; ijA < d; ijA++) {
                    A[ijA] += A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 4;
            iy += 4;
        }
    }

    if ((*info == 0) && (!(A[15] != 0.0))) {
        *info = 4;
    }
}

/* Function for MATLAB Function: '<S64>/STATE MACHINE' */
void torqueControlBalancingModelClass::torqueControlBalanci_mrdivide_h(real_T A[16],
                                                                       const real_T B[16])
{
    real_T b_A[16];
    int32_T ipiv[4];
    int32_T info;
    real_T b_temp;
    int32_T jBcol;
    int32_T jAcol;
    int32_T kBcol;
    int32_T k;
    memcpy(&b_A[0], &B[0], sizeof(real_T) << 4U);
    torqueControlBalancing_xgetrf_a(b_A, ipiv, &info);
    for (info = 0; info < 4; info++) {
        jBcol = info << 2;
        jAcol = info << 2;
        for (k = 1; k <= info; k++) {
            kBcol = (k - 1) << 2;
            if (b_A[(k + jAcol) - 1] != 0.0) {
                A[jBcol] -= b_A[(k + jAcol) - 1] * A[kBcol];
                A[1 + jBcol] -= b_A[(k + jAcol) - 1] * A[1 + kBcol];
                A[2 + jBcol] -= b_A[(k + jAcol) - 1] * A[2 + kBcol];
                A[3 + jBcol] -= b_A[(k + jAcol) - 1] * A[3 + kBcol];
            }
        }

        b_temp = 1.0 / b_A[info + jAcol];
        A[jBcol] *= b_temp;
        A[1 + jBcol] *= b_temp;
        A[2 + jBcol] *= b_temp;
        A[3 + jBcol] *= b_temp;
    }

    for (info = 3; info >= 0; info--) {
        jBcol = info << 2;
        jAcol = (info << 2) - 1;
        for (k = info + 2; k < 5; k++) {
            kBcol = (k - 1) << 2;
            if (b_A[k + jAcol] != 0.0) {
                A[jBcol] -= b_A[k + jAcol] * A[kBcol];
                A[1 + jBcol] -= b_A[k + jAcol] * A[1 + kBcol];
                A[2 + jBcol] -= b_A[k + jAcol] * A[2 + kBcol];
                A[3 + jBcol] -= b_A[k + jAcol] * A[3 + kBcol];
            }
        }
    }

    for (info = 2; info >= 0; info--) {
        if (info + 1 != ipiv[info]) {
            jBcol = ipiv[info] - 1;
            b_temp = A[info << 2];
            A[info << 2] = A[jBcol << 2];
            A[jBcol << 2] = b_temp;
            b_temp = A[(info << 2) + 1];
            A[1 + (info << 2)] = A[(jBcol << 2) + 1];
            A[1 + (jBcol << 2)] = b_temp;
            b_temp = A[(info << 2) + 2];
            A[2 + (info << 2)] = A[(jBcol << 2) + 2];
            A[2 + (jBcol << 2)] = b_temp;
            b_temp = A[(info << 2) + 3];
            A[3 + (info << 2)] = A[(jBcol << 2) + 3];
            A[3 + (jBcol << 2)] = b_temp;
        }
    }
}

/* Function for MATLAB Function: '<S64>/STATE MACHINE' */
void torqueControlBalancingModelClass::torqueControlBalanci_mldivide_o(const real_T A[16],
                                                                       real_T B[4])
{
    real_T temp;
    real_T b_A[16];
    int32_T ipiv[4];
    int32_T info;
    memcpy(&b_A[0], &A[0], sizeof(real_T) << 4U);
    torqueControlBalancing_xgetrf_a(b_A, ipiv, &info);
    if (ipiv[0] != 1) {
        temp = B[0];
        B[0] = B[ipiv[0] - 1];
        B[ipiv[0] - 1] = temp;
    }

    if (ipiv[1] != 2) {
        temp = B[1];
        B[1] = B[ipiv[1] - 1];
        B[ipiv[1] - 1] = temp;
    }

    if (ipiv[2] != 3) {
        temp = B[2];
        B[2] = B[ipiv[2] - 1];
        B[ipiv[2] - 1] = temp;
    }

    if (B[0] != 0.0) {
        for (info = 1; info + 1 < 5; info++) {
            B[info] -= B[0] * b_A[info];
        }
    }

    if (B[1] != 0.0) {
        for (info = 2; info + 1 < 5; info++) {
            B[info] -= b_A[info + 4] * B[1];
        }
    }

    if (B[2] != 0.0) {
        for (info = 3; info + 1 < 5; info++) {
            B[info] -= b_A[info + 8] * B[2];
        }
    }

    if (B[3] != 0.0) {
        B[3] /= b_A[15];
        for (info = 0; info < 3; info++) {
            B[info] -= b_A[info + 12] * B[3];
        }
    }

    if (B[2] != 0.0) {
        B[2] /= b_A[10];
        for (info = 0; info < 2; info++) {
            B[info] -= b_A[info + 8] * B[2];
        }
    }

    if (B[1] != 0.0) {
        B[1] /= b_A[5];
        for (info = 0; info < 1; info++) {
            B[info] -= b_A[info + 4] * B[1];
        }
    }

    if (B[0] != 0.0) {
        B[0] /= b_A[0];
    }
}

/* Function for MATLAB Function: '<S64>/STATE MACHINE' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_norm(const real_T x[6])
{
    real_T y;
    real_T scale;
    real_T absxk;
    real_T t;
    int32_T k;
    y = 0.0;
    scale = 3.3121686421112381E-170;
    for (k = 0; k < 6; k++) {
        absxk = std::abs(x[k]);
        if (absxk > scale) {
            t = scale / absxk;
            y = y * t * t + 1.0;
            scale = absxk;
        }
        else {
            t = absxk / scale;
            y += t * t;
        }
    }

    return scale * std::sqrt(y);
}

/* Function for MATLAB Function: '<S62>/Compute Base Velocity' */
void torqueControlBalancingModelClass::torqueControlBalan_pinvDamped_i(const real_T A[72],
                                                                       real_T regDamp,
                                                                       real_T pinvDampA[72])
{
    real_T b_A[144];
    int8_T ipiv[12];
    int32_T j;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    int32_T jBcol;
    int32_T kBcol;
    static const int8_T b_b[144] = {
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};

    for (j = 0; j < 12; j++) {
        for (jBcol = 0; jBcol < 12; jBcol++) {
            smax = 0.0;
            for (iy = 0; iy < 6; iy++) {
                smax += A[12 * iy + j] * A[12 * iy + jBcol];
            }

            b_A[j + 12 * jBcol] = (real_T) b_b[12 * jBcol + j] * regDamp + smax;
        }

        ipiv[j] = (int8_T)(1 + j);
    }

    for (j = 0; j < 11; j++) {
        jBcol = j * 13;
        iy = 0;
        ix = jBcol;
        smax = std::abs(b_A[jBcol]);
        for (kBcol = 2; kBcol <= 12 - j; kBcol++) {
            ix++;
            s = std::abs(b_A[ix]);
            if (s > smax) {
                iy = kBcol - 1;
                smax = s;
            }
        }

        if (b_A[jBcol + iy] != 0.0) {
            if (iy != 0) {
                iy += j;
                ipiv[j] = (int8_T)(iy + 1);
                ix = j;
                for (kBcol = 0; kBcol < 12; kBcol++) {
                    smax = b_A[ix];
                    b_A[ix] = b_A[iy];
                    b_A[iy] = smax;
                    ix += 12;
                    iy += 12;
                }
            }

            iy = (jBcol - j) + 12;
            for (ix = jBcol + 1; ix < iy; ix++) {
                b_A[ix] /= b_A[jBcol];
            }
        }

        iy = jBcol;
        ix = jBcol + 12;
        for (kBcol = 1; kBcol <= 11 - j; kBcol++) {
            smax = b_A[ix];
            if (b_A[ix] != 0.0) {
                c_ix = jBcol + 1;
                d = (iy - j) + 24;
                for (ijA = 13 + iy; ijA < d; ijA++) {
                    b_A[ijA] += b_A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 12;
            iy += 12;
        }
    }

    for (j = 0; j < 12; j++) {
        for (jBcol = 0; jBcol < 6; jBcol++) {
            pinvDampA[jBcol + 6 * j] = A[12 * jBcol + j];
        }
    }

    for (j = 0; j < 12; j++) {
        jBcol = 6 * j;
        iy = 12 * j;
        for (ix = 1; ix <= j; ix++) {
            kBcol = (ix - 1) * 6;
            if (b_A[(ix + iy) - 1] != 0.0) {
                for (c_ix = 0; c_ix < 6; c_ix++) {
                    d = c_ix + jBcol;
                    pinvDampA[d] -= b_A[(ix + iy) - 1] * pinvDampA[c_ix + kBcol];
                }
            }
        }

        smax = 1.0 / b_A[j + iy];
        for (iy = 0; iy < 6; iy++) {
            d = iy + jBcol;
            pinvDampA[d] *= smax;
        }
    }

    for (j = 11; j >= 0; j--) {
        jBcol = 6 * j;
        iy = 12 * j - 1;
        for (ix = j + 2; ix < 13; ix++) {
            kBcol = (ix - 1) * 6;
            if (b_A[ix + iy] != 0.0) {
                for (c_ix = 0; c_ix < 6; c_ix++) {
                    pinvDampA[c_ix + jBcol] -= b_A[ix + iy] * pinvDampA[c_ix + kBcol];
                }
            }
        }
    }

    for (j = 10; j >= 0; j--) {
        if (j + 1 != ipiv[j]) {
            jBcol = ipiv[j] - 1;
            for (iy = 0; iy < 6; iy++) {
                smax = pinvDampA[6 * j + iy];
                pinvDampA[iy + 6 * j] = pinvDampA[6 * jBcol + iy];
                pinvDampA[iy + 6 * jBcol] = smax;
            }
        }
    }
}

/* Function for MATLAB Function: '<S45>/Add motor reflected inertias' */
void torqueControlBalancingModelClass::torqu_addMotorsReflectedInertia(const real_T M[841],
                                                                       const real_T Gamma[529],
                                                                       const real_T T[529],
                                                                       const real_T I_m[529],
                                                                       real_T M_with_inertia[841])
{
    int32_T i;
    int32_T i_0;
    int32_T M_with_inertia_tmp;
    t_computeMotorsReflectedInertia(Gamma, T, I_m, torqueControlBalancing_B.reflectedInertia_p);
    for (i_0 = 0; i_0 < 29; i_0++) {
        for (i = 0; i < 6; i++) {
            torqueControlBalancing_B.dv0[i + 29 * i_0] = 0.0;
        }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        memset(&torqueControlBalancing_B.dv0[i_0 * 29 + 6], 0, 23U * sizeof(real_T));
    }

    for (i_0 = 0; i_0 < 23; i_0++) {
        memcpy(&torqueControlBalancing_B.dv0[i_0 * 29 + 180],
               &torqueControlBalancing_B.reflectedInertia_p[i_0 * 23],
               23U * sizeof(real_T));
    }

    for (i_0 = 0; i_0 < 29; i_0++) {
        for (i = 0; i < 29; i++) {
            M_with_inertia_tmp = 29 * i_0 + i;
            M_with_inertia[i + 29 * i_0] =
                M[M_with_inertia_tmp] + torqueControlBalancing_B.dv0[M_with_inertia_tmp];
        }
    }
}

void rt_invd4x4(const real_T u[16], real_T y[16])
{
    int8_T p[4];
    real_T A[16];
    int8_T ipiv[4];
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T iy;
    int32_T j;
    int32_T ijA;
    int32_T pipk;
    int32_T k;
    int32_T jBcol;
    int32_T kAcol;
    for (pipk = 0; pipk < 16; pipk++) {
        y[pipk] = 0.0;
        A[pipk] = u[pipk];
    }

    ipiv[0] = 1;
    ipiv[1] = 2;
    ipiv[2] = 3;
    for (pipk = 0; pipk < 3; pipk++) {
        jBcol = pipk * 5 + 2;
        kAcol = pipk * 5;
        iy = 1;
        ix = jBcol - 2;
        smax = std::abs(A[kAcol]);
        for (k = 2; k <= 4 - pipk; k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                iy = k;
                smax = s;
            }
        }

        if (A[(jBcol + iy) - 3] != 0.0) {
            if (iy - 1 != 0) {
                iy += pipk;
                ipiv[pipk] = (int8_T) iy;
                iy--;
                smax = A[pipk];
                A[pipk] = A[iy];
                A[iy] = smax;
                ix = pipk + 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
                ix += 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
                ix += 4;
                iy += 4;
                smax = A[ix];
                A[ix] = A[iy];
                A[iy] = smax;
            }

            k = jBcol - pipk;
            for (ix = jBcol - 1; ix < k + 2; ix++) {
                A[ix] /= A[kAcol];
            }
        }

        iy = kAcol;
        kAcol += 4;
        for (j = 1; j <= 3 - pipk; j++) {
            if (A[kAcol] != 0.0) {
                smax = -A[kAcol];
                ix = jBcol - 1;
                k = iy - pipk;
                for (ijA = 5 + iy; ijA < k + 8; ijA++) {
                    A[ijA] += A[ix] * smax;
                    ix++;
                }
            }

            kAcol += 4;
            iy += 4;
        }
    }

    p[0] = 1;
    p[1] = 2;
    p[2] = 3;
    p[3] = 4;
    if (ipiv[0] > 1) {
        jBcol = ipiv[0] - 1;
        pipk = p[jBcol];
        p[jBcol] = 1;
        p[0] = (int8_T) pipk;
    }

    if (ipiv[1] > 2) {
        jBcol = ipiv[1] - 1;
        pipk = p[jBcol];
        p[jBcol] = p[1];
        p[1] = (int8_T) pipk;
    }

    if (ipiv[2] > 3) {
        jBcol = ipiv[2] - 1;
        pipk = p[jBcol];
        p[jBcol] = p[2];
        p[2] = (int8_T) pipk;
    }

    jBcol = p[0] - 1;
    y[(p[0] - 1) << 2] = 1.0;
    for (pipk = 0; pipk + 1 < 5; pipk++) {
        if (y[(jBcol << 2) + pipk] != 0.0) {
            for (ix = pipk + 1; ix + 1 < 5; ix++) {
                y[ix + (jBcol << 2)] -= y[(jBcol << 2) + pipk] * A[(pipk << 2) + ix];
            }
        }
    }

    jBcol = p[1] - 1;
    y[1 + ((p[1] - 1) << 2)] = 1.0;
    for (pipk = 1; pipk + 1 < 5; pipk++) {
        if (y[(jBcol << 2) + pipk] != 0.0) {
            for (ix = pipk + 1; ix + 1 < 5; ix++) {
                y[ix + (jBcol << 2)] -= y[(jBcol << 2) + pipk] * A[(pipk << 2) + ix];
            }
        }
    }

    jBcol = p[2] - 1;
    y[2 + ((p[2] - 1) << 2)] = 1.0;
    for (pipk = 2; pipk + 1 < 5; pipk++) {
        if (y[(jBcol << 2) + pipk] != 0.0) {
            for (ix = pipk + 1; ix + 1 < 5; ix++) {
                y[ix + (jBcol << 2)] -= y[(jBcol << 2) + pipk] * A[(pipk << 2) + ix];
            }
        }
    }

    jBcol = p[3] - 1;
    y[3 + ((p[3] - 1) << 2)] = 1.0;
    for (pipk = 3; pipk + 1 < 5; pipk++) {
        if (y[(jBcol << 2) + pipk] != 0.0) {
            for (ix = pipk + 1; ix + 1 < 5; ix++) {
                y[ix + (jBcol << 2)] -= y[(jBcol << 2) + pipk] * A[(pipk << 2) + ix];
            }
        }
    }

    for (pipk = 0; pipk < 4; pipk++) {
        jBcol = pipk << 2;
        if (y[3 + jBcol] != 0.0) {
            y[3 + jBcol] /= A[15];
            for (ix = 0; ix < 3; ix++) {
                y[ix + jBcol] -= y[3 + jBcol] * A[ix + 12];
            }
        }

        if (y[2 + jBcol] != 0.0) {
            y[2 + jBcol] /= A[10];
            for (ix = 0; ix < 2; ix++) {
                y[ix + jBcol] -= y[2 + jBcol] * A[ix + 8];
            }
        }

        if (y[1 + jBcol] != 0.0) {
            y[1 + jBcol] /= A[5];
            for (ix = 0; ix < 1; ix++) {
                y[ix + jBcol] -= y[1 + jBcol] * A[ix + 4];
            }
        }

        if (y[jBcol] != 0.0) {
            y[jBcol] /= A[0];
        }
    }
}

/* Function for MATLAB Function: '<S21>/Get Equivalent Base Velocity' */
void torqueControlBalancingModelClass::torqueControlBalanci_mldivide_l(const real_T A[36],
                                                                       real_T B[36])
{
    int32_T ip;
    real_T b_A[36];
    int8_T ipiv[6];
    int32_T j;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T k;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    memcpy(&b_A[0], &A[0], 36U * sizeof(real_T));
    for (c_ix = 0; c_ix < 6; c_ix++) {
        ipiv[c_ix] = (int8_T)(1 + c_ix);
    }

    for (j = 0; j < 5; j++) {
        ip = j * 7;
        iy = 0;
        ix = ip;
        smax = std::abs(b_A[ip]);
        for (k = 2; k <= 6 - j; k++) {
            ix++;
            s = std::abs(b_A[ix]);
            if (s > smax) {
                iy = k - 1;
                smax = s;
            }
        }

        if (b_A[ip + iy] != 0.0) {
            if (iy != 0) {
                iy += j;
                ipiv[j] = (int8_T)(iy + 1);
                ix = j;
                for (k = 0; k < 6; k++) {
                    smax = b_A[ix];
                    b_A[ix] = b_A[iy];
                    b_A[iy] = smax;
                    ix += 6;
                    iy += 6;
                }
            }

            iy = (ip - j) + 6;
            for (ix = ip + 1; ix < iy; ix++) {
                b_A[ix] /= b_A[ip];
            }
        }

        iy = ip;
        ix = ip + 6;
        for (k = 1; k <= 5 - j; k++) {
            smax = b_A[ix];
            if (b_A[ix] != 0.0) {
                c_ix = ip + 1;
                d = (iy - j) + 12;
                for (ijA = 7 + iy; ijA < d; ijA++) {
                    b_A[ijA] += b_A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 6;
            iy += 6;
        }
    }

    for (j = 0; j < 5; j++) {
        if (j + 1 != ipiv[j]) {
            ip = ipiv[j] - 1;
            for (iy = 0; iy < 6; iy++) {
                smax = B[6 * iy + j];
                B[j + 6 * iy] = B[6 * iy + ip];
                B[ip + 6 * iy] = smax;
            }
        }
    }

    for (j = 0; j < 6; j++) {
        ip = 6 * j;
        for (iy = 0; iy < 6; iy++) {
            ix = 6 * iy;
            if (B[iy + ip] != 0.0) {
                for (k = iy + 1; k + 1 < 7; k++) {
                    c_ix = k + ip;
                    B[c_ix] -= B[iy + ip] * b_A[k + ix];
                }
            }
        }
    }

    for (j = 0; j < 6; j++) {
        ip = 6 * j;
        for (iy = 5; iy >= 0; iy--) {
            ix = 6 * iy;
            if (B[iy + ip] != 0.0) {
                B[iy + ip] /= b_A[iy + ix];
                for (k = 0; k < iy; k++) {
                    c_ix = k + ip;
                    B[c_ix] -= B[iy + ip] * b_A[k + ix];
                }
            }
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_blkdiag(const real_T varargin_1[9],
                                                                      const real_T varargin_2[9],
                                                                      real_T y[36])
{
    int32_T i;
    int32_T y_tmp;
    int32_T y_tmp_0;
    memset(&y[0], 0, 36U * sizeof(real_T));
    for (i = 0; i < 3; i++) {
        y[6 * i] = varargin_1[3 * i];
        y_tmp_0 = 6 * (3 + i);
        y[3 + y_tmp_0] = varargin_2[3 * i];
        y_tmp = 3 * i + 1;
        y[1 + 6 * i] = varargin_1[y_tmp];
        y[4 + y_tmp_0] = varargin_2[y_tmp];
        y_tmp = 3 * i + 2;
        y[2 + 6 * i] = varargin_1[y_tmp];
        y[5 + y_tmp_0] = varargin_2[y_tmp];
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_xnrm2(int32_T n,
                                                                      const real_T x[72],
                                                                      int32_T ix0)
{
    real_T y;
    real_T scale;
    int32_T kend;
    real_T absxk;
    real_T t;
    int32_T k;
    y = 0.0;
    if (!(n < 1)) {
        if (n == 1) {
            y = std::abs(x[ix0 - 1]);
        }
        else {
            scale = 3.3121686421112381E-170;
            kend = (ix0 + n) - 1;
            for (k = ix0; k <= kend; k++) {
                absxk = std::abs(x[k - 1]);
                if (absxk > scale) {
                    t = scale / absxk;
                    y = y * t * t + 1.0;
                    scale = absxk;
                }
                else {
                    t = absxk / scale;
                    y += t * t;
                }
            }

            y = scale * std::sqrt(y);
        }
    }

    return y;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_xnrm2_h(int32_T n,
                                                                        const real_T x[6],
                                                                        int32_T ix0)
{
    real_T y;
    real_T scale;
    int32_T kend;
    real_T absxk;
    real_T t;
    int32_T k;
    y = 0.0;
    if (!(n < 1)) {
        if (n == 1) {
            y = std::abs(x[ix0 - 1]);
        }
        else {
            scale = 3.3121686421112381E-170;
            kend = (ix0 + n) - 1;
            for (k = ix0; k <= kend; k++) {
                absxk = std::abs(x[k - 1]);
                if (absxk > scale) {
                    t = scale / absxk;
                    y = y * t * t + 1.0;
                    scale = absxk;
                }
                else {
                    t = absxk / scale;
                    y += t * t;
                }
            }

            y = scale * std::sqrt(y);
        }
    }

    return y;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xaxpy_cf(int32_T n,
                                                                       real_T a,
                                                                       const real_T x[12],
                                                                       int32_T ix0,
                                                                       real_T y[72],
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * x[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xaxpy_c(int32_T n,
                                                                      real_T a,
                                                                      const real_T x[72],
                                                                      int32_T ix0,
                                                                      real_T y[12],
                                                                      int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * x[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_xdotc(int32_T n,
                                                                      const real_T x[72],
                                                                      int32_T ix0,
                                                                      const real_T y[72],
                                                                      int32_T iy0)
{
    real_T d;
    int32_T ix;
    int32_T iy;
    int32_T k;
    d = 0.0;
    if (!(n < 1)) {
        ix = ix0;
        iy = iy0;
        for (k = 1; k <= n; k++) {
            d += x[ix - 1] * y[iy - 1];
            ix++;
            iy++;
        }
    }

    return d;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xaxpy(int32_T n,
                                                                    real_T a,
                                                                    int32_T ix0,
                                                                    real_T y[72],
                                                                    int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * y[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_xdotc_i(int32_T n,
                                                                        const real_T x[36],
                                                                        int32_T ix0,
                                                                        const real_T y[36],
                                                                        int32_T iy0)
{
    real_T d;
    int32_T ix;
    int32_T iy;
    int32_T k;
    d = 0.0;
    if (!(n < 1)) {
        ix = ix0;
        iy = iy0;
        for (k = 1; k <= n; k++) {
            d += x[ix - 1] * y[iy - 1];
            ix++;
            iy++;
        }
    }

    return d;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancin_xaxpy_cfu(int32_T n,
                                                                       real_T a,
                                                                       int32_T ix0,
                                                                       real_T y[36],
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * y[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xscal(real_T a,
                                                                    real_T x[72],
                                                                    int32_T ix0)
{
    int32_T k;
    for (k = ix0; k <= ix0 + 11; k++) {
        x[k - 1] *= a;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xscal_m(real_T a,
                                                                      real_T x[36],
                                                                      int32_T ix0)
{
    int32_T k;
    for (k = ix0; k <= ix0 + 5; k++) {
        x[k - 1] *= a;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xswap_h(real_T x[36],
                                                                      int32_T ix0,
                                                                      int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 6; k++) {
        temp = x[ix];
        x[ix] = x[iy];
        x[iy] = temp;
        ix++;
        iy++;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xswap_hc(real_T x[72],
                                                                       int32_T ix0,
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 12; k++) {
        temp = x[ix];
        x[ix] = x[iy];
        x[iy] = temp;
        ix++;
        iy++;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xrotg(real_T* a,
                                                                    real_T* b,
                                                                    real_T* c,
                                                                    real_T* s)
{
    real_T roe;
    real_T absa;
    real_T absb;
    real_T scale;
    real_T ads;
    real_T bds;
    roe = *b;
    absa = std::abs(*a);
    absb = std::abs(*b);
    if (absa > absb) {
        roe = *a;
    }

    scale = absa + absb;
    if (scale == 0.0) {
        *s = 0.0;
        *c = 1.0;
        absa = 0.0;
    }
    else {
        ads = absa / scale;
        bds = absb / scale;
        scale *= std::sqrt(ads * ads + bds * bds);
        if (roe < 0.0) {
            scale = -scale;
        }

        *c = *a / scale;
        *s = *b / scale;
        if (absa > absb) {
            absa = *s;
        }
        else if (*c != 0.0) {
            absa = 1.0 / *c;
        }
        else {
            absa = 1.0;
        }
    }

    *a = scale;
    *b = absa;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xrot(real_T x[36],
                                                                   int32_T ix0,
                                                                   int32_T iy0,
                                                                   real_T c,
                                                                   real_T s)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 6; k++) {
        temp = c * x[ix] + s * x[iy];
        x[iy] = c * x[iy] - s * x[ix];
        x[ix] = temp;
        iy++;
        ix++;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xrot_f(real_T x[72],
                                                                     int32_T ix0,
                                                                     int32_T iy0,
                                                                     real_T c,
                                                                     real_T s)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 12; k++) {
        temp = c * x[ix] + s * x[iy];
        x[iy] = c * x[iy] - s * x[ix];
        x[ix] = temp;
        iy++;
        ix++;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_svd(const real_T A[72],
                                                                  real_T U[72],
                                                                  real_T s[6],
                                                                  real_T V[36])
{
    real_T b_A[72];
    real_T b_s[6];
    real_T e[6];
    real_T work[12];
    real_T Vf[36];
    int32_T qq;
    boolean_T apply_transform;
    real_T nrm;
    int32_T qjj;
    int32_T qp1jj;
    int32_T qp1q;
    real_T rt;
    real_T ztest;
    real_T smm1;
    real_T emm1;
    real_T sqds;
    real_T shift;
    int32_T j_ii;
    int32_T i;
    int32_T exitg1;
    boolean_T exitg2;
    memcpy(&b_A[0], &A[0], 72U * sizeof(real_T));
    for (i = 0; i < 6; i++) {
        b_s[i] = 0.0;
        e[i] = 0.0;
    }

    memset(&work[0], 0, 12U * sizeof(real_T));
    memset(&U[0], 0, 72U * sizeof(real_T));
    memset(&Vf[0], 0, 36U * sizeof(real_T));
    for (i = 0; i < 6; i++) {
        qq = 12 * i + i;
        apply_transform = false;
        nrm = torqueControlBalancing_xnrm2(12 - i, b_A, qq + 1);
        if (nrm > 0.0) {
            apply_transform = true;
            if (b_A[qq] < 0.0) {
                b_s[i] = -nrm;
            }
            else {
                b_s[i] = nrm;
            }

            if (std::abs(b_s[i]) >= 1.0020841800044864E-292) {
                nrm = 1.0 / b_s[i];
                qp1q = (qq - i) + 12;
                for (qjj = qq; qjj < qp1q; qjj++) {
                    b_A[qjj] *= nrm;
                }
            }
            else {
                qp1q = (qq - i) + 12;
                for (qjj = qq; qjj < qp1q; qjj++) {
                    b_A[qjj] /= b_s[i];
                }
            }

            b_A[qq]++;
            b_s[i] = -b_s[i];
        }
        else {
            b_s[i] = 0.0;
        }

        for (qp1q = i + 1; qp1q + 1 < 7; qp1q++) {
            qjj = 12 * qp1q + i;
            if (apply_transform) {
                torqueControlBalancing_xaxpy(
                    12 - i,
                    -(torqueControlBalancing_xdotc(12 - i, b_A, qq + 1, b_A, qjj + 1)
                      / b_A[i + 12 * i]),
                    qq + 1,
                    b_A,
                    qjj + 1);
            }

            e[qp1q] = b_A[qjj];
        }

        for (qq = i; qq + 1 < 13; qq++) {
            U[qq + 12 * i] = b_A[12 * i + qq];
        }

        if (i + 1 <= 4) {
            nrm = torqueControlBalancing_xnrm2_h(5 - i, e, i + 2);
            if (nrm == 0.0) {
                e[i] = 0.0;
            }
            else {
                if (e[i + 1] < 0.0) {
                    e[i] = -nrm;
                }
                else {
                    e[i] = nrm;
                }

                nrm = e[i];
                if (std::abs(e[i]) >= 1.0020841800044864E-292) {
                    nrm = 1.0 / e[i];
                    for (qq = i + 1; qq < 6; qq++) {
                        e[qq] *= nrm;
                    }
                }
                else {
                    for (qq = i + 1; qq < 6; qq++) {
                        e[qq] /= nrm;
                    }
                }

                e[i + 1]++;
                e[i] = -e[i];
                for (qq = i + 1; qq + 1 < 13; qq++) {
                    work[qq] = 0.0;
                }

                for (qq = i + 1; qq + 1 < 7; qq++) {
                    torqueControlBalancing_xaxpy_c(
                        11 - i, e[qq], b_A, (i + 12 * qq) + 2, work, i + 2);
                }

                for (qq = i + 1; qq + 1 < 7; qq++) {
                    torqueControlBalancing_xaxpy_cf(
                        11 - i, -e[qq] / e[i + 1], work, i + 2, b_A, (i + 12 * qq) + 2);
                }
            }

            for (qq = i + 1; qq + 1 < 7; qq++) {
                Vf[qq + 6 * i] = e[qq];
            }
        }
    }

    i = 4;
    e[4] = b_A[64];
    e[5] = 0.0;
    for (qp1q = 5; qp1q >= 0; qp1q--) {
        qq = 12 * qp1q + qp1q;
        if (b_s[qp1q] != 0.0) {
            for (qp1jj = qp1q + 1; qp1jj + 1 < 7; qp1jj++) {
                qjj = (12 * qp1jj + qp1q) + 1;
                torqueControlBalancing_xaxpy(
                    12 - qp1q,
                    -(torqueControlBalancing_xdotc(12 - qp1q, U, qq + 1, U, qjj) / U[qq]),
                    qq + 1,
                    U,
                    qjj);
            }

            for (qjj = qp1q; qjj + 1 < 13; qjj++) {
                U[qjj + 12 * qp1q] = -U[12 * qp1q + qjj];
            }

            U[qq]++;
            for (qq = 1; qq <= qp1q; qq++) {
                U[(qq + 12 * qp1q) - 1] = 0.0;
            }
        }
        else {
            memset(&U[qp1q * 12], 0, 12U * sizeof(real_T));
            U[qq] = 1.0;
        }
    }

    for (qq = 5; qq >= 0; qq--) {
        if ((qq + 1 <= 4) && (e[qq] != 0.0)) {
            qp1q = (6 * qq + qq) + 2;
            for (qjj = qq + 1; qjj + 1 < 7; qjj++) {
                qp1jj = (6 * qjj + qq) + 2;
                torqueControlBalancin_xaxpy_cfu(
                    5 - qq,
                    -(torqueControlBalancing_xdotc_i(5 - qq, Vf, qp1q, Vf, qp1jj) / Vf[qp1q - 1]),
                    qp1q,
                    Vf,
                    qp1jj);
            }
        }

        for (qp1q = 0; qp1q < 6; qp1q++) {
            Vf[qp1q + 6 * qq] = 0.0;
        }

        Vf[qq + 6 * qq] = 1.0;
    }

    for (qq = 0; qq < 6; qq++) {
        ztest = e[qq];
        if (b_s[qq] != 0.0) {
            rt = std::abs(b_s[qq]);
            nrm = b_s[qq] / rt;
            b_s[qq] = rt;
            if (qq + 1 < 6) {
                ztest = e[qq] / nrm;
            }

            torqueControlBalancing_xscal(nrm, U, 1 + 12 * qq);
        }

        if ((qq + 1 < 6) && (ztest != 0.0)) {
            rt = std::abs(ztest);
            nrm = rt / ztest;
            ztest = rt;
            b_s[qq + 1] *= nrm;
            torqueControlBalancing_xscal_m(nrm, Vf, 1 + 6 * (qq + 1));
        }

        e[qq] = ztest;
    }

    qq = 0;
    nrm = 0.0;
    for (qp1q = 0; qp1q < 6; qp1q++) {
        ztest = std::abs(b_s[qp1q]);
        rt = std::abs(e[qp1q]);
        if (ztest > rt) {
            rt = ztest;
        }

        if (!(nrm > rt)) {
            nrm = rt;
        }
    }

    while ((i + 2 > 0) && (!(qq >= 75))) {
        qp1jj = i + 1;
        do {
            exitg1 = 0;
            qp1q = qp1jj;
            if (qp1jj == 0) {
                exitg1 = 1;
            }
            else {
                rt = std::abs(e[qp1jj - 1]);
                if ((rt
                     <= (std::abs(b_s[qp1jj - 1]) + std::abs(b_s[qp1jj])) * 2.2204460492503131E-16)
                    || ((rt <= 1.0020841800044864E-292)
                        || ((qq > 20) && (rt <= 2.2204460492503131E-16 * nrm)))) {
                    e[qp1jj - 1] = 0.0;
                    exitg1 = 1;
                }
                else {
                    qp1jj--;
                }
            }
        } while (exitg1 == 0);

        if (i + 1 == qp1jj) {
            qp1jj = 4;
        }
        else {
            qjj = i + 2;
            j_ii = i + 2;
            exitg2 = false;
            while ((!exitg2) && (j_ii >= qp1jj)) {
                qjj = j_ii;
                if (j_ii == qp1jj) {
                    exitg2 = true;
                }
                else {
                    rt = 0.0;
                    if (j_ii < i + 2) {
                        rt = std::abs(e[j_ii - 1]);
                    }

                    if (j_ii > qp1jj + 1) {
                        rt += std::abs(e[j_ii - 2]);
                    }

                    ztest = std::abs(b_s[j_ii - 1]);
                    if ((ztest <= 2.2204460492503131E-16 * rt)
                        || (ztest <= 1.0020841800044864E-292)) {
                        b_s[j_ii - 1] = 0.0;
                        exitg2 = true;
                    }
                    else {
                        j_ii--;
                    }
                }
            }

            if (qjj == qp1jj) {
                qp1jj = 3;
            }
            else if (i + 2 == qjj) {
                qp1jj = 1;
            }
            else {
                qp1jj = 2;
                qp1q = qjj;
            }
        }

        switch (qp1jj) {
            case 1:
                rt = e[i];
                e[i] = 0.0;
                for (qjj = i; qjj + 1 >= qp1q + 1; qjj--) {
                    ztest = b_s[qjj];
                    torqueControlBalancing_xrotg(&ztest, &rt, &sqds, &smm1);
                    b_s[qjj] = ztest;
                    if (qjj + 1 > qp1q + 1) {
                        rt = e[qjj - 1] * -smm1;
                        e[qjj - 1] *= sqds;
                    }

                    torqueControlBalancing_xrot(Vf, 1 + 6 * qjj, 1 + 6 * (i + 1), sqds, smm1);
                }
                break;

            case 2:
                rt = e[qp1q - 1];
                e[qp1q - 1] = 0.0;
                for (qjj = qp1q; qjj < i + 2; qjj++) {
                    ztest = b_s[qjj];
                    torqueControlBalancing_xrotg(&ztest, &rt, &sqds, &smm1);
                    b_s[qjj] = ztest;
                    rt = -smm1 * e[qjj];
                    e[qjj] *= sqds;
                    torqueControlBalancing_xrot_f(U, 1 + 12 * qjj, 1 + 12 * (qp1q - 1), sqds, smm1);
                }
                break;

            case 3:
                ztest = std::abs(b_s[i + 1]);
                rt = std::abs(b_s[i]);
                if (ztest > rt) {
                    rt = ztest;
                }

                ztest = std::abs(e[i]);
                if (rt > ztest) {
                    ztest = rt;
                }

                rt = std::abs(b_s[qp1q]);
                if (ztest > rt) {
                    rt = ztest;
                }

                ztest = std::abs(e[qp1q]);
                if (rt > ztest) {
                    ztest = rt;
                }

                rt = b_s[i + 1] / ztest;
                smm1 = b_s[i] / ztest;
                emm1 = e[i] / ztest;
                sqds = b_s[qp1q] / ztest;
                smm1 = ((smm1 + rt) * (smm1 - rt) + emm1 * emm1) / 2.0;
                emm1 *= rt;
                emm1 *= emm1;
                if ((smm1 != 0.0) || (emm1 != 0.0)) {
                    shift = std::sqrt(smm1 * smm1 + emm1);
                    if (smm1 < 0.0) {
                        shift = -shift;
                    }

                    shift = emm1 / (smm1 + shift);
                }
                else {
                    shift = 0.0;
                }

                rt = (sqds + rt) * (sqds - rt) + shift;
                ztest = e[qp1q] / ztest * sqds;
                for (qjj = qp1q + 1; qjj <= i + 1; qjj++) {
                    torqueControlBalancing_xrotg(&rt, &ztest, &sqds, &smm1);
                    if (qjj > qp1q + 1) {
                        e[qjj - 2] = rt;
                    }

                    rt = b_s[qjj - 1] * sqds + e[qjj - 1] * smm1;
                    e[qjj - 1] = e[qjj - 1] * sqds - b_s[qjj - 1] * smm1;
                    ztest = smm1 * b_s[qjj];
                    b_s[qjj] *= sqds;
                    torqueControlBalancing_xrot(Vf, 1 + 6 * (qjj - 1), 1 + 6 * qjj, sqds, smm1);
                    torqueControlBalancing_xrotg(&rt, &ztest, &sqds, &smm1);
                    b_s[qjj - 1] = rt;
                    rt = e[qjj - 1] * sqds + smm1 * b_s[qjj];
                    b_s[qjj] = e[qjj - 1] * -smm1 + sqds * b_s[qjj];
                    ztest = smm1 * e[qjj];
                    e[qjj] *= sqds;
                    torqueControlBalancing_xrot_f(U, 1 + 12 * (qjj - 1), 1 + 12 * qjj, sqds, smm1);
                }

                e[i] = rt;
                qq++;
                break;

            default:
                if (b_s[qp1q] < 0.0) {
                    b_s[qp1q] = -b_s[qp1q];
                    torqueControlBalancing_xscal_m(-1.0, Vf, 1 + 6 * qp1q);
                }

                qq = qp1q + 1;
                while ((qp1q + 1 < 6) && (b_s[qp1q] < b_s[qq])) {
                    rt = b_s[qp1q];
                    b_s[qp1q] = b_s[qq];
                    b_s[qq] = rt;
                    torqueControlBalancing_xswap_h(Vf, 1 + 6 * qp1q, 1 + 6 * (qp1q + 1));
                    torqueControlBalancing_xswap_hc(U, 1 + 12 * qp1q, 1 + 12 * (qp1q + 1));
                    qp1q = qq;
                    qq++;
                }

                qq = 0;
                i--;
                break;
        }
    }

    for (i = 0; i < 6; i++) {
        s[i] = b_s[i];
        for (qq = 0; qq < 6; qq++) {
            V[qq + 6 * i] = Vf[6 * i + qq];
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_pinv(const real_T A[72],
                                                                   real_T tol,
                                                                   real_T X[72])
{
    real_T b_X[72];
    real_T V[36];
    int32_T r;
    int32_T vcol;
    real_T U[72];
    real_T s[6];
    int32_T j;
    int32_T ar;
    int32_T ia;
    int32_T b;
    int32_T ib;
    int32_T b_ic;
    real_T z;
    real_T A_0[72];
    memset(&b_X[0], 0, 72U * sizeof(real_T));
    for (r = 0; r < 6; r++) {
        for (vcol = 0; vcol < 12; vcol++) {
            A_0[vcol + 12 * r] = A[6 * vcol + r];
        }
    }

    torqueControlBalancing_svd(A_0, U, s, V);
    r = 0;
    vcol = 1;
    while ((vcol < 7) && (s[vcol - 1] > tol)) {
        r++;
        vcol++;
    }

    if (r > 0) {
        vcol = 0;
        for (j = 1; j <= r; j++) {
            z = 1.0 / s[j - 1];
            for (ar = vcol; ar < vcol + 6; ar++) {
                V[ar] *= z;
            }

            vcol += 6;
        }

        for (vcol = 0; vcol <= 67; vcol += 6) {
            for (j = vcol; j < vcol + 6; j++) {
                b_X[j] = 0.0;
            }
        }

        vcol = -1;
        for (j = 0; j <= 67; j += 6) {
            ar = -1;
            vcol++;
            b = ((r - 1) * 12 + vcol) + 1;
            for (ib = vcol; ib + 1 <= b; ib += 12) {
                if (U[ib] != 0.0) {
                    ia = ar;
                    for (b_ic = j; b_ic < j + 6; b_ic++) {
                        ia++;
                        b_X[b_ic] += U[ib] * V[ia];
                    }
                }

                ar += 6;
            }
        }
    }

    for (r = 0; r < 6; r++) {
        for (vcol = 0; vcol < 12; vcol++) {
            X[vcol + 12 * r] = b_X[6 * vcol + r];
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_eye(real_T I[144])
{
    int32_T k;
    memset(&I[0], 0, 144U * sizeof(real_T));
    for (k = 0; k < 12; k++) {
        I[k + 12 * k] = 1.0;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancin_xswap_hco(real_T x[841],
                                                                       int32_T ix0,
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 29; k++) {
        temp = x[ix];
        x[ix] = x[iy];
        x[iy] = temp;
        ix += 29;
        iy += 29;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xgetrf_g(real_T A[841],
                                                                       int32_T ipiv[29],
                                                                       int32_T* info)
{
    int32_T j;
    int32_T c;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T k;
    int32_T jA;
    int32_T b_ix;
    int32_T d;
    int32_T ijA;
    for (j = 0; j < 29; j++) {
        ipiv[j] = 1 + j;
    }

    *info = 0;
    for (j = 0; j < 28; j++) {
        c = j * 30;
        jA = 1;
        ix = c;
        smax = std::abs(A[c]);
        for (k = 2; k <= 29 - j; k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                jA = k;
                smax = s;
            }
        }

        if (A[(c + jA) - 1] != 0.0) {
            if (jA - 1 != 0) {
                ipiv[j] = j + jA;
                torqueControlBalancin_xswap_hco(A, j + 1, j + jA);
            }

            jA = (c - j) + 29;
            for (ix = c + 1; ix < jA; ix++) {
                A[ix] /= A[c];
            }
        }
        else {
            *info = j + 1;
        }

        jA = c;
        ix = c + 29;
        for (k = 1; k <= 28 - j; k++) {
            smax = A[ix];
            if (A[ix] != 0.0) {
                b_ix = c + 1;
                d = (jA - j) + 58;
                for (ijA = 30 + jA; ijA < d; ijA++) {
                    A[ijA] += A[b_ix] * -smax;
                    b_ix++;
                }
            }

            ix += 29;
            jA += 29;
        }
    }

    if ((*info == 0) && (!(A[840] != 0.0))) {
        *info = 29;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xtrsm_j(const real_T A[841],
                                                                      real_T B[348])
{
    real_T temp;
    int32_T jBcol;
    int32_T jAcol;
    int32_T kBcol;
    int32_T j;
    int32_T k;
    int32_T i;
    int32_T tmp;
    for (j = 0; j < 29; j++) {
        jBcol = 12 * j;
        jAcol = 29 * j;
        for (k = 1; k <= j; k++) {
            kBcol = (k - 1) * 12;
            if (A[(k + jAcol) - 1] != 0.0) {
                for (i = 0; i < 12; i++) {
                    tmp = i + jBcol;
                    B[tmp] -= A[(k + jAcol) - 1] * B[i + kBcol];
                }
            }
        }

        temp = 1.0 / A[j + jAcol];
        for (jAcol = 0; jAcol < 12; jAcol++) {
            tmp = jAcol + jBcol;
            B[tmp] *= temp;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xtrsm_jj(const real_T A[841],
                                                                       real_T B[348])
{
    int32_T jAcol;
    int32_T jBcol;
    int32_T kBcol;
    int32_T j;
    int32_T k;
    int32_T i;
    int32_T tmp;
    for (j = 28; j >= 0; j--) {
        jBcol = 12 * j;
        jAcol = 29 * j - 1;
        for (k = j + 2; k < 30; k++) {
            kBcol = (k - 1) * 12;
            if (A[k + jAcol] != 0.0) {
                for (i = 0; i < 12; i++) {
                    tmp = i + jBcol;
                    B[tmp] -= A[k + jAcol] * B[i + kBcol];
                }
            }
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalanci_mrdivide_b(const real_T A[348],
                                                                       const real_T B[841],
                                                                       real_T y[348])
{
    int32_T jp;
    int32_T ipiv[29];
    int32_T info;
    real_T temp;
    int32_T xi;
    memcpy(&torqueControlBalancing_B.b_A[0], &B[0], 841U * sizeof(real_T));
    torqueControlBalancing_xgetrf_g(torqueControlBalancing_B.b_A, ipiv, &info);
    memcpy(&y[0], &A[0], 348U * sizeof(real_T));
    torqueControlBalancing_xtrsm_j(torqueControlBalancing_B.b_A, y);
    torqueControlBalancing_xtrsm_jj(torqueControlBalancing_B.b_A, y);
    for (info = 27; info >= 0; info--) {
        if (info + 1 != ipiv[info]) {
            jp = ipiv[info] - 1;
            for (xi = 0; xi < 12; xi++) {
                temp = y[12 * info + xi];
                y[xi + 12 * info] = y[12 * jp + xi];
                y[xi + 12 * jp] = temp;
            }
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalanci_pinvDamped(const real_T A[276],
                                                                       real_T regDamp,
                                                                       real_T pinvDampA[276])
{
    real_T b_A[144];
    int8_T ipiv[12];
    int32_T j;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    int32_T jBcol;
    int32_T kBcol;
    static const int8_T b_b[144] = {
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};

    for (j = 0; j < 12; j++) {
        for (jBcol = 0; jBcol < 12; jBcol++) {
            smax = 0.0;
            for (iy = 0; iy < 23; iy++) {
                smax += A[12 * iy + j] * A[12 * iy + jBcol];
            }

            b_A[j + 12 * jBcol] = (real_T) b_b[12 * jBcol + j] * regDamp + smax;
        }

        ipiv[j] = (int8_T)(1 + j);
    }

    for (j = 0; j < 11; j++) {
        jBcol = j * 13;
        iy = 0;
        ix = jBcol;
        smax = std::abs(b_A[jBcol]);
        for (kBcol = 2; kBcol <= 12 - j; kBcol++) {
            ix++;
            s = std::abs(b_A[ix]);
            if (s > smax) {
                iy = kBcol - 1;
                smax = s;
            }
        }

        if (b_A[jBcol + iy] != 0.0) {
            if (iy != 0) {
                iy += j;
                ipiv[j] = (int8_T)(iy + 1);
                ix = j;
                for (kBcol = 0; kBcol < 12; kBcol++) {
                    smax = b_A[ix];
                    b_A[ix] = b_A[iy];
                    b_A[iy] = smax;
                    ix += 12;
                    iy += 12;
                }
            }

            iy = (jBcol - j) + 12;
            for (ix = jBcol + 1; ix < iy; ix++) {
                b_A[ix] /= b_A[jBcol];
            }
        }

        iy = jBcol;
        ix = jBcol + 12;
        for (kBcol = 1; kBcol <= 11 - j; kBcol++) {
            smax = b_A[ix];
            if (b_A[ix] != 0.0) {
                c_ix = jBcol + 1;
                d = (iy - j) + 24;
                for (ijA = 13 + iy; ijA < d; ijA++) {
                    b_A[ijA] += b_A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 12;
            iy += 12;
        }
    }

    for (j = 0; j < 12; j++) {
        for (jBcol = 0; jBcol < 23; jBcol++) {
            pinvDampA[jBcol + 23 * j] = A[12 * jBcol + j];
        }
    }

    for (j = 0; j < 12; j++) {
        jBcol = 23 * j;
        iy = 12 * j;
        for (ix = 1; ix <= j; ix++) {
            kBcol = (ix - 1) * 23;
            if (b_A[(ix + iy) - 1] != 0.0) {
                for (c_ix = 0; c_ix < 23; c_ix++) {
                    d = c_ix + jBcol;
                    pinvDampA[d] -= b_A[(ix + iy) - 1] * pinvDampA[c_ix + kBcol];
                }
            }
        }

        smax = 1.0 / b_A[j + iy];
        for (iy = 0; iy < 23; iy++) {
            d = iy + jBcol;
            pinvDampA[d] *= smax;
        }
    }

    for (j = 11; j >= 0; j--) {
        jBcol = 23 * j;
        iy = 12 * j - 1;
        for (ix = j + 2; ix < 13; ix++) {
            kBcol = (ix - 1) * 23;
            if (b_A[ix + iy] != 0.0) {
                for (c_ix = 0; c_ix < 23; c_ix++) {
                    pinvDampA[c_ix + jBcol] -= b_A[ix + iy] * pinvDampA[c_ix + kBcol];
                }
            }
        }
    }

    for (j = 10; j >= 0; j--) {
        if (j + 1 != ipiv[j]) {
            jBcol = ipiv[j] - 1;
            for (iy = 0; iy < 23; iy++) {
                smax = pinvDampA[23 * j + iy];
                pinvDampA[iy + 23 * j] = pinvDampA[23 * jBcol + iy];
                pinvDampA[iy + 23 * jBcol] = smax;
            }
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_eye_j(real_T I[529])
{
    int32_T k;
    memset(&I[0], 0, 529U * sizeof(real_T));
    for (k = 0; k < 23; k++) {
        I[k + 23 * k] = 1.0;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalanc_mrdivide_bo(real_T A[138],
                                                                       const real_T B[36])
{
    real_T b_A[36];
    int8_T ipiv[6];
    int32_T j;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    int32_T jBcol;
    int32_T kBcol;
    memcpy(&b_A[0], &B[0], 36U * sizeof(real_T));
    for (d = 0; d < 6; d++) {
        ipiv[d] = (int8_T)(1 + d);
    }

    for (j = 0; j < 5; j++) {
        jBcol = j * 7;
        iy = 0;
        ix = jBcol;
        smax = std::abs(b_A[jBcol]);
        for (kBcol = 2; kBcol <= 6 - j; kBcol++) {
            ix++;
            s = std::abs(b_A[ix]);
            if (s > smax) {
                iy = kBcol - 1;
                smax = s;
            }
        }

        if (b_A[jBcol + iy] != 0.0) {
            if (iy != 0) {
                iy += j;
                ipiv[j] = (int8_T)(iy + 1);
                ix = j;
                for (kBcol = 0; kBcol < 6; kBcol++) {
                    smax = b_A[ix];
                    b_A[ix] = b_A[iy];
                    b_A[iy] = smax;
                    ix += 6;
                    iy += 6;
                }
            }

            iy = (jBcol - j) + 6;
            for (ix = jBcol + 1; ix < iy; ix++) {
                b_A[ix] /= b_A[jBcol];
            }
        }

        iy = jBcol;
        ix = jBcol + 6;
        for (kBcol = 1; kBcol <= 5 - j; kBcol++) {
            smax = b_A[ix];
            if (b_A[ix] != 0.0) {
                c_ix = jBcol + 1;
                d = (iy - j) + 12;
                for (ijA = 7 + iy; ijA < d; ijA++) {
                    b_A[ijA] += b_A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 6;
            iy += 6;
        }
    }

    for (j = 0; j < 6; j++) {
        jBcol = 23 * j;
        iy = 6 * j;
        for (ix = 1; ix <= j; ix++) {
            kBcol = (ix - 1) * 23;
            if (b_A[(ix + iy) - 1] != 0.0) {
                for (c_ix = 0; c_ix < 23; c_ix++) {
                    d = c_ix + jBcol;
                    A[d] -= b_A[(ix + iy) - 1] * A[c_ix + kBcol];
                }
            }
        }

        smax = 1.0 / b_A[j + iy];
        for (iy = 0; iy < 23; iy++) {
            d = iy + jBcol;
            A[d] *= smax;
        }
    }

    for (j = 5; j >= 0; j--) {
        jBcol = 23 * j;
        iy = 6 * j - 1;
        for (ix = j + 2; ix < 7; ix++) {
            kBcol = (ix - 1) * 23;
            if (b_A[ix + iy] != 0.0) {
                for (c_ix = 0; c_ix < 23; c_ix++) {
                    A[c_ix + jBcol] -= b_A[ix + iy] * A[c_ix + kBcol];
                }
            }
        }
    }

    for (j = 4; j >= 0; j--) {
        if (j + 1 != ipiv[j]) {
            jBcol = ipiv[j] - 1;
            for (iy = 0; iy < 23; iy++) {
                smax = A[23 * j + iy];
                A[iy + 23 * j] = A[23 * jBcol + iy];
                A[iy + 23 * jBcol] = smax;
            }
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_xnrm2_ht(int32_T n,
                                                                         const real_T x[529],
                                                                         int32_T ix0)
{
    real_T y;
    real_T scale;
    int32_T kend;
    real_T absxk;
    real_T t;
    int32_T k;
    y = 0.0;
    if (!(n < 1)) {
        if (n == 1) {
            y = std::abs(x[ix0 - 1]);
        }
        else {
            scale = 3.3121686421112381E-170;
            kend = (ix0 + n) - 1;
            for (k = ix0; k <= kend; k++) {
                absxk = std::abs(x[k - 1]);
                if (absxk > scale) {
                    t = scale / absxk;
                    y = y * t * t + 1.0;
                    scale = absxk;
                }
                else {
                    t = absxk / scale;
                    y += t * t;
                }
            }

            y = scale * std::sqrt(y);
        }
    }

    return y;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancin_xnrm2_ht1(int32_T n,
                                                                         const real_T x[23],
                                                                         int32_T ix0)
{
    real_T y;
    real_T scale;
    int32_T kend;
    real_T absxk;
    real_T t;
    int32_T k;
    y = 0.0;
    if (!(n < 1)) {
        if (n == 1) {
            y = std::abs(x[ix0 - 1]);
        }
        else {
            scale = 3.3121686421112381E-170;
            kend = (ix0 + n) - 1;
            for (k = ix0; k <= kend; k++) {
                absxk = std::abs(x[k - 1]);
                if (absxk > scale) {
                    t = scale / absxk;
                    y = y * t * t + 1.0;
                    scale = absxk;
                }
                else {
                    t = absxk / scale;
                    y += t * t;
                }
            }

            y = scale * std::sqrt(y);
        }
    }

    return y;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalan_xaxpy_cfudir(int32_T n,
                                                                       real_T a,
                                                                       const real_T x[23],
                                                                       int32_T ix0,
                                                                       real_T y[529],
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * x[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalanc_xaxpy_cfudi(int32_T n,
                                                                       real_T a,
                                                                       const real_T x[529],
                                                                       int32_T ix0,
                                                                       real_T y[23],
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * x[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
real_T torqueControlBalancingModelClass::torqueControlBalancing_xdotc_i5(int32_T n,
                                                                         const real_T x[529],
                                                                         int32_T ix0,
                                                                         const real_T y[529],
                                                                         int32_T iy0)
{
    real_T d;
    int32_T ix;
    int32_T iy;
    int32_T k;
    d = 0.0;
    if (!(n < 1)) {
        ix = ix0;
        iy = iy0;
        for (k = 1; k <= n; k++) {
            d += x[ix - 1] * y[iy - 1];
            ix++;
            iy++;
        }
    }

    return d;
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalanci_xaxpy_cfud(int32_T n,
                                                                       real_T a,
                                                                       int32_T ix0,
                                                                       real_T y[529],
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    int32_T k;
    if (!((n < 1) || (a == 0.0))) {
        ix = ix0 - 1;
        iy = iy0 - 1;
        for (k = 0; k < n; k++) {
            y[iy] += a * y[ix];
            ix++;
            iy++;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xscal_ms(real_T a,
                                                                       real_T x[529],
                                                                       int32_T ix0)
{
    int32_T k;
    for (k = ix0; k <= ix0 + 22; k++) {
        x[k - 1] *= a;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalanci_xswap_hcop(real_T x[529],
                                                                       int32_T ix0,
                                                                       int32_T iy0)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 23; k++) {
        temp = x[ix];
        x[ix] = x[iy];
        x[iy] = temp;
        ix++;
        iy++;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xrot_fl(real_T x[529],
                                                                      int32_T ix0,
                                                                      int32_T iy0,
                                                                      real_T c,
                                                                      real_T s)
{
    int32_T ix;
    int32_T iy;
    real_T temp;
    int32_T k;
    ix = ix0 - 1;
    iy = iy0 - 1;
    for (k = 0; k < 23; k++) {
        temp = c * x[ix] + s * x[iy];
        x[iy] = c * x[iy] - s * x[ix];
        x[ix] = temp;
        iy++;
        ix++;
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_svd_g(const real_T A[529],
                                                                    real_T U[529],
                                                                    real_T s[23],
                                                                    real_T V[529])
{
    real_T b_s[23];
    real_T e[23];
    real_T work[23];
    int32_T qq;
    boolean_T apply_transform;
    real_T nrm;
    int32_T qjj;
    int32_T qp1jj;
    int32_T m;
    int32_T qp1q;
    real_T rt;
    real_T ztest;
    real_T smm1;
    real_T emm1;
    real_T sqds;
    real_T shift;
    int32_T k_ii;
    int32_T exitg1;
    boolean_T exitg2;
    memcpy(&torqueControlBalancing_B.b_A_b[0], &A[0], 529U * sizeof(real_T));
    memset(&b_s[0], 0, 23U * sizeof(real_T));
    memset(&e[0], 0, 23U * sizeof(real_T));
    memset(&work[0], 0, 23U * sizeof(real_T));
    memset(&U[0], 0, 529U * sizeof(real_T));
    memset(&torqueControlBalancing_B.Vf[0], 0, 529U * sizeof(real_T));
    for (m = 0; m < 22; m++) {
        qq = 23 * m + m;
        apply_transform = false;
        nrm = torqueControlBalancing_xnrm2_ht(23 - m, torqueControlBalancing_B.b_A_b, qq + 1);
        if (nrm > 0.0) {
            apply_transform = true;
            if (torqueControlBalancing_B.b_A_b[qq] < 0.0) {
                b_s[m] = -nrm;
            }
            else {
                b_s[m] = nrm;
            }

            if (std::abs(b_s[m]) >= 1.0020841800044864E-292) {
                nrm = 1.0 / b_s[m];
                qp1q = (qq - m) + 23;
                for (qjj = qq; qjj < qp1q; qjj++) {
                    torqueControlBalancing_B.b_A_b[qjj] *= nrm;
                }
            }
            else {
                qp1q = (qq - m) + 23;
                for (qjj = qq; qjj < qp1q; qjj++) {
                    torqueControlBalancing_B.b_A_b[qjj] /= b_s[m];
                }
            }

            torqueControlBalancing_B.b_A_b[qq]++;
            b_s[m] = -b_s[m];
        }
        else {
            b_s[m] = 0.0;
        }

        for (qp1q = m + 1; qp1q + 1 < 24; qp1q++) {
            qjj = 23 * qp1q + m;
            if (apply_transform) {
                torqueControlBalanci_xaxpy_cfud(
                    23 - m,
                    -(torqueControlBalancing_xdotc_i5(23 - m,
                                                      torqueControlBalancing_B.b_A_b,
                                                      qq + 1,
                                                      torqueControlBalancing_B.b_A_b,
                                                      qjj + 1)
                      / torqueControlBalancing_B.b_A_b[m + 23 * m]),
                    qq + 1,
                    torqueControlBalancing_B.b_A_b,
                    qjj + 1);
            }

            e[qp1q] = torqueControlBalancing_B.b_A_b[qjj];
        }

        for (qq = m; qq + 1 < 24; qq++) {
            U[qq + 23 * m] = torqueControlBalancing_B.b_A_b[23 * m + qq];
        }

        if (m + 1 <= 21) {
            nrm = torqueControlBalancin_xnrm2_ht1(22 - m, e, m + 2);
            if (nrm == 0.0) {
                e[m] = 0.0;
            }
            else {
                if (e[m + 1] < 0.0) {
                    e[m] = -nrm;
                }
                else {
                    e[m] = nrm;
                }

                nrm = e[m];
                if (std::abs(e[m]) >= 1.0020841800044864E-292) {
                    nrm = 1.0 / e[m];
                    for (qq = m + 1; qq < 23; qq++) {
                        e[qq] *= nrm;
                    }
                }
                else {
                    for (qq = m + 1; qq < 23; qq++) {
                        e[qq] /= nrm;
                    }
                }

                e[m + 1]++;
                e[m] = -e[m];
                for (qq = m + 1; qq + 1 < 24; qq++) {
                    work[qq] = 0.0;
                }

                for (qq = m + 1; qq + 1 < 24; qq++) {
                    torqueControlBalanc_xaxpy_cfudi(22 - m,
                                                    e[qq],
                                                    torqueControlBalancing_B.b_A_b,
                                                    (m + 23 * qq) + 2,
                                                    work,
                                                    m + 2);
                }

                for (qq = m + 1; qq + 1 < 24; qq++) {
                    torqueControlBalan_xaxpy_cfudir(22 - m,
                                                    -e[qq] / e[m + 1],
                                                    work,
                                                    m + 2,
                                                    torqueControlBalancing_B.b_A_b,
                                                    (m + 23 * qq) + 2);
                }
            }

            for (qq = m + 1; qq + 1 < 24; qq++) {
                torqueControlBalancing_B.Vf[qq + 23 * m] = e[qq];
            }
        }
    }

    m = 21;
    b_s[22] = torqueControlBalancing_B.b_A_b[528];
    e[21] = torqueControlBalancing_B.b_A_b[527];
    e[22] = 0.0;
    memset(&U[506], 0, 23U * sizeof(real_T));
    U[528] = 1.0;
    for (qp1q = 21; qp1q >= 0; qp1q--) {
        qq = 23 * qp1q + qp1q;
        if (b_s[qp1q] != 0.0) {
            for (qp1jj = qp1q + 1; qp1jj + 1 < 24; qp1jj++) {
                qjj = (23 * qp1jj + qp1q) + 1;
                torqueControlBalanci_xaxpy_cfud(
                    23 - qp1q,
                    -(torqueControlBalancing_xdotc_i5(23 - qp1q, U, qq + 1, U, qjj) / U[qq]),
                    qq + 1,
                    U,
                    qjj);
            }

            for (qjj = qp1q; qjj + 1 < 24; qjj++) {
                U[qjj + 23 * qp1q] = -U[23 * qp1q + qjj];
            }

            U[qq]++;
            for (qq = 1; qq <= qp1q; qq++) {
                U[(qq + 23 * qp1q) - 1] = 0.0;
            }
        }
        else {
            memset(&U[qp1q * 23], 0, 23U * sizeof(real_T));
            U[qq] = 1.0;
        }
    }

    for (qq = 22; qq >= 0; qq--) {
        if ((qq + 1 <= 21) && (e[qq] != 0.0)) {
            qp1q = (23 * qq + qq) + 2;
            for (qjj = qq + 1; qjj + 1 < 24; qjj++) {
                qp1jj = (23 * qjj + qq) + 2;
                torqueControlBalanci_xaxpy_cfud(
                    22 - qq,
                    -(torqueControlBalancing_xdotc_i5(22 - qq,
                                                      torqueControlBalancing_B.Vf,
                                                      qp1q,
                                                      torqueControlBalancing_B.Vf,
                                                      qp1jj)
                      / torqueControlBalancing_B.Vf[qp1q - 1]),
                    qp1q,
                    torqueControlBalancing_B.Vf,
                    qp1jj);
            }
        }

        memset(&torqueControlBalancing_B.Vf[qq * 23], 0, 23U * sizeof(real_T));
        torqueControlBalancing_B.Vf[qq + 23 * qq] = 1.0;
    }

    for (qq = 0; qq < 23; qq++) {
        ztest = e[qq];
        if (b_s[qq] != 0.0) {
            rt = std::abs(b_s[qq]);
            nrm = b_s[qq] / rt;
            b_s[qq] = rt;
            if (qq + 1 < 23) {
                ztest = e[qq] / nrm;
            }

            torqueControlBalancing_xscal_ms(nrm, U, 1 + 23 * qq);
        }

        if ((qq + 1 < 23) && (ztest != 0.0)) {
            rt = std::abs(ztest);
            nrm = rt / ztest;
            ztest = rt;
            b_s[qq + 1] *= nrm;
            torqueControlBalancing_xscal_ms(nrm, torqueControlBalancing_B.Vf, 1 + 23 * (qq + 1));
        }

        e[qq] = ztest;
    }

    qq = 0;
    nrm = 0.0;
    for (qp1q = 0; qp1q < 23; qp1q++) {
        ztest = std::abs(b_s[qp1q]);
        rt = std::abs(e[qp1q]);
        if (ztest > rt) {
            rt = ztest;
        }

        if (!(nrm > rt)) {
            nrm = rt;
        }
    }

    while ((m + 2 > 0) && (!(qq >= 75))) {
        qp1jj = m + 1;
        do {
            exitg1 = 0;
            qp1q = qp1jj;
            if (qp1jj == 0) {
                exitg1 = 1;
            }
            else {
                rt = std::abs(e[qp1jj - 1]);
                if ((rt
                     <= (std::abs(b_s[qp1jj - 1]) + std::abs(b_s[qp1jj])) * 2.2204460492503131E-16)
                    || ((rt <= 1.0020841800044864E-292)
                        || ((qq > 20) && (rt <= 2.2204460492503131E-16 * nrm)))) {
                    e[qp1jj - 1] = 0.0;
                    exitg1 = 1;
                }
                else {
                    qp1jj--;
                }
            }
        } while (exitg1 == 0);

        if (m + 1 == qp1jj) {
            qp1jj = 4;
        }
        else {
            qjj = m + 2;
            k_ii = m + 2;
            exitg2 = false;
            while ((!exitg2) && (k_ii >= qp1jj)) {
                qjj = k_ii;
                if (k_ii == qp1jj) {
                    exitg2 = true;
                }
                else {
                    rt = 0.0;
                    if (k_ii < m + 2) {
                        rt = std::abs(e[k_ii - 1]);
                    }

                    if (k_ii > qp1jj + 1) {
                        rt += std::abs(e[k_ii - 2]);
                    }

                    ztest = std::abs(b_s[k_ii - 1]);
                    if ((ztest <= 2.2204460492503131E-16 * rt)
                        || (ztest <= 1.0020841800044864E-292)) {
                        b_s[k_ii - 1] = 0.0;
                        exitg2 = true;
                    }
                    else {
                        k_ii--;
                    }
                }
            }

            if (qjj == qp1jj) {
                qp1jj = 3;
            }
            else if (m + 2 == qjj) {
                qp1jj = 1;
            }
            else {
                qp1jj = 2;
                qp1q = qjj;
            }
        }

        switch (qp1jj) {
            case 1:
                rt = e[m];
                e[m] = 0.0;
                for (qjj = m; qjj + 1 >= qp1q + 1; qjj--) {
                    ztest = b_s[qjj];
                    torqueControlBalancing_xrotg(&ztest, &rt, &sqds, &smm1);
                    b_s[qjj] = ztest;
                    if (qjj + 1 > qp1q + 1) {
                        rt = e[qjj - 1] * -smm1;
                        e[qjj - 1] *= sqds;
                    }

                    torqueControlBalancing_xrot_fl(
                        torqueControlBalancing_B.Vf, 1 + 23 * qjj, 1 + 23 * (m + 1), sqds, smm1);
                }
                break;

            case 2:
                rt = e[qp1q - 1];
                e[qp1q - 1] = 0.0;
                for (qjj = qp1q; qjj < m + 2; qjj++) {
                    ztest = b_s[qjj];
                    torqueControlBalancing_xrotg(&ztest, &rt, &sqds, &smm1);
                    b_s[qjj] = ztest;
                    rt = -smm1 * e[qjj];
                    e[qjj] *= sqds;
                    torqueControlBalancing_xrot_fl(
                        U, 1 + 23 * qjj, 1 + 23 * (qp1q - 1), sqds, smm1);
                }
                break;

            case 3:
                ztest = std::abs(b_s[m + 1]);
                rt = std::abs(b_s[m]);
                if (ztest > rt) {
                    rt = ztest;
                }

                ztest = std::abs(e[m]);
                if (rt > ztest) {
                    ztest = rt;
                }

                rt = std::abs(b_s[qp1q]);
                if (ztest > rt) {
                    rt = ztest;
                }

                ztest = std::abs(e[qp1q]);
                if (rt > ztest) {
                    ztest = rt;
                }

                rt = b_s[m + 1] / ztest;
                smm1 = b_s[m] / ztest;
                emm1 = e[m] / ztest;
                sqds = b_s[qp1q] / ztest;
                smm1 = ((smm1 + rt) * (smm1 - rt) + emm1 * emm1) / 2.0;
                emm1 *= rt;
                emm1 *= emm1;
                if ((smm1 != 0.0) || (emm1 != 0.0)) {
                    shift = std::sqrt(smm1 * smm1 + emm1);
                    if (smm1 < 0.0) {
                        shift = -shift;
                    }

                    shift = emm1 / (smm1 + shift);
                }
                else {
                    shift = 0.0;
                }

                rt = (sqds + rt) * (sqds - rt) + shift;
                ztest = e[qp1q] / ztest * sqds;
                for (qjj = qp1q + 1; qjj <= m + 1; qjj++) {
                    torqueControlBalancing_xrotg(&rt, &ztest, &sqds, &smm1);
                    if (qjj > qp1q + 1) {
                        e[qjj - 2] = rt;
                    }

                    rt = b_s[qjj - 1] * sqds + e[qjj - 1] * smm1;
                    e[qjj - 1] = e[qjj - 1] * sqds - b_s[qjj - 1] * smm1;
                    ztest = smm1 * b_s[qjj];
                    b_s[qjj] *= sqds;
                    torqueControlBalancing_xrot_fl(
                        torqueControlBalancing_B.Vf, 1 + 23 * (qjj - 1), 1 + 23 * qjj, sqds, smm1);
                    torqueControlBalancing_xrotg(&rt, &ztest, &sqds, &smm1);
                    b_s[qjj - 1] = rt;
                    rt = e[qjj - 1] * sqds + smm1 * b_s[qjj];
                    b_s[qjj] = e[qjj - 1] * -smm1 + sqds * b_s[qjj];
                    ztest = smm1 * e[qjj];
                    e[qjj] *= sqds;
                    torqueControlBalancing_xrot_fl(U, 1 + 23 * (qjj - 1), 1 + 23 * qjj, sqds, smm1);
                }

                e[m] = rt;
                qq++;
                break;

            default:
                if (b_s[qp1q] < 0.0) {
                    b_s[qp1q] = -b_s[qp1q];
                    torqueControlBalancing_xscal_ms(
                        -1.0, torqueControlBalancing_B.Vf, 1 + 23 * qp1q);
                }

                qq = qp1q + 1;
                while ((qp1q + 1 < 23) && (b_s[qp1q] < b_s[qq])) {
                    rt = b_s[qp1q];
                    b_s[qp1q] = b_s[qq];
                    b_s[qq] = rt;
                    torqueControlBalanci_xswap_hcop(
                        torqueControlBalancing_B.Vf, 1 + 23 * qp1q, 1 + 23 * (qp1q + 1));
                    torqueControlBalanci_xswap_hcop(U, 1 + 23 * qp1q, 1 + 23 * (qp1q + 1));
                    qp1q = qq;
                    qq++;
                }

                qq = 0;
                m--;
                break;
        }
    }

    for (m = 0; m < 23; m++) {
        s[m] = b_s[m];
        memcpy(&V[m * 23], &torqueControlBalancing_B.Vf[m * 23], 23U * sizeof(real_T));
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_xgemm(int32_T k,
                                                                    const real_T A[529],
                                                                    const real_T B[529],
                                                                    real_T C[529])
{
    int32_T br;
    int32_T ar;
    int32_T ia;
    int32_T ic;
    int32_T b;
    int32_T ib;
    int32_T b_ic;
    for (br = 0; br <= 507; br += 23) {
        for (ic = br; ic < br + 23; ic++) {
            C[ic] = 0.0;
        }
    }

    br = -1;
    for (ic = 0; ic <= 507; ic += 23) {
        ar = -1;
        br++;
        b = ((k - 1) * 23 + br) + 1;
        for (ib = br; ib + 1 <= b; ib += 23) {
            if (B[ib] != 0.0) {
                ia = ar;
                for (b_ic = ic; b_ic < ic + 23; b_ic++) {
                    ia++;
                    C[b_ic] += B[ib] * A[ia];
                }
            }

            ar += 23;
        }
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_pinv_o(const real_T A[529],
                                                                     real_T tol,
                                                                     real_T X[529])
{
    int32_T r;
    int32_T vcol;
    real_T s[23];
    int32_T j;
    memset(&X[0], 0, 529U * sizeof(real_T));
    torqueControlBalancing_svd_g(A, torqueControlBalancing_B.U, s, torqueControlBalancing_B.V);
    r = 0;
    vcol = 1;
    while ((vcol < 24) && (s[vcol - 1] > tol)) {
        r++;
        vcol++;
    }

    if (r > 0) {
        vcol = 1;
        for (j = 1; j <= r; j++) {
            torqueControlBalancing_xscal_ms(1.0 / s[j - 1], torqueControlBalancing_B.V, vcol);
            vcol += 23;
        }

        torqueControlBalancing_xgemm(r, torqueControlBalancing_B.V, torqueControlBalancing_B.U, X);
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancing_diag(const real_T v[23],
                                                                   real_T d[529])
{
    int32_T j;
    memset(&d[0], 0, 529U * sizeof(real_T));
    for (j = 0; j < 23; j++) {
        d[j + 23 * j] = v[j];
    }
}

/* Function for MATLAB Function: '<S15>/Momentum Based Balancing Controller ' */
void torqueControlBalancingModelClass::torqueControlBalancin_blkdiag_h(const real_T varargin_1[114],
                                                                       const real_T varargin_2[114],
                                                                       real_T y[456])
{
    int32_T i;
    int32_T i_0;
    int32_T y_tmp;
    memset(&y[0], 0, 456U * sizeof(real_T));
    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 19; i++) {
            y_tmp = 19 * i_0 + i;
            y[i + 38 * i_0] = varargin_1[y_tmp];
            y[(i + 38 * (6 + i_0)) + 19] = varargin_2[y_tmp];
        }
    }
}

/* Function for MATLAB Function: '<S26>/Analytical Solution QP One Foot (unconstrained)' */
void torqueControlBalancingModelClass::torqueControlBalancing_invNxN(const real_T x[36],
                                                                     real_T y[36])
{
    int8_T p[6];
    real_T A[36];
    int8_T ipiv[6];
    int32_T b_j;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T b_k;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    int32_T pipk;
    for (b_k = 0; b_k < 36; b_k++) {
        y[b_k] = 0.0;
        A[b_k] = x[b_k];
    }

    for (b_k = 0; b_k < 6; b_k++) {
        ipiv[b_k] = (int8_T)(1 + b_k);
    }

    for (b_j = 0; b_j < 5; b_j++) {
        pipk = b_j * 7;
        iy = 0;
        ix = pipk;
        smax = std::abs(A[pipk]);
        for (b_k = 2; b_k <= 6 - b_j; b_k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                iy = b_k - 1;
                smax = s;
            }
        }

        if (A[pipk + iy] != 0.0) {
            if (iy != 0) {
                iy += b_j;
                ipiv[b_j] = (int8_T)(iy + 1);
                ix = b_j;
                for (b_k = 0; b_k < 6; b_k++) {
                    smax = A[ix];
                    A[ix] = A[iy];
                    A[iy] = smax;
                    ix += 6;
                    iy += 6;
                }
            }

            iy = (pipk - b_j) + 6;
            for (ix = pipk + 1; ix < iy; ix++) {
                A[ix] /= A[pipk];
            }
        }

        iy = pipk;
        ix = pipk + 6;
        for (b_k = 1; b_k <= 5 - b_j; b_k++) {
            smax = A[ix];
            if (A[ix] != 0.0) {
                c_ix = pipk + 1;
                d = (iy - b_j) + 12;
                for (ijA = 7 + iy; ijA < d; ijA++) {
                    A[ijA] += A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 6;
            iy += 6;
        }
    }

    for (b_k = 0; b_k < 6; b_k++) {
        p[b_k] = (int8_T)(1 + b_k);
    }

    for (b_j = 0; b_j < 5; b_j++) {
        if (ipiv[b_j] > 1 + b_j) {
            b_k = ipiv[b_j] - 1;
            pipk = p[b_k];
            p[b_k] = p[b_j];
            p[b_j] = (int8_T) pipk;
        }
    }

    for (b_j = 0; b_j < 6; b_j++) {
        b_k = p[b_j] - 1;
        y[b_j + 6 * b_k] = 1.0;
        for (iy = b_j; iy + 1 < 7; iy++) {
            if (y[6 * b_k + iy] != 0.0) {
                for (ix = iy + 1; ix + 1 < 7; ix++) {
                    y[ix + 6 * b_k] -= y[6 * b_k + iy] * A[6 * iy + ix];
                }
            }
        }
    }

    for (b_j = 0; b_j < 6; b_j++) {
        pipk = 6 * b_j;
        for (iy = 5; iy >= 0; iy--) {
            ix = 6 * iy;
            b_k = iy + pipk;
            if (y[b_k] != 0.0) {
                y[b_k] = y[iy + pipk] / A[iy + ix];
                for (b_k = 0; b_k < iy; b_k++) {
                    c_ix = b_k + pipk;
                    y[c_ix] -= y[iy + pipk] * A[b_k + ix];
                }
            }
        }
    }
}

/* Function for MATLAB Function: '<S27>/Analytical Solution Two Feet (unconstrained)' */
void torqueControlBalancingModelClass::torqueControlBalancing_invNxN_b(const real_T x[144],
                                                                       real_T y[144])
{
    int8_T p[12];
    real_T A[144];
    int8_T ipiv[12];
    int32_T b_j;
    int32_T ix;
    real_T smax;
    real_T s;
    int32_T b_k;
    int32_T iy;
    int32_T c_ix;
    int32_T d;
    int32_T ijA;
    int32_T pipk;
    for (b_k = 0; b_k < 144; b_k++) {
        y[b_k] = 0.0;
        A[b_k] = x[b_k];
    }

    for (b_k = 0; b_k < 12; b_k++) {
        ipiv[b_k] = (int8_T)(1 + b_k);
    }

    for (b_j = 0; b_j < 11; b_j++) {
        pipk = b_j * 13;
        iy = 0;
        ix = pipk;
        smax = std::abs(A[pipk]);
        for (b_k = 2; b_k <= 12 - b_j; b_k++) {
            ix++;
            s = std::abs(A[ix]);
            if (s > smax) {
                iy = b_k - 1;
                smax = s;
            }
        }

        if (A[pipk + iy] != 0.0) {
            if (iy != 0) {
                iy += b_j;
                ipiv[b_j] = (int8_T)(iy + 1);
                ix = b_j;
                for (b_k = 0; b_k < 12; b_k++) {
                    smax = A[ix];
                    A[ix] = A[iy];
                    A[iy] = smax;
                    ix += 12;
                    iy += 12;
                }
            }

            iy = (pipk - b_j) + 12;
            for (ix = pipk + 1; ix < iy; ix++) {
                A[ix] /= A[pipk];
            }
        }

        iy = pipk;
        ix = pipk + 12;
        for (b_k = 1; b_k <= 11 - b_j; b_k++) {
            smax = A[ix];
            if (A[ix] != 0.0) {
                c_ix = pipk + 1;
                d = (iy - b_j) + 24;
                for (ijA = 13 + iy; ijA < d; ijA++) {
                    A[ijA] += A[c_ix] * -smax;
                    c_ix++;
                }
            }

            ix += 12;
            iy += 12;
        }
    }

    for (b_k = 0; b_k < 12; b_k++) {
        p[b_k] = (int8_T)(1 + b_k);
    }

    for (b_j = 0; b_j < 11; b_j++) {
        if (ipiv[b_j] > 1 + b_j) {
            b_k = ipiv[b_j] - 1;
            pipk = p[b_k];
            p[b_k] = p[b_j];
            p[b_j] = (int8_T) pipk;
        }
    }

    for (b_j = 0; b_j < 12; b_j++) {
        b_k = p[b_j] - 1;
        y[b_j + 12 * b_k] = 1.0;
        for (iy = b_j; iy + 1 < 13; iy++) {
            if (y[12 * b_k + iy] != 0.0) {
                for (ix = iy + 1; ix + 1 < 13; ix++) {
                    y[ix + 12 * b_k] -= y[12 * b_k + iy] * A[12 * iy + ix];
                }
            }
        }
    }

    for (b_j = 0; b_j < 12; b_j++) {
        pipk = 12 * b_j;
        for (iy = 11; iy >= 0; iy--) {
            ix = 12 * iy;
            b_k = iy + pipk;
            if (y[b_k] != 0.0) {
                y[b_k] = y[iy + pipk] / A[iy + ix];
                for (b_k = 0; b_k < iy; b_k++) {
                    c_ix = b_k + pipk;
                    y[c_ix] -= y[iy + pipk] * A[b_k + ix];
                }
            }
        }
    }
}

/* Model step function */
void torqueControlBalancingModelClass::step()
{
    /* local block i/o variables */
    real_T rtb_imu_H_link[16];
    real_T rtb_link_H_root[16];
    real_T rtb_Switch[3];
    real_T rtb_imu_H_link_a[16];
    real_T rtb_link_H_root_l[16];
    real_T rtb_Switch_c[3];
    real_T rtb_Switch_cg[23];
    boolean_T rtb_Compare;
    boolean_T rtb_Compare_b;
    boolean_T rtb_Compare_f;
    boolean_T rtb_Compare_l;
    boolean_T rtb_Compare_lt;
    boolean_T rtb_Compare_a;
    real_T fixed_link_CoMDes[4];
    real_T scale;
    real_T absxk;
    real_T t;
    real_T Jc[348];
    real_T pinvJb[36];
    static const int8_T b[36] = {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                                 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1};

    real_T f_grav[6];
    real_T A_right[36];
    real_T A[72];
    real_T LDot_star[6];
    real_T ConstraintMatrixRightFoot[114];
    real_T pinvA[72];
    real_T Jc_invM[348];
    real_T Lambda[276];
    real_T pinvLambda[276];
    real_T ConstraintsMatrixBothFeet[456];
    static const int8_T b_b[9] = {1, 0, 0, 0, 1, 0, 0, 0, 1};

    static const int8_T c[18] = {1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    static const int8_T d_b[667] = {
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};

    static const int8_T d_a[36] = {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                                   0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1};

    static const int8_T e_a[144] = {
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};

    static const int8_T e_b[529] = {
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};

    real_T delta_u_min;
    real_T updated_primalSolution[12];
    real_T rtb_tauModel[23];
    real_T rtb_Clock1;
    real_T rtb_Switch3[9];
    real_T rtb_TmpSignalConversionAtSFunct[29];
    real_T rtb_f_LDot[12];
    boolean_T rtb_res_check_range[23];
    real_T rtb_Na[144];
    real_T rtb_Sigma[276];
    int32_T i;
    real_T tmp[144];
    int32_T i_0;
    real_T tmp_0[16];
    real_T tmp_1[72];
    real_T pinvJb_0[36];
    real_T pinvJb_1[138];
    real_T tmp_2[3];
    real_T tmp_3[3];
    real_T rtb_Switch3_0[3];
    real_T tmp_4[3];
    real_T tmp_5[9];
    real_T LDot_star_0[6];
    real_T tmp_6[144];
    real_T pinvLambda_0[276];
    real_T NullLambda[276];
    real_T Jc_invM_0[12];
    real_T tmp_7[12];
    real_T Jc_invM_1[12];
    real_T tmp_8[23];
    real_T pinvLambda_1[23];
    real_T NullLambda_0[23];
    real_T rtb_tauModel_0[23];
    real_T tmp_9[38];
    real_T ConstraintsMatrixBothFeet_0[38];
    int32_T rtb_feetContactStatus_idx_0;
    int32_T rtb_feetContactStatus_idx_1;
    real_T r_right_idx_2;
    int32_T Jc_tmp;
    int32_T Jc_tmp_0;
    int32_T tmp_a;
    int32_T rtb_D_tmp;

    /* S-Function (BlockFactory): '<S3>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S3>/S-Function

    /* MATLAB Function: '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}' */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/From tau_QP to Joint
     * Torques (motor reflected inertia)/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}': '<S42>:1' */
    /* '<S42>:1:3' */
    /* '<S42>:1:4' */
    /* '<S42>:1:5' */
    /* '<S42>:1:7' */
    t_computeMotorsReflectedInertia(torqueControlBalancing_P.Config.Gamma,
                                    torqueControlBalancing_P.Config.T,
                                    torqueControlBalancing_P.Config.I_m,
                                    torqueControlBalancing_B.reflectedInertia);

    /* S-Function (BlockFactory): '<S4>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_c.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_c.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S4>/S-Function

    /* S-Function (BlockFactory): '<S74>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_p.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_p.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S74>/S-Function

    /* S-Function (BlockFactory): '<S72>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_b.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_b.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S72>/S-Function

    /* Product: '<S70>/Inv' */
    rt_mldivided4x4(
        torqueControlBalancing_B.SFunction_k, torqueControlBalancing_B.SFunction_a, rtb_imu_H_link);

    /* RelationalOperator: '<S80>/Compare' incorporates:
     *  Clock: '<S77>/Clock'
     *  Constant: '<S80>/Constant'
     */
    rtb_Compare = ((&torqueControlBalancing_M)->Timing.t[0]
                   == torqueControlBalancing_P.CompareToConstant_const);

    /* MATLAB Function: '<S77>/MATLAB Function' */
    torqueControlB_MATLABFunction_i(rtb_imu_H_link,
                                    &torqueControlBalancing_B.sf_MATLABFunction_i,
                                    &torqueControlBalancing_DW.sf_MATLABFunction_i);

    /* S-Function (BlockFactory): '<S75>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_m.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_m.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S75>/S-Function

    /* Product: '<S70>/Inv_2' */
    rt_mldivided4x4(torqueControlBalancing_B.SFunction_a,
                    torqueControlBalancing_B.SFunction_n,
                    rtb_link_H_root);

    /* S-Function (BlockFactory): '<Root>/IMU_meas' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.IMU_meas_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.IMU_meas_PWORK.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <Root>/IMU_meas

    /* RelationalOperator: '<S82>/Compare' incorporates:
     *  Clock: '<S78>/Clock'
     *  Constant: '<S82>/Constant'
     */
    rtb_Compare_b = ((&torqueControlBalancing_M)->Timing.t[0]
                     == torqueControlBalancing_P.CompareToConstant_const_o);

    /* MATLAB Function: '<S78>/MATLAB Function' */
    torqueControlB_MATLABFunction_o(torqueControlBalancing_B.IMU_meas,
                                    &torqueControlBalancing_B.sf_MATLABFunction_o,
                                    &torqueControlBalancing_DW.sf_MATLABFunction_o);

    /* S-Function (BlockFactory): '<S70>/Neck Position' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.NeckPosition_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.NeckPosition_PWORK.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S70>/Neck Position

    /* Switch: '<S79>/Switch' incorporates:
     *  Constant: '<S79>/Constant'
     *  Constant: '<S79>/USE_IMU4EST_BASE1'
     *  Gain: '<S79>/Gain'
     */
    if (torqueControlBalancing_P.Config.CORRECT_NECK_IMU) {
        rtb_Switch[0] =
            torqueControlBalancing_P.Gain_Gain * torqueControlBalancing_B.NeckPosition[0];
        rtb_Switch[1] =
            torqueControlBalancing_P.Gain_Gain * torqueControlBalancing_B.NeckPosition[1];
        rtb_Switch[2] =
            torqueControlBalancing_P.Gain_Gain * torqueControlBalancing_B.NeckPosition[2];
    }
    else {
        rtb_Switch[0] = torqueControlBalancing_P.Constant_Value[0];
        rtb_Switch[1] = torqueControlBalancing_P.Constant_Value[1];
        rtb_Switch[2] = torqueControlBalancing_P.Constant_Value[2];
    }

    /* End of Switch: '<S79>/Switch' */

    /* MATLAB Function: '<S70>/Get Base Rotation From IMU' */
    torqueCo_GetBaseRotationFromIMU(rtb_imu_H_link,
                                    torqueControlBalancing_B.sf_MATLABFunction_i.s0,
                                    rtb_link_H_root,
                                    &torqueControlBalancing_B.sf_MATLABFunction_o.s0[0],
                                    &torqueControlBalancing_B.IMU_meas[0],
                                    rtb_Switch,
                                    &torqueControlBalancing_B.sf_GetBaseRotationFromIMU,
                                    &torqueControlBalancing_P);

    /* Switch: '<S70>/Switch6' incorporates:
     *  Constant: '<S70>/USE_IMU4EST_BASE'
     */
    if (torqueControlBalancing_P.Config.USE_IMU4EST_BASE) {
        memcpy(&torqueControlBalancing_B.Switch6[0],
               &torqueControlBalancing_B.sf_GetBaseRotationFromIMU.w_H_b[0],
               sizeof(real_T) << 4U);
    }
    else {
        memcpy(&torqueControlBalancing_B.Switch6[0], &rtb_link_H_root[0], sizeof(real_T) << 4U);
    }

    /* End of Switch: '<S70>/Switch6' */

    /* S-Function (BlockFactory): '<S103>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_h.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_h.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S103>/S-Function

    /* MATLAB Function: '<S95>/MATLAB Function' incorporates:
     *  Selector: '<S97>/CoM6D ->  CoMXYZ2'
     */
    /* MATLAB Function 'Utilities/holder /MATLAB Function': '<S100>:1' */
    if (!torqueControlBalancing_DW.state_not_empty) {
        /* '<S100>:1:5' */
        /* '<S100>:1:6' */
        torqueControlBalancing_DW.state[0] = torqueControlBalancing_B.SFunction_j[12];
        torqueControlBalancing_DW.state[1] = torqueControlBalancing_B.SFunction_j[13];
        torqueControlBalancing_DW.state[2] = torqueControlBalancing_B.SFunction_j[14];
        torqueControlBalancing_DW.state_not_empty = true;
    }

    /* RelationalOperator: '<S101>/Compare' incorporates:
     *  Clock: '<S96>/Clock'
     *  Constant: '<S101>/Constant'
     */
    /* '<S100>:1:9' */
    rtb_Compare_f = ((&torqueControlBalancing_M)->Timing.t[0]
                     == torqueControlBalancing_P.CompareToConstant_const_pf);

    /* MATLAB Function: '<S96>/MATLAB Function' */
    torqueControlBal_MATLABFunction(torqueControlBalancing_B.SFunction_d,
                                    &torqueControlBalancing_B.sf_MATLABFunction_d,
                                    &torqueControlBalancing_DW.sf_MATLABFunction_d);

    /* S-Function (BlockFactory): '<S84>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_g.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_g.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S84>/S-Function

    /* S-Function (BlockFactory): '<S73>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_l.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_l.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S73>/S-Function

    /* Product: '<S71>/Inv' */
    rt_mldivided4x4(torqueControlBalancing_B.SFunction_f,
                    torqueControlBalancing_B.SFunction_i,
                    rtb_imu_H_link_a);

    /* RelationalOperator: '<S90>/Compare' incorporates:
     *  Clock: '<S87>/Clock'
     *  Constant: '<S90>/Constant'
     */
    rtb_Compare_l = ((&torqueControlBalancing_M)->Timing.t[0]
                     == torqueControlBalancing_P.CompareToConstant_const_h);

    /* MATLAB Function: '<S87>/MATLAB Function' */
    torqueControlB_MATLABFunction_i(rtb_imu_H_link_a,
                                    &torqueControlBalancing_B.sf_MATLABFunction_j,
                                    &torqueControlBalancing_DW.sf_MATLABFunction_j);

    /* S-Function (BlockFactory): '<S85>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_a.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_a.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S85>/S-Function

    /* Product: '<S71>/Inv_2' */
    rt_mldivided4x4(torqueControlBalancing_B.SFunction_i,
                    torqueControlBalancing_B.SFunction_e,
                    rtb_link_H_root_l);

    /* RelationalOperator: '<S92>/Compare' incorporates:
     *  Clock: '<S88>/Clock'
     *  Constant: '<S92>/Constant'
     */
    rtb_Compare_lt = ((&torqueControlBalancing_M)->Timing.t[0]
                      == torqueControlBalancing_P.CompareToConstant_const_k);

    /* MATLAB Function: '<S88>/MATLAB Function' */
    torqueControlB_MATLABFunction_o(torqueControlBalancing_B.IMU_meas,
                                    &torqueControlBalancing_B.sf_MATLABFunction_c,
                                    &torqueControlBalancing_DW.sf_MATLABFunction_c);

    /* S-Function (BlockFactory): '<S71>/Neck Position' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.NeckPosition_PWORK_j.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.NeckPosition_PWORK_j.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S71>/Neck Position

    /* Switch: '<S89>/Switch' incorporates:
     *  Constant: '<S89>/Constant'
     *  Constant: '<S89>/USE_IMU4EST_BASE1'
     *  Gain: '<S89>/Gain'
     */
    if (torqueControlBalancing_P.Config.CORRECT_NECK_IMU) {
        rtb_Switch_c[0] =
            torqueControlBalancing_P.Gain_Gain_j * torqueControlBalancing_B.NeckPosition_n[0];
        rtb_Switch_c[1] =
            torqueControlBalancing_P.Gain_Gain_j * torqueControlBalancing_B.NeckPosition_n[1];
        rtb_Switch_c[2] =
            torqueControlBalancing_P.Gain_Gain_j * torqueControlBalancing_B.NeckPosition_n[2];
    }
    else {
        rtb_Switch_c[0] = torqueControlBalancing_P.Constant_Value_e[0];
        rtb_Switch_c[1] = torqueControlBalancing_P.Constant_Value_e[1];
        rtb_Switch_c[2] = torqueControlBalancing_P.Constant_Value_e[2];
    }

    /* End of Switch: '<S89>/Switch' */

    /* MATLAB Function: '<S71>/Get Base Rotation From IMU' */
    torqueCo_GetBaseRotationFromIMU(rtb_imu_H_link_a,
                                    torqueControlBalancing_B.sf_MATLABFunction_j.s0,
                                    rtb_link_H_root_l,
                                    &torqueControlBalancing_B.sf_MATLABFunction_c.s0[0],
                                    &torqueControlBalancing_B.IMU_meas[0],
                                    rtb_Switch_c,
                                    &torqueControlBalancing_B.sf_GetBaseRotationFromIMU_c,
                                    &torqueControlBalancing_P);

    /* Switch: '<S71>/Switch6' incorporates:
     *  Constant: '<S71>/USE_IMU4EST_BASE'
     */
    if (torqueControlBalancing_P.Config.USE_IMU4EST_BASE) {
        memcpy(&torqueControlBalancing_B.Switch6_e[0],
               &torqueControlBalancing_B.sf_GetBaseRotationFromIMU_c.w_H_b[0],
               sizeof(real_T) << 4U);
    }
    else {
        memcpy(&torqueControlBalancing_B.Switch6_e[0], &rtb_link_H_root_l[0], sizeof(real_T) << 4U);
    }

    /* End of Switch: '<S71>/Switch6' */

    /* S-Function (BlockFactory): '<S104>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_k.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_k.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S104>/S-Function

    /* Clock: '<S64>/Clock1' */
    rtb_Clock1 = (&torqueControlBalancing_M)->Timing.t[0];

    /* S-Function (BlockFactory): '<Root>/wrench_rightFoot' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.wrench_rightFoot_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.wrench_rightFoot_PWORK.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <Root>/wrench_rightFoot

    /* S-Function (BlockFactory): '<Root>/wrench_leftFoot' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.wrench_leftFoot_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.wrench_leftFoot_PWORK.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <Root>/wrench_leftFoot

    /* MATLAB Function: '<S64>/STATE MACHINE' incorporates:
     *  MATLAB Function: '<S95>/MATLAB Function'
     *  Selector: '<S97>/CoM6D ->  CoMXYZ2'
     *  Selector: '<S98>/CoM6D ->  CoMXYZ2'
     */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Robot State and References/State Machine/STATE
     * MACHINE': '<S94>:1' */
    /* '<S94>:1:5' */
    if (!torqueControlBalancing_DW.currentState_not_empty) {
        torqueControlBalancing_DW.currentState = torqueControlBalancing_P.StateMachine.initialState;
        torqueControlBalancing_DW.currentState_not_empty = true;
    }

    torqueControlBalancing_B.pos_CoM_des[0] = torqueControlBalancing_DW.state[0];
    torqueControlBalancing_B.pos_CoM_des[1] = torqueControlBalancing_DW.state[1];
    torqueControlBalancing_B.pos_CoM_des[2] = torqueControlBalancing_DW.state[2];
    rtb_feetContactStatus_idx_0 = 1;
    rtb_feetContactStatus_idx_1 = 1;
    memcpy(&torqueControlBalancing_B.jointPos_des[0],
           &torqueControlBalancing_B.sf_MATLABFunction_d.s0[0],
           23U * sizeof(real_T));
    memset(&torqueControlBalancing_B.w_H_b[0], 0, sizeof(real_T) << 4U);
    torqueControlBalancing_B.w_H_b[0] = 1.0;
    torqueControlBalancing_B.w_H_b[5] = 1.0;
    torqueControlBalancing_B.w_H_b[10] = 1.0;
    torqueControlBalancing_B.w_H_b[15] = 1.0;
    if (torqueControlBalancing_DW.currentState == 1.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        if (torqueControlBalancing_P.Config.COORDINATOR_DEMO) {
            if (torqueControlBalancing_P.Config.LEFT_RIGHT_MOVEMENTS) {
                if (rtb_Clock1 > torqueControlBalancing_P.Config.noOscillationTime) {
                    delta_u_min = torqueControlBalancing_P.Config.amplitudeOfOscillation;
                }
                else {
                    delta_u_min = 0.0;
                }

                delta_u_min *=
                    std::sin(6.2831853071795862
                             * torqueControlBalancing_P.Config.frequencyOfOscillation * rtb_Clock1);
                torqueControlBalancing_B.pos_CoM_des[0] =
                    delta_u_min * torqueControlBalancing_P.Config.directionOfOscillation[0]
                    + torqueControlBalancing_DW.state[0];
                torqueControlBalancing_B.pos_CoM_des[1] =
                    delta_u_min * torqueControlBalancing_P.Config.directionOfOscillation[1]
                    + torqueControlBalancing_DW.state[1];
                torqueControlBalancing_B.pos_CoM_des[2] =
                    delta_u_min * torqueControlBalancing_P.Config.directionOfOscillation[2]
                    + torqueControlBalancing_DW.state[2];
            }
        }
        else {
            if (rtb_Clock1 > torqueControlBalancing_P.StateMachine.tBalancing) {
                torqueControlBalancing_DW.currentState = 2.0;
                if (torqueControlBalancing_P.StateMachine.demoStartsOnRightSupport) {
                    for (i_0 = 0; i_0 < 4; i_0++) {
                        for (i = 0; i < 4; i++) {
                            tmp_0[i + (i_0 << 2)] = 0.0;
                            tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[i_0 << 2]
                                                     * torqueControlBalancing_DW.w_H_fixedLink[i];
                            tmp_0[i + (i_0 << 2)] +=
                                torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                                * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                            tmp_0[i + (i_0 << 2)] +=
                                torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                                * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                            tmp_0[i + (i_0 << 2)] +=
                                torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                                * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
                        }
                    }

                    for (i_0 = 0; i_0 < 4; i_0++) {
                        torqueControlBalancing_DW.w_H_fixedLink[i_0 << 2] = tmp_0[i_0 << 2];
                        torqueControlBalancing_DW.w_H_fixedLink[1 + (i_0 << 2)] =
                            tmp_0[(i_0 << 2) + 1];
                        torqueControlBalancing_DW.w_H_fixedLink[2 + (i_0 << 2)] =
                            tmp_0[(i_0 << 2) + 2];
                        torqueControlBalancing_DW.w_H_fixedLink[3 + (i_0 << 2)] =
                            tmp_0[(i_0 << 2) + 3];
                    }

                    torqueControlBalanci_mrdivide_h(torqueControlBalancing_DW.w_H_fixedLink,
                                                    torqueControlBalancing_B.Switch6_e);
                    torqueControlBalancing_DW.currentState = 8.0;
                }
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 2.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        fixed_link_CoMDes[0] = torqueControlBalancing_B.pos_CoM_des[0];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        fixed_link_CoMDes[1] = torqueControlBalancing_B.pos_CoM_des[1];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        fixed_link_CoMDes[2] = torqueControlBalancing_B.pos_CoM_des[2];
        fixed_link_CoMDes[3] = 1.0;
        torqueControlBalanci_mldivide_o(torqueControlBalancing_DW.w_H_fixedLink, fixed_link_CoMDes);
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        if ((std::abs(fixed_link_CoMDes[1] - torqueControlBalancing_B.SFunction_j[13])
             < torqueControlBalancing_P.StateMachine.CoM_threshold)
            && (torqueControlBalancing_B.wrench_rightFoot[2]
                < torqueControlBalancing_P.StateMachine.wrench_thresholdContactOff)) {
            torqueControlBalancing_DW.currentState = 3.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
        }
    }

    if (torqueControlBalancing_DW.currentState == 3.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        rtb_feetContactStatus_idx_1 = 0;
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        if (rtb_Clock1 > torqueControlBalancing_DW.t_switch
                             + torqueControlBalancing_P.StateMachine.tBalancingBeforeYoga) {
            torqueControlBalancing_DW.currentState = 4.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
            if (torqueControlBalancing_P.StateMachine.skipYoga) {
                torqueControlBalancing_DW.currentState = 5.0;
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 4.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        rtb_feetContactStatus_idx_1 = 0;
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        for (i = 0; i < 25; i++) {
            if ((rtb_Clock1 > torqueControlBalancing_P.StateMachine.joints_leftYogaRef[i]
                                  + torqueControlBalancing_DW.t_switch)
                && (rtb_Clock1 <= torqueControlBalancing_P.StateMachine.joints_leftYogaRef[i + 1]
                                      + torqueControlBalancing_DW.t_switch)) {
                for (i_0 = 0; i_0 < 23; i_0++) {
                    torqueControlBalancing_B.jointPos_des[i_0] =
                        torqueControlBalancing_P.StateMachine
                            .joints_leftYogaRef[(1 + i_0) * 26 + i];
                }
            }
        }

        if (rtb_Clock1 > torqueControlBalancing_P.StateMachine.joints_leftYogaRef[25]
                             + torqueControlBalancing_DW.t_switch) {
            for (i_0 = 0; i_0 < 23; i_0++) {
                torqueControlBalancing_B.jointPos_des[i_0] =
                    torqueControlBalancing_P.StateMachine.joints_leftYogaRef[(1 + i_0) * 26 + 25];
            }

            if (rtb_Clock1
                > ((torqueControlBalancing_P.StateMachine.joints_leftYogaRef[25]
                    + torqueControlBalancing_DW.t_switch)
                   + torqueControlBalancing_P.StateMachine
                         .jointsSmoothingTime[(int32_T) torqueControlBalancing_DW.currentState - 1])
                      + torqueControlBalancing_P.StateMachine.joints_pauseBetweenYogaMoves) {
                torqueControlBalancing_DW.t_switch = rtb_Clock1;
                torqueControlBalancing_DW.yogaMovesetCounter++;
                if ((torqueControlBalancing_DW.yogaMovesetCounter
                     > torqueControlBalancing_P.StateMachine.yogaCounter)
                    || (!torqueControlBalancing_P.StateMachine.oneFootYogaInLoop)) {
                    torqueControlBalancing_DW.currentState = 5.0;
                }
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 5.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        rtb_feetContactStatus_idx_1 = 0;
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        for (i_0 = 0; i_0 < 6; i_0++) {
            LDot_star_0[i_0] = torqueControlBalancing_B.SFunction_d[17 + i_0]
                               - torqueControlBalancing_B.jointPos_des[17 + i_0];
        }

        if (torqueControlBalancing_norm(LDot_star_0) * 180.0 / 3.1415926535897931
            < torqueControlBalancing_P.StateMachine.joints_thresholdNotInContact) {
            for (i_0 = 0; i_0 < 6; i_0++) {
                LDot_star_0[i_0] = torqueControlBalancing_B.SFunction_d[11 + i_0]
                                   - torqueControlBalancing_B.jointPos_des[11 + i_0];
            }

            if (torqueControlBalancing_norm(LDot_star_0) * 180.0 / 3.1415926535897931
                < torqueControlBalancing_P.StateMachine.joints_thresholdInContact) {
                torqueControlBalancing_DW.currentState = 6.0;
                torqueControlBalancing_DW.t_switch = rtb_Clock1;
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 6.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        rtb_feetContactStatus_idx_1 = 0;
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        if (torqueControlBalancing_B.wrench_rightFoot[2]
            > torqueControlBalancing_P.StateMachine.wrench_thresholdContactOn) {
            torqueControlBalancing_DW.currentState = 7.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
        }
    }

    if (torqueControlBalancing_DW.currentState == 7.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.state[0];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.state[1];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        scale = 3.3121686421112381E-170;
        absxk = std::abs(torqueControlBalancing_B.SFunction_j[12]
                         - torqueControlBalancing_B.pos_CoM_des[0]);
        if (absxk > 3.3121686421112381E-170) {
            delta_u_min = 1.0;
            scale = absxk;
        }
        else {
            t = absxk / 3.3121686421112381E-170;
            delta_u_min = t * t;
        }

        rtb_feetContactStatus_idx_1 = 1;
        absxk = std::abs(torqueControlBalancing_B.SFunction_j[13]
                         - torqueControlBalancing_B.pos_CoM_des[1]);
        if (absxk > scale) {
            t = scale / absxk;
            delta_u_min = delta_u_min * t * t + 1.0;
            scale = absxk;
        }
        else {
            t = absxk / scale;
            delta_u_min += t * t;
        }

        delta_u_min = scale * std::sqrt(delta_u_min);
        if ((delta_u_min < 10.0 * torqueControlBalancing_P.StateMachine.CoM_threshold)
            && torqueControlBalancing_P.StateMachine.yogaAlsoOnRightFoot
            && (rtb_Clock1 > torqueControlBalancing_DW.t_switch
                                 + torqueControlBalancing_P.StateMachine.tBalancing)) {
            for (i_0 = 0; i_0 < 4; i_0++) {
                for (i = 0; i < 4; i++) {
                    tmp_0[i + (i_0 << 2)] = 0.0;
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[i_0 << 2]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i];
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
                }
            }

            for (i_0 = 0; i_0 < 4; i_0++) {
                torqueControlBalancing_DW.w_H_fixedLink[i_0 << 2] = tmp_0[i_0 << 2];
                torqueControlBalancing_DW.w_H_fixedLink[1 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 1];
                torqueControlBalancing_DW.w_H_fixedLink[2 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 2];
                torqueControlBalancing_DW.w_H_fixedLink[3 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 3];
            }

            torqueControlBalanci_mrdivide_h(torqueControlBalancing_DW.w_H_fixedLink,
                                            torqueControlBalancing_B.Switch6_e);
            torqueControlBalancing_DW.currentState = 8.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
        }
    }

    if (torqueControlBalancing_DW.currentState == 8.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        rtb_feetContactStatus_idx_1 = 1;
        fixed_link_CoMDes[0] = torqueControlBalancing_B.pos_CoM_des[0];
        fixed_link_CoMDes[1] = torqueControlBalancing_B.pos_CoM_des[1];
        fixed_link_CoMDes[2] = torqueControlBalancing_B.pos_CoM_des[2];
        fixed_link_CoMDes[3] = 1.0;
        torqueControlBalanci_mldivide_o(torqueControlBalancing_DW.w_H_fixedLink, fixed_link_CoMDes);
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        if ((std::abs(fixed_link_CoMDes[1] - torqueControlBalancing_B.SFunction_c[13])
             < torqueControlBalancing_P.StateMachine.CoM_threshold)
            && (torqueControlBalancing_B.wrench_leftFoot[2]
                < torqueControlBalancing_P.StateMachine.wrench_thresholdContactOff)) {
            torqueControlBalancing_DW.currentState = 9.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
        }
    }

    if (torqueControlBalancing_DW.currentState == 9.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        rtb_feetContactStatus_idx_0 = 0;
        rtb_feetContactStatus_idx_1 = 1;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        if (rtb_Clock1 > torqueControlBalancing_DW.t_switch
                             + torqueControlBalancing_P.StateMachine.tBalancingBeforeYoga) {
            torqueControlBalancing_DW.currentState = 10.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
            if (torqueControlBalancing_P.StateMachine.skipYoga) {
                torqueControlBalancing_DW.currentState = 11.0;
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 10.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        rtb_feetContactStatus_idx_0 = 0;
        rtb_feetContactStatus_idx_1 = 1;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        for (i = 0; i < 25; i++) {
            if ((rtb_Clock1 > torqueControlBalancing_P.StateMachine.joints_rightYogaRef[i]
                                  + torqueControlBalancing_DW.t_switch)
                && (rtb_Clock1 <= torqueControlBalancing_P.StateMachine.joints_rightYogaRef[i + 1]
                                      + torqueControlBalancing_DW.t_switch)) {
                for (i_0 = 0; i_0 < 23; i_0++) {
                    torqueControlBalancing_B.jointPos_des[i_0] =
                        torqueControlBalancing_P.StateMachine
                            .joints_rightYogaRef[(1 + i_0) * 26 + i];
                }
            }
        }

        if (rtb_Clock1 > torqueControlBalancing_P.StateMachine.joints_rightYogaRef[25]
                             + torqueControlBalancing_DW.t_switch) {
            for (i_0 = 0; i_0 < 23; i_0++) {
                torqueControlBalancing_B.jointPos_des[i_0] =
                    torqueControlBalancing_P.StateMachine.joints_rightYogaRef[(1 + i_0) * 26 + 25];
            }

            if (rtb_Clock1
                > ((torqueControlBalancing_P.StateMachine.joints_rightYogaRef[25]
                    + torqueControlBalancing_DW.t_switch)
                   + torqueControlBalancing_P.StateMachine
                         .jointsSmoothingTime[(int32_T) torqueControlBalancing_DW.currentState - 1])
                      + torqueControlBalancing_P.StateMachine.joints_pauseBetweenYogaMoves) {
                torqueControlBalancing_DW.t_switch = rtb_Clock1;
                torqueControlBalancing_DW.yogaMovesetCounter++;
                if ((torqueControlBalancing_DW.yogaMovesetCounter
                     > torqueControlBalancing_P.StateMachine.yogaCounter)
                    || (!torqueControlBalancing_P.StateMachine.oneFootYogaInLoop)) {
                    torqueControlBalancing_DW.currentState = 11.0;
                }
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 11.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        rtb_feetContactStatus_idx_0 = 0;
        rtb_feetContactStatus_idx_1 = 1;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        for (i_0 = 0; i_0 < 6; i_0++) {
            LDot_star_0[i_0] = torqueControlBalancing_B.SFunction_d[17 + i_0]
                               - torqueControlBalancing_B.jointPos_des[17 + i_0];
        }

        if (torqueControlBalancing_norm(LDot_star_0) * 180.0 / 3.1415926535897931
            < torqueControlBalancing_P.StateMachine.joints_thresholdInContact) {
            for (i_0 = 0; i_0 < 6; i_0++) {
                LDot_star_0[i_0] = torqueControlBalancing_B.SFunction_d[11 + i_0]
                                   - torqueControlBalancing_B.jointPos_des[11 + i_0];
            }

            if (torqueControlBalancing_norm(LDot_star_0) * 180.0 / 3.1415926535897931
                < torqueControlBalancing_P.StateMachine.joints_thresholdNotInContact) {
                torqueControlBalancing_DW.currentState = 12.0;
                torqueControlBalancing_DW.t_switch = rtb_Clock1;
            }
        }
    }

    if (torqueControlBalancing_DW.currentState == 12.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        rtb_feetContactStatus_idx_0 = 0;
        rtb_feetContactStatus_idx_1 = 1;
        torqueControlBalancing_B.pos_CoM_des[0] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 - 1]
            + torqueControlBalancing_DW.w_H_fixedLink[12];
        torqueControlBalancing_B.pos_CoM_des[1] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 12]
            + torqueControlBalancing_DW.w_H_fixedLink[13];
        torqueControlBalancing_B.pos_CoM_des[2] =
            torqueControlBalancing_P.StateMachine.CoM_delta[i_0 + 25]
            + torqueControlBalancing_DW.state[2];
        i_0 = (int32_T) torqueControlBalancing_DW.currentState;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.jointPos_des[i] =
                torqueControlBalancing_P.StateMachine.joints_references[(13 * i + i_0) - 1];
        }

        if (torqueControlBalancing_B.wrench_leftFoot[2]
            > torqueControlBalancing_P.StateMachine.wrench_thresholdContactOn) {
            torqueControlBalancing_DW.currentState = 13.0;
            torqueControlBalancing_DW.t_switch = rtb_Clock1;
        }
    }

    if (torqueControlBalancing_DW.currentState == 13.0) {
        for (i_0 = 0; i_0 < 4; i_0++) {
            for (i = 0; i < 4; i++) {
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] = 0.0;
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[i_0 << 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                torqueControlBalancing_B.w_H_b[i + (i_0 << 2)] +=
                    torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                    * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
            }
        }

        rtb_feetContactStatus_idx_0 = 1;
        rtb_feetContactStatus_idx_1 = 1;
        if ((rtb_Clock1 - torqueControlBalancing_DW.t_switch
             > torqueControlBalancing_P.StateMachine.tBalancing)
            && torqueControlBalancing_P.StateMachine.twoFeetYogaInLoop) {
            torqueControlBalancing_DW.currentState = 2.0;
            for (i_0 = 0; i_0 < 4; i_0++) {
                for (i = 0; i < 4; i++) {
                    tmp_0[i + (i_0 << 2)] = 0.0;
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6_e[i_0 << 2]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i];
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 1]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 2]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                    tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6_e[(i_0 << 2) + 3]
                                             * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
                }
            }

            for (i_0 = 0; i_0 < 4; i_0++) {
                torqueControlBalancing_DW.w_H_fixedLink[i_0 << 2] = tmp_0[i_0 << 2];
                torqueControlBalancing_DW.w_H_fixedLink[1 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 1];
                torqueControlBalancing_DW.w_H_fixedLink[2 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 2];
                torqueControlBalancing_DW.w_H_fixedLink[3 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 3];
            }

            torqueControlBalanci_mrdivide_h(torqueControlBalancing_DW.w_H_fixedLink,
                                            torqueControlBalancing_B.Switch6);
            if (torqueControlBalancing_P.StateMachine.demoStartsOnRightSupport) {
                torqueControlBalancing_DW.currentState = 8.0;
                for (i_0 = 0; i_0 < 4; i_0++) {
                    for (i = 0; i < 4; i++) {
                        tmp_0[i + (i_0 << 2)] = 0.0;
                        tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[i_0 << 2]
                                                 * torqueControlBalancing_DW.w_H_fixedLink[i];
                        tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[(i_0 << 2) + 1]
                                                 * torqueControlBalancing_DW.w_H_fixedLink[i + 4];
                        tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[(i_0 << 2) + 2]
                                                 * torqueControlBalancing_DW.w_H_fixedLink[i + 8];
                        tmp_0[i + (i_0 << 2)] += torqueControlBalancing_B.Switch6[(i_0 << 2) + 3]
                                                 * torqueControlBalancing_DW.w_H_fixedLink[i + 12];
                    }
                }

                for (i_0 = 0; i_0 < 4; i_0++) {
                    torqueControlBalancing_DW.w_H_fixedLink[i_0 << 2] = tmp_0[i_0 << 2];
                    torqueControlBalancing_DW.w_H_fixedLink[1 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 1];
                    torqueControlBalancing_DW.w_H_fixedLink[2 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 2];
                    torqueControlBalancing_DW.w_H_fixedLink[3 + (i_0 << 2)] = tmp_0[(i_0 << 2) + 3];
                }

                torqueControlBalanci_mrdivide_h(torqueControlBalancing_DW.w_H_fixedLink,
                                                torqueControlBalancing_B.Switch6_e);
            }
        }
    }

    /* '<S94>:1:5' */
    if ((torqueControlBalancing_DW.currentState == 4.0)
        || (torqueControlBalancing_DW.currentState == 10.0)) {
        torqueControlBalancing_B.smoothingTimeJoints =
            torqueControlBalancing_P.StateMachine
                .jointsSmoothingTime[(int32_T) torqueControlBalancing_DW.currentState - 1]
            * torqueControlBalancing_P.StateMachine.scaleFactorSmoothingTime;
    }
    else {
        torqueControlBalancing_B.smoothingTimeJoints =
            torqueControlBalancing_P.StateMachine
                .jointsSmoothingTime[(int32_T) torqueControlBalancing_DW.currentState - 1];
    }

    torqueControlBalancing_B.smoothingTimeCoM =
        torqueControlBalancing_P.StateMachine
            .CoMSmoothingTime[(int32_T) torqueControlBalancing_DW.currentState - 1];

    /* S-Function (BlockFactory): '<S107>/MinimumJerkTrajectoryGenerator1' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator1.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator1.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S107>/MinimumJerkTrajectoryGenerator1

    /* Switch: '<S107>/Switch5' incorporates:
     *  Constant: '<S107>/SMOOTH_DES_COM2'
     */
    if (torqueControlBalancing_P.Config.SMOOTH_JOINT_DES) {
        memcpy(&torqueControlBalancing_B.Switch5[0],
               &torqueControlBalancing_B.MinimumJerkTrajectoryGenerator1[0],
               23U * sizeof(real_T));
    }
    else {
        memcpy(&torqueControlBalancing_B.Switch5[0],
               &torqueControlBalancing_B.jointPos_des[0],
               23U * sizeof(real_T));
    }

    /* End of Switch: '<S107>/Switch5' */

    /* S-Function (BlockFactory): '<S68>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_j.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_j.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S68>/S-Function

    /* S-Function (BlockFactory): '<S69>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_jg.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_jg.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S69>/S-Function

    /* S-Function (BlockFactory): '<S5>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_bs.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_bs.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S5>/S-Function

    /* MATLAB Function: '<S62>/Compute Base Velocity' */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Robot State and References/Compute State
     * Velocity/Compute Base Velocity': '<S66>:1' */
    /* '<S66>:1:3' */
    /* '<S66>:1:5' */
    for (i_0 = 0; i_0 < 29; i_0++) {
        for (i = 0; i < 6; i++) {
            Jc_tmp = 6 * i_0 + i;
            Jc_tmp_0 = i + 12 * i_0;
            Jc[Jc_tmp_0] = torqueControlBalancing_B.SFunction_e0[Jc_tmp]
                           * (real_T) rtb_feetContactStatus_idx_0;
            Jc[Jc_tmp_0 + 6] = torqueControlBalancing_B.SFunction_da[Jc_tmp]
                               * (real_T) rtb_feetContactStatus_idx_1;
        }
    }

    torqueControlBalan_pinvDamped_i(&Jc[0], torqueControlBalancing_P.Reg.pinvDamp_baseVel, pinvA);
    for (i_0 = 0; i_0 < 12; i_0++) {
        for (i = 0; i < 6; i++) {
            tmp_1[i + 6 * i_0] = -pinvA[6 * i_0 + i];
        }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        torqueControlBalancing_B.nu_b[i_0] = 0.0;
        for (i = 0; i < 23; i++) {
            Jc_tmp_0 = i_0 + 6 * i;
            pinvJb_1[Jc_tmp_0] = 0.0;
            for (Jc_tmp = 0; Jc_tmp < 12; Jc_tmp++) {
                pinvJb_1[Jc_tmp_0] =
                    Jc[(6 + i) * 12 + Jc_tmp] * tmp_1[6 * Jc_tmp + i_0] + pinvJb_1[6 * i + i_0];
            }

            torqueControlBalancing_B.nu_b[i_0] +=
                pinvJb_1[6 * i + i_0] * torqueControlBalancing_B.SFunction_nr[i];
        }
    }

    /* End of MATLAB Function: '<S62>/Compute Base Velocity' */

    /* S-Function (BlockFactory): '<S48>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_n.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_n.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S48>/S-Function

    /* MATLAB Function: '<S45>/Add motor reflected inertias' */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Dynamics and Kinematics/Dynamics/Add motors
     * reflected inertia/Add motor reflected inertias': '<S49>:1' */
    /* '<S49>:1:3' */
    /* '<S49>:1:4' */
    /* '<S49>:1:5' */
    /* '<S49>:1:7' */
    torqu_addMotorsReflectedInertia(torqueControlBalancing_B.SFunction_b,
                                    torqueControlBalancing_P.Config.Gamma,
                                    torqueControlBalancing_P.Config.T,
                                    torqueControlBalancing_P.Config.I_m,
                                    torqueControlBalancing_B.M_with_inertia);

    /* Switch: '<S45>/Switch' incorporates:
     *  Constant: '<S45>/Constant'
     */
    for (i_0 = 0; i_0 < 841; i_0++) {
        rtb_Clock1 = torqueControlBalancing_B.M_with_inertia[i_0];
        if (!torqueControlBalancing_P.Config.USE_MOTOR_REFLECTED_INERTIA) {
            rtb_Clock1 = torqueControlBalancing_B.SFunction_b[i_0];
        }

        torqueControlBalancing_B.M_with_inertia[i_0] = rtb_Clock1;
    }

    /* End of Switch: '<S45>/Switch' */

    /* Gain: '<S47>/Gain' */
    for (i = 0; i < 23; i++) {
        torqueControlBalancing_B.Gain[i] =
            torqueControlBalancing_P.Gain_Gain_o * torqueControlBalancing_B.SFunction_nr[i];
    }

    /* End of Gain: '<S47>/Gain' */

    /* S-Function (BlockFactory): '<S47>/S-Function' incorporates:
     *  Constant: '<S47>/Constant'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_hk.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_hk.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S47>/S-Function

    /* S-Function (BlockFactory): '<S46>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_e.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_e.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S46>/S-Function

    /* S-Function (BlockFactory): '<S40>/S-Function' incorporates:
     *  Constant: '<S35>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_d.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_d.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S40>/S-Function

    /* MATLAB Function: '<S21>/Select base to world transform' incorporates:
     *  MATLAB Function: '<S64>/STATE MACHINE'
     */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute angular
     * momentum integral error/Select base to world transform': '<S39>:1' */
    /* '<S39>:1:8' */
    rtb_Clock1 = 1.0;
    if ((torqueControlBalancing_DW.currentState == 9.0)
        || (torqueControlBalancing_DW.currentState == 10.0)
        || (torqueControlBalancing_DW.currentState == 11.0)
        || (torqueControlBalancing_DW.currentState == 12.0)) {
        /* '<S39>:1:10' */
        /* '<S39>:1:12' */
        rtb_Clock1 = 0.0;
    }

    /* End of MATLAB Function: '<S21>/Select base to world transform' */

    /* S-Function (BlockFactory): '<S41>/S-Function' incorporates:
     *  Constant: '<S35>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_er.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_er.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S41>/S-Function

    /* Switch: '<S21>/Switch' */
    if (rtb_Clock1 > torqueControlBalancing_P.Switch_Threshold) {
        /* Product: '<S35>/inv  ' */
        rt_invd4x4(torqueControlBalancing_B.SFunction_br, torqueControlBalancing_B.Switch);
    }
    else {
        /* Product: '<S35>/inv  1' */
        rt_invd4x4(torqueControlBalancing_B.SFunction_ai, torqueControlBalancing_B.Switch);
    }

    /* End of Switch: '<S21>/Switch' */

    /* S-Function (BlockFactory): '<S37>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_dc.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_dc.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S37>/S-Function

    /* S-Function (BlockFactory): '<S38>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_am.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_am.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S38>/S-Function

    /* Sum: '<S21>/Add' */
    for (i = 0; i < 23; i++) {
        torqueControlBalancing_B.Add[i] =
            torqueControlBalancing_B.SFunction_d[i] - torqueControlBalancing_B.Switch5[i];
    }

    /* End of Sum: '<S21>/Add' */

    /* MATLAB Function: '<S21>/Get Equivalent Base Velocity' */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute angular
     * momentum integral error/Get Equivalent Base Velocity': '<S36>:1' */
    /* '<S36>:1:5' */
    if (rtb_feetContactStatus_idx_0 == 1) {
        /* '<S36>:1:3' */
        /* '<S36>:1:5' */
        for (i_0 = 0; i_0 < 6; i_0++) {
            for (i = 0; i < 6; i++) {
                Jc_tmp = 6 * i + i_0;
                pinvJb[i + 6 * i_0] = torqueControlBalancing_B.SFunction_e0o[Jc_tmp];
                scale = 0.0;
                for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                    scale += torqueControlBalancing_B.SFunction_e0o[6 * i_0 + Jc_tmp_0]
                             * torqueControlBalancing_B.SFunction_e0o[6 * i + Jc_tmp_0];
                }

                pinvJb_0[i_0 + 6 * i] =
                    (real_T) b[Jc_tmp] * torqueControlBalancing_P.Reg.pinvDamp_baseVel + scale;
            }
        }

        torqueControlBalanci_mldivide_l(pinvJb_0, pinvJb);

        /* '<S36>:1:6' */
        for (i_0 = 0; i_0 < 6; i_0++) {
            for (i = 0; i < 6; i++) {
                pinvJb_0[i + 6 * i_0] = -pinvJb[6 * i_0 + i];
            }
        }

        for (i_0 = 0; i_0 < 6; i_0++) {
            torqueControlBalancing_B.baseVel_equivalent[i_0] = 0.0;
            for (i = 0; i < 23; i++) {
                Jc_tmp = i_0 + 6 * i;
                pinvJb_1[Jc_tmp] = 0.0;
                for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                    pinvJb_1[Jc_tmp] =
                        torqueControlBalancing_B.SFunction_e0o[(6 + i) * 6 + Jc_tmp_0]
                            * pinvJb_0[6 * Jc_tmp_0 + i_0]
                        + pinvJb_1[6 * i + i_0];
                }

                torqueControlBalancing_B.baseVel_equivalent[i_0] +=
                    pinvJb_1[6 * i + i_0] * torqueControlBalancing_B.Add[i];
            }
        }
    }
    else {
        /* '<S36>:1:8' */
        for (i_0 = 0; i_0 < 6; i_0++) {
            for (i = 0; i < 6; i++) {
                Jc_tmp = 6 * i + i_0;
                pinvJb[i + 6 * i_0] = torqueControlBalancing_B.SFunction_cf[Jc_tmp];
                scale = 0.0;
                for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                    scale += torqueControlBalancing_B.SFunction_cf[6 * i_0 + Jc_tmp_0]
                             * torqueControlBalancing_B.SFunction_cf[6 * i + Jc_tmp_0];
                }

                pinvJb_0[i_0 + 6 * i] =
                    (real_T) b[Jc_tmp] * torqueControlBalancing_P.Reg.pinvDamp_baseVel + scale;
            }
        }

        torqueControlBalanci_mldivide_l(pinvJb_0, pinvJb);

        /* '<S36>:1:9' */
        for (i_0 = 0; i_0 < 6; i_0++) {
            for (i = 0; i < 6; i++) {
                pinvJb_0[i + 6 * i_0] = -pinvJb[6 * i_0 + i];
            }
        }

        for (i_0 = 0; i_0 < 6; i_0++) {
            torqueControlBalancing_B.baseVel_equivalent[i_0] = 0.0;
            for (i = 0; i < 23; i++) {
                Jc_tmp = i_0 + 6 * i;
                pinvJb_1[Jc_tmp] = 0.0;
                for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                    pinvJb_1[Jc_tmp] = torqueControlBalancing_B.SFunction_cf[(6 + i) * 6 + Jc_tmp_0]
                                           * pinvJb_0[6 * Jc_tmp_0 + i_0]
                                       + pinvJb_1[6 * i + i_0];
                }

                torqueControlBalancing_B.baseVel_equivalent[i_0] +=
                    pinvJb_1[6 * i + i_0] * torqueControlBalancing_B.Add[i];
            }
        }
    }

    /* End of MATLAB Function: '<S21>/Get Equivalent Base Velocity' */

    /* S-Function (BlockFactory): '<S34>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_c4.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_c4.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S34>/S-Function

    /* S-Function (BlockFactory): '<S56>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_jj.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_jj.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S56>/S-Function

    /* S-Function (BlockFactory): '<S57>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_pk.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_pk.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S57>/S-Function

    /* S-Function (BlockFactory): '<S54>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_ne.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_ne.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S54>/S-Function

    /* S-Function (BlockFactory): '<S55>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_bp.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_bp.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S55>/S-Function

    /* S-Function (BlockFactory): '<S51>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_d4.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_d4.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S51>/S-Function

    /* S-Function (BlockFactory): '<S52>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_d1.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_d1.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S52>/S-Function

    /* S-Function (BlockFactory): '<S50>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_hl.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_hl.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S50>/S-Function

    /* S-Function (BlockFactory): '<S53>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_ay.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_ay.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S53>/S-Function

    /* S-Function (BlockFactory): '<S106>/MinimumJerkTrajectoryGenerator2' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator2.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator2.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S106>/MinimumJerkTrajectoryGenerator2

    /* Switch: '<S106>/Switch3' incorporates:
     *  Constant: '<S106>/Constant'
     *  Constant: '<S106>/SMOOTH_DES_COM'
     */
    if (torqueControlBalancing_P.Config.SMOOTH_COM_DES) {
        rtb_Switch3[0] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerator2[0];
        rtb_Switch3[3] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_a[0];
        rtb_Switch3[6] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerat_pp[0];
        rtb_Switch3[1] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerator2[1];
        rtb_Switch3[4] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_a[1];
        rtb_Switch3[7] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerat_pp[1];
        rtb_Switch3[2] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerator2[2];
        rtb_Switch3[5] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_a[2];
        rtb_Switch3[8] = torqueControlBalancing_B.MinimumJerkTrajectoryGenerat_pp[2];
    }
    else {
        rtb_Switch3[0] = torqueControlBalancing_B.pos_CoM_des[0];
        rtb_Switch3[3] = torqueControlBalancing_P.Constant_Value_i[0];
        rtb_Switch3[6] = torqueControlBalancing_P.Constant_Value_i[3];
        rtb_Switch3[1] = torqueControlBalancing_B.pos_CoM_des[1];
        rtb_Switch3[4] = torqueControlBalancing_P.Constant_Value_i[1];
        rtb_Switch3[7] = torqueControlBalancing_P.Constant_Value_i[4];
        rtb_Switch3[2] = torqueControlBalancing_B.pos_CoM_des[2];
        rtb_Switch3[5] = torqueControlBalancing_P.Constant_Value_i[2];
        rtb_Switch3[8] = torqueControlBalancing_P.Constant_Value_i[5];
    }

    /* End of Switch: '<S106>/Switch3' */

    /* MATLAB Function: '<S64>/STATE MACHINE' */
    i_0 = (int32_T) torqueControlBalancing_DW.currentState;
    i = (int32_T) torqueControlBalancing_DW.currentState;
    Jc_tmp_0 = (int32_T) torqueControlBalancing_DW.currentState;

    /* SignalConversion: '<S64>/TmpSignal ConversionAtMinimumJerkTrajectoryGeneratorInport1'
     * incorporates: MATLAB Function: '<S64>/STATE MACHINE'
     */
    for (Jc_tmp = 0; Jc_tmp < 23; Jc_tmp++) {
        torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[Jc_tmp] =
            torqueControlBalancing_P.Gain.KP_postural[(13 * Jc_tmp + i_0) - 1];
    }

    torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[23] =
        torqueControlBalancing_P.Gain.KP_CoM[i - 1];
    torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[26] =
        torqueControlBalancing_P.Gain.KD_CoM[Jc_tmp_0 - 1];
    torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[24] =
        torqueControlBalancing_P.Gain.KP_CoM[i + 12];
    torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[27] =
        torqueControlBalancing_P.Gain.KD_CoM[Jc_tmp_0 + 12];
    torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[25] =
        torqueControlBalancing_P.Gain.KP_CoM[i + 25];
    torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[28] =
        torqueControlBalancing_P.Gain.KD_CoM[Jc_tmp_0 + 25];

    /* End of SignalConversion: '<S64>/TmpSignal ConversionAtMinimumJerkTrajectoryGeneratorInport1'
     */

    /* S-Function (BlockFactory): '<S64>/MinimumJerkTrajectoryGenerator' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator_.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator_.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S64>/MinimumJerkTrajectoryGenerator

    /* MATLAB Function: '<S105>/MATLAB Function1' */
    torqueControlBa_MATLABFunction1(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerator[23],
                                    &torqueControlBalancing_B.sf_MATLABFunction1);

    /* MATLAB Function: '<S105>/MATLAB Function2' */
    torqueControlBa_MATLABFunction1(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerator[26],
                                    &torqueControlBalancing_B.sf_MATLABFunction2);

    /* MATLAB Function: '<S105>/MATLAB Function' */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Robot State and References/Update Gains and
     * References/Reshape Gains Matrices/MATLAB Function': '<S108>:1' */
    /* '<S108>:1:3' */
    memset(&torqueControlBalancing_B.D[0], 0, 529U * sizeof(real_T));
    for (i = 0; i < 23; i++) {
        torqueControlBalancing_B.D[i + 23 * i] =
            torqueControlBalancing_B.MinimumJerkTrajectoryGenerator[i];
    }

    /* End of MATLAB Function: '<S105>/MATLAB Function' */
    for (i = 0; i < 6; i++) {
        /* SignalConversion: '<S23>/TmpSignal ConversionAt SFunction Inport6' incorporates:
         *  MATLAB Function: '<S15>/Momentum Based Balancing Controller '
         */
        rtb_TmpSignalConversionAtSFunct[i] = torqueControlBalancing_B.nu_b[i];
    }

    /* SignalConversion: '<S23>/TmpSignal ConversionAt SFunction Inport6' incorporates:
     *  MATLAB Function: '<S15>/Momentum Based Balancing Controller '
     */
    memcpy(&rtb_TmpSignalConversionAtSFunct[6],
           &torqueControlBalancing_B.SFunction_nr[0],
           23U * sizeof(real_T));

    /* MATLAB Function: '<S15>/Momentum Based Balancing Controller ' incorporates:
     *  Constant: '<S15>/Constant'
     *  Constant: '<S15>/Constant1'
     *  Selector: '<S44>/CoM6D ->  CoMXYZ2'
     */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Momentum Based
     * Balancing Controller ': '<S23>:1' */
    /* '<S23>:1:7' */
    f_grav[0] = 0.0;
    f_grav[1] = 0.0;
    f_grav[2] =
        -torqueControlBalancing_B.M_with_inertia[0] * torqueControlBalancing_P.Config.GRAV_ACC;
    f_grav[3] = 0.0;
    rtb_Clock1 =
        torqueControlBalancing_B.SFunction_oe[12] - torqueControlBalancing_B.SFunction_dk[12];
    delta_u_min =
        torqueControlBalancing_B.SFunction_jt[12] - torqueControlBalancing_B.SFunction_dk[12];
    f_grav[4] = 0.0;
    scale = torqueControlBalancing_B.SFunction_oe[13] - torqueControlBalancing_B.SFunction_dk[13];
    absxk = torqueControlBalancing_B.SFunction_jt[13] - torqueControlBalancing_B.SFunction_dk[13];
    f_grav[5] = 0.0;
    t = torqueControlBalancing_B.SFunction_oe[14] - torqueControlBalancing_B.SFunction_dk[14];
    r_right_idx_2 =
        torqueControlBalancing_B.SFunction_jt[14] - torqueControlBalancing_B.SFunction_dk[14];
    for (i_0 = 0; i_0 < 6; i_0++) {
        pinvJb[6 * i_0] = c[3 * i_0];
        pinvJb[1 + 6 * i_0] = c[3 * i_0 + 1];
        pinvJb[2 + 6 * i_0] = c[3 * i_0 + 2];
    }

    pinvJb[3] = 0.0;
    pinvJb[9] = -t;
    pinvJb[15] = scale;
    pinvJb[4] = t;
    pinvJb[10] = 0.0;
    pinvJb[16] = -rtb_Clock1;
    pinvJb[5] = -scale;
    pinvJb[11] = rtb_Clock1;
    pinvJb[17] = 0.0;
    for (i_0 = 0; i_0 < 3; i_0++) {
        Jc_tmp = 6 * (i_0 + 3);
        pinvJb[3 + Jc_tmp] = b_b[3 * i_0];
        pinvJb[4 + Jc_tmp] = b_b[3 * i_0 + 1];
        pinvJb[5 + Jc_tmp] = b_b[3 * i_0 + 2];
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        A_right[6 * i_0] = c[3 * i_0];
        A_right[1 + 6 * i_0] = c[3 * i_0 + 1];
        A_right[2 + 6 * i_0] = c[3 * i_0 + 2];
    }

    A_right[3] = 0.0;
    A_right[9] = -r_right_idx_2;
    A_right[15] = absxk;
    A_right[4] = r_right_idx_2;
    A_right[10] = 0.0;
    A_right[16] = -delta_u_min;
    A_right[5] = -absxk;
    A_right[11] = delta_u_min;
    A_right[17] = 0.0;
    for (i_0 = 0; i_0 < 3; i_0++) {
        i = 6 * (i_0 + 3);
        A_right[3 + i] = b_b[3 * i_0];
        A_right[4 + i] = b_b[3 * i_0 + 1];
        A_right[5 + i] = b_b[3 * i_0 + 2];
    }

    for (i_0 = 0; i_0 < 36; i_0++) {
        A[i_0] = pinvJb[i_0];
        A[i_0 + 36] = A_right[i_0];
    }

    for (i_0 = 0; i_0 < 3; i_0++) {
        tmp_2[i_0] = torqueControlBalancing_B.SFunction_dk[12 + i_0] - rtb_Switch3[i_0];
        scale = 0.0;
        for (i = 0; i < 29; i++) {
            scale += torqueControlBalancing_B.SFunction_n5[6 * i + i_0]
                     * rtb_TmpSignalConversionAtSFunct[i];
        }

        tmp_3[i_0] = scale - rtb_Switch3[3 + i_0];
    }

    for (i_0 = 0; i_0 < 3; i_0++) {
        rtb_Switch3_0[i_0] =
            rtb_Switch3[6 + i_0]
            - ((torqueControlBalancing_B.sf_MATLABFunction1.D[i_0 + 3] * tmp_2[1]
                + torqueControlBalancing_B.sf_MATLABFunction1.D[i_0] * tmp_2[0])
               + torqueControlBalancing_B.sf_MATLABFunction1.D[i_0 + 6] * tmp_2[2]);
        tmp_5[3 * i_0] =
            -((real_T) b_b[3 * i_0] * torqueControlBalancing_P.Gain.KP_AngularMomentum);
        tmp_5[1 + 3 * i_0] =
            -((real_T) b_b[3 * i_0 + 1] * torqueControlBalancing_P.Gain.KP_AngularMomentum);
        tmp_5[2 + 3 * i_0] =
            -((real_T) b_b[3 * i_0 + 2] * torqueControlBalancing_P.Gain.KP_AngularMomentum);
        tmp_4[i_0] = torqueControlBalancing_B.sf_MATLABFunction2.D[i_0 + 6] * tmp_3[2]
                     + (torqueControlBalancing_B.sf_MATLABFunction2.D[i_0 + 3] * tmp_3[1]
                        + torqueControlBalancing_B.sf_MATLABFunction2.D[i_0] * tmp_3[0]);
    }

    for (i_0 = 0; i_0 < 3; i_0++) {
        LDot_star[i_0] =
            (rtb_Switch3_0[i_0] - tmp_4[i_0]) * torqueControlBalancing_B.M_with_inertia[0];
        LDot_star[i_0 + 3] =
            (tmp_5[i_0 + 6] * torqueControlBalancing_B.SFunction_ci[5]
             + (tmp_5[i_0 + 3] * torqueControlBalancing_B.SFunction_ci[4]
                + tmp_5[i_0] * torqueControlBalancing_B.SFunction_ci[3]))
            - ((real_T) b_b[i_0 + 6] * torqueControlBalancing_P.Gain.KI_AngularMomentum
                   * torqueControlBalancing_B.SFunction_o[5]
               + ((real_T) b_b[i_0 + 3] * torqueControlBalancing_P.Gain.KI_AngularMomentum
                      * torqueControlBalancing_B.SFunction_o[4]
                  + torqueControlBalancing_P.Gain.KI_AngularMomentum * (real_T) b_b[i_0]
                        * torqueControlBalancing_B.SFunction_o[3]));
    }

    i_0 = 1 - rtb_feetContactStatus_idx_1;
    i = 1 - rtb_feetContactStatus_idx_0;
    for (Jc_tmp_0 = 0; Jc_tmp_0 < 36; Jc_tmp_0++) {
        pinvJb[Jc_tmp_0] = pinvJb[Jc_tmp_0] * (real_T) rtb_feetContactStatus_idx_0 * (real_T) i_0
                           + A_right[Jc_tmp_0] * (real_T) rtb_feetContactStatus_idx_1 * (real_T) i;
    }

    for (i_0 = 0; i_0 < 3; i_0++) {
        tmp_5[3 * i_0] = torqueControlBalancing_B.SFunction_oe[i_0];
        rtb_Switch3[3 * i_0] = torqueControlBalancing_B.SFunction_oe[i_0];
        i = 1 + 3 * i_0;
        tmp_5[i] = torqueControlBalancing_B.SFunction_oe[i_0 + 4];
        rtb_Switch3[i] = torqueControlBalancing_B.SFunction_oe[i_0 + 4];
        i = 2 + 3 * i_0;
        tmp_5[i] = torqueControlBalancing_B.SFunction_oe[i_0 + 8];
        rtb_Switch3[i] = torqueControlBalancing_B.SFunction_oe[i_0 + 8];
    }

    torqueControlBalancing_blkdiag(tmp_5, rtb_Switch3, pinvJb_0);
    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 19; i++) {
            Jc_tmp = i + 19 * i_0;
            torqueControlBalancing_B.ConstraintsMatrixOneFoot[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                torqueControlBalancing_B.ConstraintsMatrixOneFoot[Jc_tmp] =
                    torqueControlBalancing_P.ConstraintsMatrix[19 * Jc_tmp_0 + i]
                        * pinvJb_0[6 * i_0 + Jc_tmp_0]
                    + torqueControlBalancing_B.ConstraintsMatrixOneFoot[19 * i_0 + i];
            }
        }
    }

    for (i_0 = 0; i_0 < 3; i_0++) {
        tmp_5[3 * i_0] = torqueControlBalancing_B.SFunction_jt[i_0];
        rtb_Switch3[3 * i_0] = torqueControlBalancing_B.SFunction_jt[i_0];
        i = 1 + 3 * i_0;
        tmp_5[i] = torqueControlBalancing_B.SFunction_jt[i_0 + 4];
        rtb_Switch3[i] = torqueControlBalancing_B.SFunction_jt[i_0 + 4];
        i = 2 + 3 * i_0;
        tmp_5[i] = torqueControlBalancing_B.SFunction_jt[i_0 + 8];
        rtb_Switch3[i] = torqueControlBalancing_B.SFunction_jt[i_0 + 8];
    }

    torqueControlBalancing_blkdiag(tmp_5, rtb_Switch3, pinvJb_0);
    delta_u_min = (1 - rtb_feetContactStatus_idx_1) * rtb_feetContactStatus_idx_0;
    rtb_Clock1 = (1 - rtb_feetContactStatus_idx_0) * rtb_feetContactStatus_idx_1;
    torqueControlBalancing_pinv(A, torqueControlBalancing_P.Reg.pinvTol, pinvA);
    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 19; i++) {
            Jc_tmp = i + 19 * i_0;
            ConstraintMatrixRightFoot[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                ConstraintMatrixRightFoot[Jc_tmp] =
                    torqueControlBalancing_P.ConstraintsMatrix[19 * Jc_tmp_0 + i]
                        * pinvJb_0[6 * i_0 + Jc_tmp_0]
                    + ConstraintMatrixRightFoot[19 * i_0 + i];
            }
        }

        LDot_star_0[i_0] = LDot_star[i_0] - f_grav[i_0];
    }

    torqueControlBalancing_eye(tmp);
    for (i_0 = 0; i_0 < 12; i_0++) {
        rtb_f_LDot[i_0] = 0.0;
        for (i = 0; i < 6; i++) {
            rtb_f_LDot[i_0] += pinvA[12 * i + i_0] * LDot_star_0[i];
        }

        for (i = 0; i < 12; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                scale += pinvA[12 * Jc_tmp_0 + i_0] * A[6 * i + Jc_tmp_0];
            }

            tmp_6[i_0 + 12 * i] = tmp[12 * i + i_0] - scale;
        }
    }

    for (i_0 = 0; i_0 < 12; i_0++) {
        for (i = 0; i < 12; i++) {
            rtb_Na[i + 12 * i_0] = tmp_6[12 * i_0 + i] * (real_T) rtb_feetContactStatus_idx_0
                                   * (real_T) rtb_feetContactStatus_idx_1;
        }
    }

    for (i_0 = 0; i_0 < 29; i_0++) {
        for (i = 0; i < 6; i++) {
            Jc_tmp = 6 * i_0 + i;
            Jc_tmp_0 = i + 12 * i_0;
            Jc[Jc_tmp_0] = torqueControlBalancing_B.SFunction_c4[Jc_tmp]
                           * (real_T) rtb_feetContactStatus_idx_0;
            Jc[Jc_tmp_0 + 6] = torqueControlBalancing_B.SFunction_b3[Jc_tmp]
                               * (real_T) rtb_feetContactStatus_idx_1;
        }
    }

    torqueControlBalanci_mrdivide_b(Jc, torqueControlBalancing_B.M_with_inertia, Jc_invM);
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 12; i++) {
            Jc_tmp = i + 12 * i_0;
            Lambda[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 29; Jc_tmp_0++) {
                Lambda[Jc_tmp] = Jc_invM[12 * Jc_tmp_0 + i] * (real_T) d_b[29 * i_0 + Jc_tmp_0]
                                 + Lambda[12 * i_0 + i];
            }
        }
    }

    torqueControlBalanci_pinvDamped(Lambda, torqueControlBalancing_P.Reg.pinvDamp, pinvLambda);
    torqueControlBalancing_eye_j(torqueControlBalancing_B.rtb_M_with_inertia_m);
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 12; Jc_tmp_0++) {
                scale += pinvLambda[23 * Jc_tmp_0 + i] * Lambda[12 * i_0 + Jc_tmp_0];
            }

            torqueControlBalancing_B.NullLambda[i + 23 * i_0] =
                torqueControlBalancing_B.rtb_M_with_inertia_m[23 * i_0 + i] - scale;
        }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 23; i++) {
            pinvJb_1[i + 23 * i_0] = torqueControlBalancing_B.M_with_inertia[(6 + i) * 29 + i_0];
        }

        for (i = 0; i < 6; i++) {
            pinvJb_0[i + 6 * i_0] = torqueControlBalancing_B.M_with_inertia[29 * i_0 + i];
        }
    }

    torqueControlBalanc_mrdivide_bo(pinvJb_1, pinvJb_0);
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 29; i++) {
            Jc_tmp = i_0 + 23 * i;
            torqueControlBalancing_B.pinvLambda[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 12; Jc_tmp_0++) {
                torqueControlBalancing_B.pinvLambda[Jc_tmp] =
                    pinvLambda[23 * Jc_tmp_0 + i_0] * Jc_invM[12 * i + Jc_tmp_0]
                    + torqueControlBalancing_B.pinvLambda[23 * i + i_0];
            }
        }

        for (i = 0; i < 12; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                scale += pinvJb_1[23 * Jc_tmp_0 + i_0] * Jc[12 * Jc_tmp_0 + i];
            }

            Jc_tmp = i_0 + 23 * i;
            rtb_Sigma[Jc_tmp] = Jc[(6 + i_0) * 12 + i] - scale;
            pinvLambda_0[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 29; Jc_tmp_0++) {
                pinvLambda_0[Jc_tmp] =
                    torqueControlBalancing_B.pinvLambda[23 * Jc_tmp_0 + i_0] * Jc[12 * Jc_tmp_0 + i]
                    + pinvLambda_0[23 * i + i_0];
            }
        }
    }

    for (i_0 = 0; i_0 < 12; i_0++) {
        for (i = 0; i < 23; i++) {
            Jc_tmp = i + 23 * i_0;
            NullLambda[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 23; Jc_tmp_0++) {
                NullLambda[Jc_tmp] = torqueControlBalancing_B.NullLambda[23 * Jc_tmp_0 + i]
                                         * rtb_Sigma[23 * i_0 + Jc_tmp_0]
                                     + NullLambda[23 * i_0 + i];
            }
        }
    }

    for (i_0 = 0; i_0 < 12; i_0++) {
        for (i = 0; i < 23; i++) {
            Jc_tmp_0 = 23 * i_0 + i;
            rtb_Sigma[i + 23 * i_0] = -(pinvLambda_0[Jc_tmp_0] + NullLambda[Jc_tmp_0]);
        }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 23; i++) {
            pinvJb_1[i + 23 * i_0] = torqueControlBalancing_B.M_with_inertia[(6 + i) * 29 + i_0];
        }

        for (i = 0; i < 6; i++) {
            pinvJb_0[i + 6 * i_0] = torqueControlBalancing_B.M_with_inertia[29 * i_0 + i];
        }
    }

    torqueControlBalanc_mrdivide_bo(pinvJb_1, pinvJb_0);
    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                scale += torqueControlBalancing_B.M_with_inertia[(6 + i) * 29 + Jc_tmp_0]
                         * pinvJb_1[23 * Jc_tmp_0 + i_0];
            }

            torqueControlBalancing_B.rtb_M_with_inertia_m[i_0 + 23 * i] =
                torqueControlBalancing_B.M_with_inertia[((6 + i) * 29 + i_0) + 6] - scale;
        }
    }

    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            Jc_tmp = i + 23 * i_0;
            torqueControlBalancing_B.NullLambda_Mbar[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 23; Jc_tmp_0++) {
                torqueControlBalancing_B.NullLambda_Mbar[Jc_tmp] =
                    torqueControlBalancing_B.NullLambda[23 * Jc_tmp_0 + i]
                        * torqueControlBalancing_B.rtb_M_with_inertia_m[23 * i_0 + Jc_tmp_0]
                    + torqueControlBalancing_B.NullLambda_Mbar[23 * i_0 + i];
            }
        }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 23; i++) {
            pinvJb_1[i + 23 * i_0] = torqueControlBalancing_B.M_with_inertia[(6 + i) * 29 + i_0];
        }

        for (i = 0; i < 6; i++) {
            pinvJb_0[i + 6 * i_0] = torqueControlBalancing_B.M_with_inertia[29 * i_0 + i];
        }
    }

    torqueControlBalanc_mrdivide_bo(pinvJb_1, pinvJb_0);
    torqueControlBalancing_pinv_o(torqueControlBalancing_B.NullLambda_Mbar,
                                  torqueControlBalancing_P.Reg.pinvTol,
                                  torqueControlBalancing_B.rtb_M_with_inertia_m);
    torqueControlBalancing_diag(torqueControlBalancing_P.Gain.KD_postural,
                                torqueControlBalancing_B.dv1);
    torqueControlBalancing_pinv_o(torqueControlBalancing_B.NullLambda_Mbar,
                                  torqueControlBalancing_P.Reg.pinvTol,
                                  torqueControlBalancing_B.dv2);
    for (i_0 = 0; i_0 < 12; i_0++) {
        Jc_invM_0[i_0] = 0.0;
        for (i = 0; i < 29; i++) {
            Jc_invM_0[i_0] += Jc_invM[12 * i + i_0] * torqueControlBalancing_B.SFunction_ft[i];
        }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        tmp_7[i_0] =
            torqueControlBalancing_B.SFunction_ej[i_0] * (real_T) rtb_feetContactStatus_idx_0;
        tmp_7[i_0 + 6] =
            torqueControlBalancing_B.SFunction_h[i_0] * (real_T) rtb_feetContactStatus_idx_1;
    }

    for (i_0 = 0; i_0 < 12; i_0++) {
        Jc_invM_1[i_0] = Jc_invM_0[i_0] - tmp_7[i_0];
    }

    for (i_0 = 0; i_0 < 23; i_0++) {
        for (i = 0; i < 23; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 23; Jc_tmp_0++) {
                scale += torqueControlBalancing_B.D[23 * Jc_tmp_0 + i_0]
                         * torqueControlBalancing_B.rtb_M_with_inertia_m[23 * i + Jc_tmp_0];
            }

            torqueControlBalancing_B.rtb_D_c[i_0 + 23 * i] =
                -((real_T) e_b[23 * i + i_0] * torqueControlBalancing_P.Reg.KP_postural + scale);
        }

        NullLambda_0[i_0] =
            torqueControlBalancing_B.SFunction_d[i_0] - torqueControlBalancing_B.Switch5[i_0];
        for (i = 0; i < 23; i++) {
            rtb_D_tmp = i_0 + 23 * i;
            torqueControlBalancing_B.rtb_D_k[rtb_D_tmp] = 0.0;
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 23; Jc_tmp_0++) {
                Jc_tmp = 23 * Jc_tmp_0 + i_0;
                tmp_a = 23 * i + Jc_tmp_0;
                scale += torqueControlBalancing_B.dv1[Jc_tmp] * torqueControlBalancing_B.dv2[tmp_a];
                torqueControlBalancing_B.rtb_D_k[rtb_D_tmp] =
                    torqueControlBalancing_B.rtb_D_c[Jc_tmp]
                        * torqueControlBalancing_B.NullLambda_Mbar[tmp_a]
                    + torqueControlBalancing_B.rtb_D_k[23 * i + i_0];
            }

            torqueControlBalancing_B.dv3[rtb_D_tmp] =
                (real_T) e_b[23 * i + i_0] * torqueControlBalancing_P.Reg.KD_postural + scale;
        }

        for (i = 0; i < 23; i++) {
            Jc_tmp_0 = i_0 + 23 * i;
            torqueControlBalancing_B.dv4[Jc_tmp_0] = 0.0;
            for (Jc_tmp = 0; Jc_tmp < 23; Jc_tmp++) {
                torqueControlBalancing_B.dv4[Jc_tmp_0] =
                    torqueControlBalancing_B.dv3[23 * Jc_tmp + i_0]
                        * torqueControlBalancing_B.NullLambda_Mbar[23 * i + Jc_tmp]
                    + torqueControlBalancing_B.dv4[23 * i + i_0];
            }
        }
    }

    for (i_0 = 0; i_0 < 23; i_0++) {
        rtb_tauModel[i_0] = 0.0;
        rtb_tauModel_0[i_0] = 0.0;
        for (i = 0; i < 23; i++) {
            rtb_D_tmp = 23 * i + i_0;
            rtb_tauModel[i_0] += torqueControlBalancing_B.rtb_D_k[rtb_D_tmp] * NullLambda_0[i];
            rtb_tauModel_0[i_0] +=
                torqueControlBalancing_B.dv4[rtb_D_tmp] * rtb_TmpSignalConversionAtSFunct[6 + i];
        }

        scale = 0.0;
        for (i = 0; i < 6; i++) {
            scale += pinvJb_1[23 * i + i_0] * torqueControlBalancing_B.SFunction_ft[i];
        }

        tmp_8[i_0] = (torqueControlBalancing_B.SFunction_ft[6 + i_0] - scale)
                     + (rtb_tauModel[i_0] - rtb_tauModel_0[i_0]);
        pinvLambda_1[i_0] = 0.0;
        for (i = 0; i < 12; i++) {
            pinvLambda_1[i_0] += pinvLambda[23 * i + i_0] * Jc_invM_1[i];
        }
    }

    torqueControlBalancin_blkdiag_h(torqueControlBalancing_B.ConstraintsMatrixOneFoot,
                                    ConstraintMatrixRightFoot,
                                    ConstraintsMatrixBothFeet);
    for (i_0 = 0; i_0 < 23; i_0++) {
        NullLambda_0[i_0] = 0.0;
        for (i = 0; i < 23; i++) {
            NullLambda_0[i_0] += torqueControlBalancing_B.NullLambda[23 * i + i_0] * tmp_8[i];
        }

        rtb_tauModel[i_0] = pinvLambda_1[i_0] + NullLambda_0[i_0];
        for (i = 0; i < 12; i++) {
            Jc_tmp = i_0 + 23 * i;
            Lambda[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 12; Jc_tmp_0++) {
                Lambda[Jc_tmp] = rtb_Sigma[23 * Jc_tmp_0 + i_0] * rtb_Na[12 * i + Jc_tmp_0]
                                 + Lambda[23 * i + i_0];
            }
        }
    }

    /* '<S23>:1:7' */
    /* '<S23>:1:8' */
    /* '<S23>:1:9' */
    for (i_0 = 0; i_0 < 6; i_0++) {
        for (i = 0; i < 6; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 6; Jc_tmp_0++) {
                scale += pinvJb[6 * i_0 + Jc_tmp_0] * pinvJb[6 * i + Jc_tmp_0];
            }

            Jc_tmp_0 = 6 * i + i_0;
            torqueControlBalancing_B.HessianMatrixOneFoot[i_0 + 6 * i] =
                (real_T) d_a[Jc_tmp_0] * torqueControlBalancing_P.Reg.HessianQP + scale;
            pinvJb_0[i + 6 * i_0] = -pinvJb[Jc_tmp_0];
        }

        LDot_star_0[i_0] = LDot_star[i_0] - f_grav[i_0];
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
        torqueControlBalancing_B.gradientOneFoot[i_0] = 0.0;
        for (i = 0; i < 6; i++) {
            torqueControlBalancing_B.gradientOneFoot[i_0] += pinvJb_0[6 * i + i_0] * LDot_star_0[i];
        }
    }

    for (i_0 = 0; i_0 < 114; i_0++) {
        torqueControlBalancing_B.ConstraintsMatrixOneFoot[i_0] =
            delta_u_min * torqueControlBalancing_B.ConstraintsMatrixOneFoot[i_0]
            + rtb_Clock1 * ConstraintMatrixRightFoot[i_0];
    }

    memcpy(&torqueControlBalancing_B.bVectorConstraintsOneFoot[0],
           &torqueControlBalancing_P.bVectorConstraints[0],
           19U * sizeof(real_T));
    for (i_0 = 0; i_0 < 12; i_0++) {
        for (i = 0; i < 12; i++) {
            scale = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 23; Jc_tmp_0++) {
                scale += Lambda[23 * i_0 + Jc_tmp_0] * Lambda[23 * i + Jc_tmp_0];
            }

            torqueControlBalancing_B.HessianMatrixTwoFeet[i_0 + 12 * i] =
                (real_T) e_a[12 * i + i_0] * torqueControlBalancing_P.Reg.HessianQP + scale;
        }
    }

    for (i_0 = 0; i_0 < 23; i_0++) {
        scale = 0.0;
        for (i = 0; i < 12; i++) {
            scale += rtb_Sigma[23 * i + i_0] * rtb_f_LDot[i];
        }

        rtb_tauModel_0[i_0] = rtb_tauModel[i_0] + scale;
    }

    for (i_0 = 0; i_0 < 12; i_0++) {
        torqueControlBalancing_B.gradientTwoFeet[i_0] = 0.0;
        for (i = 0; i < 23; i++) {
            torqueControlBalancing_B.gradientTwoFeet[i_0] +=
                Lambda[23 * i_0 + i] * rtb_tauModel_0[i];
        }

        for (i = 0; i < 38; i++) {
            Jc_tmp = i + 38 * i_0;
            torqueControlBalancing_B.ConstraintsMatrixTwoFeet[Jc_tmp] = 0.0;
            for (Jc_tmp_0 = 0; Jc_tmp_0 < 12; Jc_tmp_0++) {
                torqueControlBalancing_B.ConstraintsMatrixTwoFeet[Jc_tmp] =
                    ConstraintsMatrixBothFeet[38 * Jc_tmp_0 + i] * rtb_Na[12 * i_0 + Jc_tmp_0]
                    + torqueControlBalancing_B.ConstraintsMatrixTwoFeet[38 * i_0 + i];
            }
        }
    }

    for (i_0 = 0; i_0 < 19; i_0++) {
        tmp_9[i_0] = torqueControlBalancing_P.bVectorConstraints[i_0];
        tmp_9[i_0 + 19] = torqueControlBalancing_P.bVectorConstraints[i_0];
    }

    for (i_0 = 0; i_0 < 38; i_0++) {
        ConstraintsMatrixBothFeet_0[i_0] = 0.0;
        for (i = 0; i < 12; i++) {
            ConstraintsMatrixBothFeet_0[i_0] +=
                ConstraintsMatrixBothFeet[38 * i + i_0] * rtb_f_LDot[i];
        }

        torqueControlBalancing_B.bVectorConstraintsTwoFeet[i_0] =
            tmp_9[i_0] - ConstraintsMatrixBothFeet_0[i_0];
    }

    /* MATLAB Function: '<S24>/One Foot Two Feet QP Selector' */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute Desired
     * Torques/QPSolver/One Foot Two Feet QP Selector': '<S25>:1' */
    /* '<S25>:1:3' */
    rtb_Clock1 = rtb_feetContactStatus_idx_0 + rtb_feetContactStatus_idx_1;
    torqueControlBalancing_B.onOneFoot = ((!(rtb_Clock1 > 1.9)) && (rtb_Clock1 > 0.9));

    /* SignalConversion: '<S24>/HiddenBuf_InsertedFor_QP One Foot_at_inport_5' */
    torqueControlBalancing_B.HiddenBuf_InsertedFor_QPOneFoot = torqueControlBalancing_B.onOneFoot;

    /* Outputs for Enabled SubSystem: '<S24>/QP One Foot' incorporates:
     *  EnablePort: '<S26>/Enable'
     */
    if (torqueControlBalancing_B.HiddenBuf_InsertedFor_QPOneFoot) {
        if (!torqueControlBalancing_DW.QPOneFoot_MODE) {
            torqueControlBalancing_DW.QPOneFoot_MODE = true;
        }
    }
    else {
        if (torqueControlBalancing_DW.QPOneFoot_MODE) {
            torqueControlBalancing_DW.QPOneFoot_MODE = false;
        }
    }

    if (torqueControlBalancing_DW.QPOneFoot_MODE) {
        /* S-Function (BlockFactory): '<S26>/QP One Foot' */
        /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute Desired
         * Torques/QPSolver/QP One Foot/Analytical Solution QP One Foot (unconstrained)': '<S28>:1'
         */
        /* '<S28>:1:3' */
        {
            // Get the CoderBlockInformation from the PWork
            blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
            blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
                torqueControlBalancing_DW.QPOneFoot_PWORK.blockPWork[1]);

            // Get the Block from the PWork
            blockfactory::core::Block* blockPtr = nullptr;
            blockPtr = static_cast<blockfactory::core::Block*>(
                torqueControlBalancing_DW.QPOneFoot_PWORK.blockPWork[0]);

            // Calculate the output
            // --------------------
            bool ok;
            ok = blockPtr->output(blockInfo);

            // Report errors
            if (!ok) {
                std::string error = blockfactory::core::Log::getSingleton().getErrors();
                error = "[Output]" + error;

                // Trim the message if needed
                if (error.length() >= 1024) {
                    error = error.substr(0, 1024 - 1);
                }

                // This shouldn't happen
                if (getRTM()->errorStatus) {
                    delete getRTM()->errorStatus;
                    getRTM()->errorStatus = nullptr;
                }

                getRTM()->errorStatus = new char[1024];
                sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
                return;
            }
        }

        // End of S-Function Block: <S26>/QP One Foot

        /* MATLAB Function: '<S26>/Process QP output' */
        /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute Desired
         * Torques/QPSolver/QP One Foot/Process QP output': '<S30>:1' */
        /* '<S30>:1:3' */
        if (rtb_feetContactStatus_idx_0 > 0.9) {
            /* MATLAB Function: '<S26>/Analytical Solution QP One Foot (unconstrained)' */
            torqueControlBalancing_invNxN(torqueControlBalancing_B.HessianMatrixOneFoot, pinvJb_0);
            for (i = 0; i < 6; i++) {
                updated_primalSolution[i] = torqueControlBalancing_B.QPOneFoot_o1[i];
                updated_primalSolution[i + 6] = 0.0;
                for (i_0 = 0; i_0 < 6; i_0++) {
                    pinvJb[i_0 + 6 * i] = -pinvJb_0[6 * i + i_0];
                }
            }

            for (i_0 = 0; i_0 < 6; i_0++) {
                LDot_star_0[i_0] = 0.0;
                for (i = 0; i < 6; i++) {
                    LDot_star_0[i_0] +=
                        pinvJb[6 * i + i_0] * torqueControlBalancing_B.gradientOneFoot[i];
                }

                torqueControlBalancing_B.f_star_m[i_0] = LDot_star_0[i_0];
                torqueControlBalancing_B.f_star_m[i_0 + 6] = 0.0;
            }
        }
        else {
            /* MATLAB Function: '<S26>/Analytical Solution QP One Foot (unconstrained)' */
            torqueControlBalancing_invNxN(torqueControlBalancing_B.HessianMatrixOneFoot, pinvJb_0);
            for (i = 0; i < 6; i++) {
                updated_primalSolution[i] = 0.0;
                updated_primalSolution[i + 6] = torqueControlBalancing_B.QPOneFoot_o1[i];
                for (i_0 = 0; i_0 < 6; i_0++) {
                    pinvJb[i_0 + 6 * i] = -pinvJb_0[6 * i + i_0];
                }
            }

            for (i_0 = 0; i_0 < 6; i_0++) {
                LDot_star_0[i_0] = 0.0;
                for (i = 0; i < 6; i++) {
                    LDot_star_0[i_0] +=
                        pinvJb[6 * i + i_0] * torqueControlBalancing_B.gradientOneFoot[i];
                }

                torqueControlBalancing_B.f_star_m[i_0] = 0.0;
                torqueControlBalancing_B.f_star_m[i_0 + 6] = LDot_star_0[i_0];
            }
        }

        if (torqueControlBalancing_P.Config.USE_QP_SOLVER
            && (std::abs(torqueControlBalancing_B.QPOneFoot_o2) < 0.01)) {
            memcpy(&torqueControlBalancing_B.f_star_m[0],
                   &updated_primalSolution[0],
                   12U * sizeof(real_T));
        }

        /* End of MATLAB Function: '<S26>/Process QP output' */
    }

    /* End of Outputs for SubSystem: '<S24>/QP One Foot' */

    /* Logic: '<S24>/NOT' */
    torqueControlBalancing_B.NOT = !torqueControlBalancing_B.onOneFoot;

    /* SignalConversion: '<S24>/HiddenBuf_InsertedFor_QP Two Feet_at_inport_4' */
    torqueControlBalancing_B.HiddenBuf_InsertedFor_QPTwoFeet = torqueControlBalancing_B.NOT;

    /* Outputs for Enabled SubSystem: '<S24>/QP Two Feet' incorporates:
     *  EnablePort: '<S27>/Enable'
     */
    if (torqueControlBalancing_B.HiddenBuf_InsertedFor_QPTwoFeet) {
        if (!torqueControlBalancing_DW.QPTwoFeet_MODE) {
            torqueControlBalancing_DW.QPTwoFeet_MODE = true;
        }
    }
    else {
        if (torqueControlBalancing_DW.QPTwoFeet_MODE) {
            torqueControlBalancing_DW.QPTwoFeet_MODE = false;
        }
    }

    if (torqueControlBalancing_DW.QPTwoFeet_MODE) {
        /* S-Function (BlockFactory): '<S27>/QP Two Feet' */
        /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute Desired
         * Torques/QPSolver/QP Two Feet/Analytical Solution Two Feet (unconstrained)': '<S31>:1' */
        /* '<S31>:1:3' */
        {
            // Get the CoderBlockInformation from the PWork
            blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
            blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
                torqueControlBalancing_DW.QPTwoFeet_PWORK.blockPWork[1]);

            // Get the Block from the PWork
            blockfactory::core::Block* blockPtr = nullptr;
            blockPtr = static_cast<blockfactory::core::Block*>(
                torqueControlBalancing_DW.QPTwoFeet_PWORK.blockPWork[0]);

            // Calculate the output
            // --------------------
            bool ok;
            ok = blockPtr->output(blockInfo);

            // Report errors
            if (!ok) {
                std::string error = blockfactory::core::Log::getSingleton().getErrors();
                error = "[Output]" + error;

                // Trim the message if needed
                if (error.length() >= 1024) {
                    error = error.substr(0, 1024 - 1);
                }

                // This shouldn't happen
                if (getRTM()->errorStatus) {
                    delete getRTM()->errorStatus;
                    getRTM()->errorStatus = nullptr;
                }

                getRTM()->errorStatus = new char[1024];
                sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
                return;
            }
        }

        // End of S-Function Block: <S27>/QP Two Feet

        /* MATLAB Function: '<S27>/Process QP output' incorporates:
         *  MATLAB Function: '<S27>/Analytical Solution Two Feet (unconstrained)'
         */
        /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute Desired
         * Torques/QPSolver/QP Two Feet/Process QP output': '<S33>:1' */
        /* '<S33>:1:3' */
        if (torqueControlBalancing_P.Config.USE_QP_SOLVER
            && (std::abs(torqueControlBalancing_B.QPTwoFeet_o2) < 0.01)) {
            memcpy(&torqueControlBalancing_B.f_star[0],
                   &torqueControlBalancing_B.QPTwoFeet_o1[0],
                   12U * sizeof(real_T));
        }
        else {
            /* MATLAB Function: '<S27>/Analytical Solution Two Feet (unconstrained)' */
            torqueControlBalancing_invNxN_b(torqueControlBalancing_B.HessianMatrixTwoFeet, tmp);
            for (i_0 = 0; i_0 < 12; i_0++) {
                for (i = 0; i < 12; i++) {
                    tmp_6[i + 12 * i_0] = -tmp[12 * i_0 + i];
                }
            }

            for (i_0 = 0; i_0 < 12; i_0++) {
                torqueControlBalancing_B.f_star[i_0] = 0.0;
                for (i = 0; i < 12; i++) {
                    torqueControlBalancing_B.f_star[i_0] +=
                        tmp_6[12 * i + i_0] * torqueControlBalancing_B.gradientTwoFeet[i];
                }
            }
        }

        /* End of MATLAB Function: '<S27>/Process QP output' */
    }

    /* End of Outputs for SubSystem: '<S24>/QP Two Feet' */

    /* Switch: '<S22>/Switch' incorporates:
     *  Constant: '<S22>/ '
     *  Constant: '<S22>/ 1'
     *  Product: '<S20>/Product1'
     *  Product: '<S22>/Product'
     *  Sum: '<S20>/Add'
     *  Switch: '<S22>/Switch1'
     */
    if (torqueControlBalancing_P.Config.USE_MOTOR_REFLECTED_INERTIA) {
        /* Sum: '<S20>/Add1' incorporates:
         *  Product: '<S20>/Product1'
         *  Product: '<S20>/Product2'
         */
        for (i_0 = 0; i_0 < 12; i_0++) {
            scale = 0.0;
            for (i = 0; i < 12; i++) {
                scale += rtb_Na[12 * i + i_0] * torqueControlBalancing_B.f_star[i];
            }

            /* Switch: '<S20>/f_LDot is f_star while on One Foot' incorporates:
             *  Product: '<S20>/Product1'
             *  Product: '<S20>/Product2'
             */
            if (torqueControlBalancing_B.onOneFoot) {
                rtb_Clock1 = torqueControlBalancing_B.f_star_m[i_0];
            }
            else {
                rtb_Clock1 = rtb_f_LDot[i_0];
            }

            tmp_7[i_0] = rtb_Clock1 + scale;
        }

        if (torqueControlBalancing_P.Config.USE_DES_JOINT_ACC_FOR_MOTORS_INERTIA) {
            memcpy(&NullLambda_0[0],
                   &torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_p[0],
                   23U * sizeof(real_T));
        }
        else {
            memcpy(&NullLambda_0[0], &torqueControlBalancing_B.SFunction[0], 23U * sizeof(real_T));
        }

        /* Product: '<S22>/Product' incorporates:
         *  Constant: '<S22>/ 1'
         *  Gain: '<S22>/Gain'
         *  Product: '<S20>/Product1'
         *  Sum: '<S20>/Add'
         *  Sum: '<S22>/Add'
         *  Switch: '<S22>/Switch1'
         */
        for (i_0 = 0; i_0 < 23; i_0++) {
            rtb_tauModel_0[i_0] = 0.0;
            for (i = 0; i < 23; i++) {
                rtb_tauModel_0[i_0] +=
                    torqueControlBalancing_B.reflectedInertia[23 * i + i_0] * NullLambda_0[i];
            }

            scale = 0.0;
            for (i = 0; i < 12; i++) {
                scale += rtb_Sigma[23 * i + i_0] * tmp_7[i];
            }

            rtb_Switch_cg[i_0] = (rtb_tauModel[i_0] + scale)
                                 - torqueControlBalancing_P.Config.K_ff * rtb_tauModel_0[i_0];
        }
    }
    else {
        /* Sum: '<S20>/Add1' incorporates:
         *  Product: '<S20>/Product1'
         *  Product: '<S20>/Product2'
         */
        for (i_0 = 0; i_0 < 12; i_0++) {
            scale = 0.0;
            for (i = 0; i < 12; i++) {
                scale += rtb_Na[12 * i + i_0] * torqueControlBalancing_B.f_star[i];
            }

            /* Switch: '<S20>/f_LDot is f_star while on One Foot' incorporates:
             *  Product: '<S20>/Product1'
             *  Product: '<S20>/Product2'
             */
            if (torqueControlBalancing_B.onOneFoot) {
                rtb_Clock1 = torqueControlBalancing_B.f_star_m[i_0];
            }
            else {
                rtb_Clock1 = rtb_f_LDot[i_0];
            }

            tmp_7[i_0] = rtb_Clock1 + scale;
        }

        for (i_0 = 0; i_0 < 23; i_0++) {
            scale = 0.0;
            for (i = 0; i < 12; i++) {
                scale += rtb_Sigma[23 * i + i_0] * tmp_7[i];
            }

            rtb_Switch_cg[i_0] = rtb_tauModel[i_0] + scale;
        }
    }

    /* End of Switch: '<S22>/Switch' */

    /* RelationalOperator: '<S60>/Compare' incorporates:
     *  Clock: '<S59>/Clock'
     *  Constant: '<S60>/Constant'
     */
    rtb_Compare_a = ((&torqueControlBalancing_M)->Timing.t[0]
                     == torqueControlBalancing_P.CompareToConstant_const_l);

    /* MATLAB Function: '<S59>/MATLAB Function' */
    torqueControlBal_MATLABFunction(rtb_Switch_cg,
                                    &torqueControlBalancing_B.sf_MATLABFunction,
                                    &torqueControlBalancing_DW.sf_MATLABFunction);

    /* MATLAB Function: '<S17>/Saturate Torque Derivative' incorporates:
     *  Constant: '<S17>/Constant1'
     *  Constant: '<S17>/Constant2'
     */
    /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/Joint Torque Saturation/Saturate Torque
     * Derivative': '<S58>:1' */
    /* '<S58>:1:3' */
    if (!torqueControlBalancing_DW.uPrev_not_empty) {
        memcpy(&torqueControlBalancing_DW.uPrev[0],
               &torqueControlBalancing_B.sf_MATLABFunction.s0[0],
               23U * sizeof(real_T));
        torqueControlBalancing_DW.uPrev_not_empty = true;
    }

    rtb_Clock1 = torqueControlBalancing_P.Sat.uDotMax * torqueControlBalancing_P.Config.tStep;
    delta_u_min = -torqueControlBalancing_P.Sat.uDotMax * torqueControlBalancing_P.Config.tStep;
    for (i = 0; i < 23; i++) {
        scale = rtb_Switch_cg[i] - torqueControlBalancing_DW.uPrev[i];
        if (scale > rtb_Clock1) {
            scale = rtb_Clock1;
        }

        if (scale < delta_u_min) {
            scale = delta_u_min;
        }

        scale += torqueControlBalancing_DW.uPrev[i];
        torqueControlBalancing_DW.uPrev[i] = scale;

        /* Switch: '<S17>/Switch' incorporates:
         *  Constant: '<S17>/Constant'
         */
        if (!torqueControlBalancing_P.Config.SATURATE_TORQUE_DERIVATIVE) {
            scale = rtb_Switch_cg[i];
        }

        /* End of Switch: '<S17>/Switch' */

        /* Saturate: '<S17>/Saturation' */
        if (scale > torqueControlBalancing_P.Sat.torque) {
            torqueControlBalancing_B.Saturation[i] = torqueControlBalancing_P.Sat.torque;
        }
        else if (scale < -torqueControlBalancing_P.Sat.torque) {
            torqueControlBalancing_B.Saturation[i] = -torqueControlBalancing_P.Sat.torque;
        }
        else {
            torqueControlBalancing_B.Saturation[i] = scale;
        }

        /* End of Saturate: '<S17>/Saturation' */
    }

    /* End of MATLAB Function: '<S17>/Saturate Torque Derivative' */

    /* S-Function (BlockFactory): '<S7>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_le.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_le.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S7>/S-Function

    /* Outputs for Enabled SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' incorporates:
     *  EnablePort: '<S111>/Enable'
     */
    /* Constant: '<S19>/ON_GAZEBO 1' */
    if (torqueControlBalancing_P.Config.EMERGENCY_STOP_WITH_JOINTS_LIMITS) {
        if (!torqueControlBalancing_DW.STOPIFJOINTSHITTHELIMITS_MODE) {
            torqueControlBalancing_DW.STOPIFJOINTSHITTHELIMITS_MODE = true;
        }
    }
    else {
        if (torqueControlBalancing_DW.STOPIFJOINTSHITTHELIMITS_MODE) {
            torqueControlBalancing_DW.STOPIFJOINTSHITTHELIMITS_MODE = false;
        }
    }

    /* End of Constant: '<S19>/ON_GAZEBO 1' */
    if (torqueControlBalancing_DW.STOPIFJOINTSHITTHELIMITS_MODE) {
        /* Assertion: '<S111>/Assertion' incorporates:
         *  UnitDelay: '<S111>/Unit Delay'
         */
        utAssert(torqueControlBalancing_DW.UnitDelay_DSTATE_f != 0.0);

        /* S-Function (BlockFactory): '<S113>/S-Function' */
        {
            // Get the CoderBlockInformation from the PWork
            blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
            blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
                torqueControlBalancing_DW.SFunction_PWORK_g2.blockPWork[1]);

            // Get the Block from the PWork
            blockfactory::core::Block* blockPtr = nullptr;
            blockPtr = static_cast<blockfactory::core::Block*>(
                torqueControlBalancing_DW.SFunction_PWORK_g2.blockPWork[0]);

            // Calculate the output
            // --------------------
            bool ok;
            ok = blockPtr->output(blockInfo);

            // Report errors
            if (!ok) {
                std::string error = blockfactory::core::Log::getSingleton().getErrors();
                error = "[Output]" + error;

                // Trim the message if needed
                if (error.length() >= 1024) {
                    error = error.substr(0, 1024 - 1);
                }

                // This shouldn't happen
                if (getRTM()->errorStatus) {
                    delete getRTM()->errorStatus;
                    getRTM()->errorStatus = nullptr;
                }

                getRTM()->errorStatus = new char[1024];
                sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
                return;
            }
        }

        // End of S-Function Block: <S113>/S-Function

        /* MATLAB Function: '<S111>/MATLAB Function' incorporates:
         *  Constant: '<S111>/index1'
         */
        /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/emergency stop: joint limits/STOP IF
         * JOINTS HIT THE LIMITS/MATLAB Function': '<S114>:1' */
        /* '<S114>:1:3' */
        for (i = 0; i < 23; i++) {
            rtb_res_check_range[i] = ((torqueControlBalancing_B.SFunction_d[i]
                                       < torqueControlBalancing_B.SFunction_o1[i]
                                             + torqueControlBalancing_P.index1_Value)
                                      || (torqueControlBalancing_B.SFunction_d[i]
                                          > torqueControlBalancing_B.SFunction_o2[i]
                                                - torqueControlBalancing_P.index1_Value));
        }

        rtb_Clock1 = rtb_res_check_range[0];
        for (i = 0; i < 22; i++) {
            rtb_Clock1 += (real_T) rtb_res_check_range[i + 1];
        }

        /* '<S114>:1:3' */
        torqueControlBalancing_B.inRange = (rtb_Clock1 == 0.0);

        /* End of MATLAB Function: '<S111>/MATLAB Function' */
        /* '<S114>:1:3' */
    }

    /* End of Outputs for SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */

    /* Outputs for Enabled SubSystem: '<S19>/STOP IF THERE ARE SPIKES IN THE ENCODERS' incorporates:
     *  EnablePort: '<S112>/Enable'
     */
    /* Constant: '<S19>/ON_GAZEBO 2' */
    if (torqueControlBalancing_P.Config.EMERGENCY_STOP_WITH_ENCODER_SPIKES) {
        if (!torqueControlBalancing_DW.STOPIFTHEREARESPIKESINTHEENCODE) {
            torqueControlBalancing_DW.STOPIFTHEREARESPIKESINTHEENCODE = true;
        }
    }
    else {
        if (torqueControlBalancing_DW.STOPIFTHEREARESPIKESINTHEENCODE) {
            torqueControlBalancing_DW.STOPIFTHEREARESPIKESINTHEENCODE = false;
        }
    }

    /* End of Constant: '<S19>/ON_GAZEBO 2' */
    if (torqueControlBalancing_DW.STOPIFTHEREARESPIKESINTHEENCODE) {
        /* Assertion: '<S112>/Assertion' incorporates:
         *  UnitDelay: '<S112>/Unit Delay'
         */
        utAssert(torqueControlBalancing_DW.UnitDelay_DSTATE != 0.0);

        /* MATLAB Function: '<S112>/MATLAB Function' incorporates:
         *  Constant: '<S112>/index1'
         */
        /* MATLAB Function 'MOMENTUM BASED TORQUE CONTROL/emergency stop: joint limits/STOP IF THERE
         * ARE SPIKES IN THE ENCODERS/MATLAB Function': '<S115>:1' */
        /* '<S115>:1:3' */
        if (!torqueControlBalancing_DW.u_previous_not_empty) {
            memcpy(&torqueControlBalancing_DW.u_previous[0],
                   &torqueControlBalancing_B.SFunction_d[0],
                   23U * sizeof(real_T));
            torqueControlBalancing_DW.u_previous_not_empty = true;
        }

        for (i = 0; i < 23; i++) {
            torqueControlBalancing_DW.u_previous[i] =
                torqueControlBalancing_B.SFunction_d[i] - torqueControlBalancing_DW.u_previous[i];
            rtb_res_check_range[i] = (std::abs(torqueControlBalancing_DW.u_previous[i])
                                      >= torqueControlBalancing_P.Sat.maxJointsPositionDelta);
        }

        rtb_Clock1 = rtb_res_check_range[0];
        for (i = 0; i < 22; i++) {
            rtb_Clock1 += (real_T) rtb_res_check_range[i + 1];
        }

        memcpy(&torqueControlBalancing_DW.u_previous[0],
               &torqueControlBalancing_B.SFunction_d[0],
               23U * sizeof(real_T));

        /* '<S115>:1:3' */
        torqueControlBalancing_B.noSpikes = (rtb_Clock1 < 0.1);

        /* End of MATLAB Function: '<S112>/MATLAB Function' */
        /* '<S115>:1:3' */
    }

    /* End of Outputs for SubSystem: '<S19>/STOP IF THERE ARE SPIKES IN THE ENCODERS' */

    /* Outputs for Enabled SubSystem: '<S2>/Visualizer' incorporates:
     *  EnablePort: '<S12>/Enable'
     */
    /* Constant: '<S2>/ON_GAZEBO 4' */
    if (torqueControlBalancing_P.Config.SCOPES_MAIN) {
        if (!torqueControlBalancing_DW.Visualizer_MODE) {
            torqueControlBalancing_DW.Visualizer_MODE = true;
        }
    }
    else {
        if (torqueControlBalancing_DW.Visualizer_MODE) {
            torqueControlBalancing_DW.Visualizer_MODE = false;
        }
    }

    /* End of Constant: '<S2>/ON_GAZEBO 4' */
    if (torqueControlBalancing_DW.Visualizer_MODE) {
        /* S-Function (BlockFactory): '<S14>/S-Function' */
        {
            // Get the CoderBlockInformation from the PWork
            blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
            blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
                torqueControlBalancing_DW.SFunction_PWORK_f.blockPWork[1]);

            // Get the Block from the PWork
            blockfactory::core::Block* blockPtr = nullptr;
            blockPtr = static_cast<blockfactory::core::Block*>(
                torqueControlBalancing_DW.SFunction_PWORK_f.blockPWork[0]);

            // Calculate the output
            // --------------------
            bool ok;
            ok = blockPtr->output(blockInfo);

            // Report errors
            if (!ok) {
                std::string error = blockfactory::core::Log::getSingleton().getErrors();
                error = "[Output]" + error;

                // Trim the message if needed
                if (error.length() >= 1024) {
                    error = error.substr(0, 1024 - 1);
                }

                // This shouldn't happen
                if (getRTM()->errorStatus) {
                    delete getRTM()->errorStatus;
                    getRTM()->errorStatus = nullptr;
                }

                getRTM()->errorStatus = new char[1024];
                sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
                return;
            }
        }

        // End of S-Function Block: <S14>/S-Function
    }

    /* End of Outputs for SubSystem: '<S2>/Visualizer' */

    /* Outputs for Enabled SubSystem: '<S8>/GAZEBO_SYNCHRONIZER' incorporates:
     *  EnablePort: '<S116>/Enable'
     */
    /* Constant: '<S8>/ON_GAZEBO ' */
    if (torqueControlBalancing_P.Config.ON_GAZEBO) {
        /* S-Function (BlockFactory): '<S116>/Simulator Synchronizer' */
        {
            // Get the CoderBlockInformation from the PWork
            blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
            blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
                torqueControlBalancing_DW.SimulatorSynchronizer_PWORK.blockPWork[1]);

            // Get the Block from the PWork
            blockfactory::core::Block* blockPtr = nullptr;
            blockPtr = static_cast<blockfactory::core::Block*>(
                torqueControlBalancing_DW.SimulatorSynchronizer_PWORK.blockPWork[0]);

            // Calculate the output
            // --------------------
            bool ok;
            ok = blockPtr->output(blockInfo);

            // Report errors
            if (!ok) {
                std::string error = blockfactory::core::Log::getSingleton().getErrors();
                error = "[Output]" + error;

                // Trim the message if needed
                if (error.length() >= 1024) {
                    error = error.substr(0, 1024 - 1);
                }

                // This shouldn't happen
                if (getRTM()->errorStatus) {
                    delete getRTM()->errorStatus;
                    getRTM()->errorStatus = nullptr;
                }

                getRTM()->errorStatus = new char[1024];
                sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
                return;
            }
        }

        // End of S-Function Block: <S116>/Simulator Synchronizer
    }

    /* End of Outputs for SubSystem: '<S8>/GAZEBO_SYNCHRONIZER' */

    /* Outputs for Enabled SubSystem: '<S8>/REAL_TIME_SYNC' incorporates:
     *  EnablePort: '<S117>/Enable'
     */
    /* Logic: '<S8>/Logical Operator' incorporates:
     *  Constant: '<S8>/ON_GAZEBO '
     */
    if (!torqueControlBalancing_P.Config.ON_GAZEBO) {
        /* S-Function (BlockFactory): '<S117>/Real Time Synchronizer' */
        {
            // Get the CoderBlockInformation from the PWork
            blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
            blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
                torqueControlBalancing_DW.RealTimeSynchronizer_PWORK.blockPWork[1]);

            // Get the Block from the PWork
            blockfactory::core::Block* blockPtr = nullptr;
            blockPtr = static_cast<blockfactory::core::Block*>(
                torqueControlBalancing_DW.RealTimeSynchronizer_PWORK.blockPWork[0]);

            // Calculate the output
            // --------------------
            bool ok;
            ok = blockPtr->output(blockInfo);

            // Report errors
            if (!ok) {
                std::string error = blockfactory::core::Log::getSingleton().getErrors();
                error = "[Output]" + error;

                // Trim the message if needed
                if (error.length() >= 1024) {
                    error = error.substr(0, 1024 - 1);
                }

                // This shouldn't happen
                if (getRTM()->errorStatus) {
                    delete getRTM()->errorStatus;
                    getRTM()->errorStatus = nullptr;
                }

                getRTM()->errorStatus = new char[1024];
                sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
                return;
            }
        }

        // End of S-Function Block: <S117>/Real Time Synchronizer
    }

    /* End of Logic: '<S8>/Logical Operator' */
    /* End of Outputs for SubSystem: '<S8>/REAL_TIME_SYNC' */

    /* S-Function (BlockFactory): '<S8>/Yarp Clock' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.YarpClock_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.YarpClock_PWORK.blockPWork[0]);

        // Calculate the output
        // --------------------
        bool ok;
        ok = blockPtr->output(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Output]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S8>/Yarp Clock

    /* Update for Enabled SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' incorporates:
     *  EnablePort: '<S111>/Enable'
     */
    if (torqueControlBalancing_DW.STOPIFJOINTSHITTHELIMITS_MODE) {
        /* Update for UnitDelay: '<S111>/Unit Delay' */
        torqueControlBalancing_DW.UnitDelay_DSTATE_f = torqueControlBalancing_B.inRange;
    }

    /* End of Update for SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */

    /* Update for Enabled SubSystem: '<S19>/STOP IF THERE ARE SPIKES IN THE ENCODERS' incorporates:
     *  EnablePort: '<S112>/Enable'
     */
    if (torqueControlBalancing_DW.STOPIFTHEREARESPIKESINTHEENCODE) {
        /* Update for UnitDelay: '<S112>/Unit Delay' */
        torqueControlBalancing_DW.UnitDelay_DSTATE = torqueControlBalancing_B.noSpikes;
    }

    /* End of Update for SubSystem: '<S19>/STOP IF THERE ARE SPIKES IN THE ENCODERS' */

    /* Update absolute time for base rate */
    /* The "clockTick0" counts the number of times the code of this task has
     * been executed. The absolute time is the multiplication of "clockTick0"
     * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
     * overflow during the application lifespan selected.
     * Timer of this task consists of two 32 bit unsigned integers.
     * The two integers represent the low bits Timing.clockTick0 and the high bits
     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
     */
    if (!(++(&torqueControlBalancing_M)->Timing.clockTick0)) {
        ++(&torqueControlBalancing_M)->Timing.clockTickH0;
    }

    (&torqueControlBalancing_M)->Timing.t[0] = (&torqueControlBalancing_M)->Timing.clockTick0
                                                   * (&torqueControlBalancing_M)->Timing.stepSize0
                                               + (&torqueControlBalancing_M)->Timing.clockTickH0
                                                     * (&torqueControlBalancing_M)->Timing.stepSize0
                                                     * 4294967296.0;

    {
        /* Update absolute timer for sample time: [0.01s, 0.0s] */
        /* The "clockTick1" counts the number of times the code of this task has
         * been executed. The resolution of this integer timer is 0.01, which is the step size
         * of the task. Size of "clockTick1" ensures timer will not overflow during the
         * application lifespan selected.
         * Timer of this task consists of two 32 bit unsigned integers.
         * The two integers represent the low bits Timing.clockTick1 and the high bits
         * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.
         */
        (&torqueControlBalancing_M)->Timing.clockTick1++;
        if (!(&torqueControlBalancing_M)->Timing.clockTick1) {
            (&torqueControlBalancing_M)->Timing.clockTickH1++;
        }
    }
}

/* Model initialize function */
void torqueControlBalancingModelClass::initialize()
{
    /* Registration code */

    /* initialize real-time model */
    (void) memset((void*) (&torqueControlBalancing_M), 0, sizeof(RT_MODEL_torqueControlBalanci_T));

    {
        /* Setup solver object */
        rtsiSetSimTimeStepPtr(&(&torqueControlBalancing_M)->solverInfo,
                              &(&torqueControlBalancing_M)->Timing.simTimeStep);
        rtsiSetTPtr(&(&torqueControlBalancing_M)->solverInfo,
                    &rtmGetTPtr((&torqueControlBalancing_M)));
        rtsiSetStepSizePtr(&(&torqueControlBalancing_M)->solverInfo,
                           &(&torqueControlBalancing_M)->Timing.stepSize0);
        rtsiSetErrorStatusPtr(&(&torqueControlBalancing_M)->solverInfo,
                              (&rtmGetErrorStatus((&torqueControlBalancing_M))));
        rtsiSetRTModelPtr(&(&torqueControlBalancing_M)->solverInfo, (&torqueControlBalancing_M));
    }

    rtsiSetSimTimeStep(&(&torqueControlBalancing_M)->solverInfo, MAJOR_TIME_STEP);
    rtsiSetSolverName(&(&torqueControlBalancing_M)->solverInfo, "FixedStepDiscrete");
    rtmSetTPtr(getRTM(), &(&torqueControlBalancing_M)->Timing.tArray[0]);
    (&torqueControlBalancing_M)->Timing.stepSize0 = 0.01;

    /* block I/O */
    (void) memset(((void*) &torqueControlBalancing_B), 0, sizeof(B_torqueControlBalancing_T));

    /* states (dwork) */
    (void) memset((void*) &torqueControlBalancing_DW, 0, sizeof(DW_torqueControlBalancing_T));

    /* Start for S-Function (BlockFactory): '<S3>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "Joints Acceleration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "MeasuredType"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "GetMeasurement",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/GetMeasurement/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S3>/S-Function
    /* Start for S-Function (BlockFactory): '<S4>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_c.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "Joints Position",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "MeasuredType"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "GetMeasurement",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/GetMeasurement1/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_c.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S4>/S-Function
    /* Start for S-Function (BlockFactory): '<S74>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_p.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "imu_frame",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and "
            "References/Compute base to fixed link transform/LFoot to base link transform /Fixed "
            "base to imu transform/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_k[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_p.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S74>/S-Function
    /* Start for S-Function (BlockFactory): '<S72>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_b.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/Compute base to fixed link "
                                      "transform/Relative transform l_sole_H_base/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_a[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_b.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S72>/S-Function
    /* Start for S-Function (BlockFactory): '<S75>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_m.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "root_link",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and "
            "References/Compute base to fixed link transform/LFoot to base link transform /Fixed "
            "base to root link transform/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_n[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_m.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S75>/S-Function
    /* Start for S-Function (BlockFactory): '<Root>/IMU_meas' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.IMU_meas_PWORK.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<int>(
            12.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::INT, 3.0, 1.0, 1.0, "SignalSize"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "ErrorOnMissingPort"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "WaitData"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "Autoconnect"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ReadTimestamp"));
        params.storeParameter<double>(
            0.5,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 8.0, 1.0, 1.0, "Timeout"));
        params.storeParameter<std::string>(
            "/icubSim/inertial",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 2.0, 1.0, 1.0, "PortName"));
        params.storeParameter<std::string>(
            "YarpRead",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/IMU_meas");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 12}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.IMU_meas[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.IMU_meas_PWORK.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <Root>/IMU_meas
    /* Start for S-Function (BlockFactory): '<S70>/Neck Position' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.NeckPosition_PWORK.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<int>(
            3.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::INT, 3.0, 1.0, 1.0, "SignalSize"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "ErrorOnMissingPort"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "WaitData"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "Autoconnect"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ReadTimestamp"));
        params.storeParameter<double>(
            0.5,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 8.0, 1.0, 1.0, "Timeout"));
        params.storeParameter<std::string>(
            "/icubSim/head/state:o",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 2.0, 1.0, 1.0, "PortName"));
        params.storeParameter<std::string>(
            "YarpRead",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/Compute base to fixed link "
                                      "transform/LFoot to base link transform /Neck Position");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 3}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.NeckPosition[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.NeckPosition_PWORK.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S70>/Neck Position
    /* Start for S-Function (BlockFactory): '<S103>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_h.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "com",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/State Machine/xCom/CoM/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch6[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_j[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_h.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S103>/S-Function
    /* Start for S-Function (BlockFactory): '<S84>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_g.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "imu_frame",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and "
            "References/Compute base to fixed link transform/RFoot to base link transform/Fixed "
            "base to imu transform/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_f[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_g.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S84>/S-Function
    /* Start for S-Function (BlockFactory): '<S73>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_l.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/Compute base to fixed link "
                                      "transform/Relative transform r_sole_H_base/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_i[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_l.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S73>/S-Function
    /* Start for S-Function (BlockFactory): '<S85>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_a.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "root_link",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and "
            "References/Compute base to fixed link transform/RFoot to base link transform/Fixed "
            "base to root link transform/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_e[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_a.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S85>/S-Function
    /* Start for S-Function (BlockFactory): '<S71>/Neck Position' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.NeckPosition_PWORK_j.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<int>(
            3.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::INT, 3.0, 1.0, 1.0, "SignalSize"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "ErrorOnMissingPort"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "WaitData"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "Autoconnect"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ReadTimestamp"));
        params.storeParameter<double>(
            0.5,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 8.0, 1.0, 1.0, "Timeout"));
        params.storeParameter<std::string>(
            "/icubSim/head/state:o",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 2.0, 1.0, 1.0, "PortName"));
        params.storeParameter<std::string>(
            "YarpRead",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/Compute base to fixed link "
                                      "transform/RFoot to base link transform/Neck Position");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 3}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.NeckPosition_n[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.NeckPosition_PWORK_j.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S71>/Neck Position
    /* Start for S-Function (BlockFactory): '<S104>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_k.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "com",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/State Machine/xCom2/CoM/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch6_e[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_c[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_k.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S104>/S-Function
    /* Start for S-Function (BlockFactory): '<Root>/wrench_rightFoot' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.wrench_rightFoot_PWORK.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<int>(
            6.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::INT, 3.0, 1.0, 1.0, "SignalSize"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "ErrorOnMissingPort"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "WaitData"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "Autoconnect"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ReadTimestamp"));
        params.storeParameter<double>(
            0.5,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 8.0, 1.0, 1.0, "Timeout"));
        params.storeParameter<std::string>(
            "/wholeBodyDynamics/right_leg/cartesianEndEffectorWrench:o",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 2.0, 1.0, 1.0, "PortName"));
        params.storeParameter<std::string>(
            "YarpRead",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/wrench_rightFoot");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.wrench_rightFoot[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.wrench_rightFoot_PWORK.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <Root>/wrench_rightFoot
    /* Start for S-Function (BlockFactory): '<Root>/wrench_leftFoot' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.wrench_leftFoot_PWORK.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<int>(
            6.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::INT, 3.0, 1.0, 1.0, "SignalSize"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "ErrorOnMissingPort"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "WaitData"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "Autoconnect"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ReadTimestamp"));
        params.storeParameter<double>(
            0.5,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 8.0, 1.0, 1.0, "Timeout"));
        params.storeParameter<std::string>(
            "/wholeBodyDynamics/left_leg/cartesianEndEffectorWrench:o",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 2.0, 1.0, 1.0, "PortName"));
        params.storeParameter<std::string>(
            "YarpRead",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/wrench_leftFoot");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.wrench_leftFoot[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.wrench_leftFoot_PWORK.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <Root>/wrench_leftFoot
    /* Start for S-Function (BlockFactory): '<S107>/MinimumJerkTrajectoryGenerator1' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator1.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(blockfactory::core::ParameterType::BOOL,
                                                  7.0,
                                                  1.0,
                                                  1.0,
                                                  "ReadExternalSettlingTime"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(blockfactory::core::ParameterType::BOOL,
                                                  8.0,
                                                  1.0,
                                                  1.0,
                                                  "ResetOnSettlingTimeChange"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "ReadInitialValue"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "ComputeFirstDerivative"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ComputeSecondDerivative"));
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 3.0, 1.0, 1.0, "SettlingTime"));
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 2.0, 1.0, 1.0, "SampleTime"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "MinimumJerkTrajectoryGenerator",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/Update Gains and References/Smooth "
                                      "reference joint position/MinimumJerkTrajectoryGenerator1");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.jointPos_des[0]));
        blockInfo->setInputPort({1, {1, 1}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.smoothingTimeJoints));

        // Outputs
        blockInfo->setOutputPort(
            {0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerator1[0]));
        blockInfo->setOutputPort(
            {1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_o[0]));
        blockInfo->setOutputPort(
            {2, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_p[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MinimumJerkTrajectoryGenerator"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MinimumJerkTrajectoryGenerator"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator1.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S107>/MinimumJerkTrajectoryGenerator1
    /* Start for S-Function (BlockFactory): '<S68>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_j.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and "
            "References/Compute State Velocity/Feet Jacobians/Jacobian l_sole/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_e0[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_j.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S68>/S-Function
    /* Start for S-Function (BlockFactory): '<S69>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_jg.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and "
            "References/Compute State Velocity/Feet Jacobians/Jacobian r_sole/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_da[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_jg.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S69>/S-Function
    /* Start for S-Function (BlockFactory): '<S5>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_bs.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "Joints Velocity",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "MeasuredType"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "GetMeasurement",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/GetMeasurement2/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_nr[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_bs.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S5>/S-Function
    /* Start for S-Function (BlockFactory): '<S48>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_n.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "MassMatrix",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Dynamics/MassMatrix/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {29, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_b[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MassMatrix"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MassMatrix"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_n.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S48>/S-Function
    /* Start for S-Function (BlockFactory): '<S47>/S-Function' incorporates:
     *  Constant: '<S47>/Constant'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_hk.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "InverseDynamics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Dynamics/GetBiasForces/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));
        blockInfo->setInputPort({2, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.nu_b[0]));
        blockInfo->setInputPort({3, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_nr[0]));
        blockInfo->setInputPort({4, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant_Value_d[0]));
        blockInfo->setInputPort({5, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Gain[0]));

        // Outputs
        blockInfo->setOutputPort({0, {1, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_ft[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "InverseDynamics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "InverseDynamics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_hk.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S47>/S-Function
    /* Start for S-Function (BlockFactory): '<S46>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_e.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "CentroidalMomentum",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Dynamics/CentroidalMomentum/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));
        blockInfo->setInputPort({2, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.nu_b[0]));
        blockInfo->setInputPort({3, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_nr[0]));

        // Outputs
        blockInfo->setOutputPort({0, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_ci[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "CentroidalMomentum"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "CentroidalMomentum"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_e.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S46>/S-Function
    /* Start for S-Function (BlockFactory): '<S40>/S-Function' incorporates:
     *  Constant: '<S35>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_d.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "angular momentum integral error/Compute base to fixed link transform/l_sole to "
            "root_link relative transform/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value_o[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch5[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_br[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_d.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S40>/S-Function
    /* Start for S-Function (BlockFactory): '<S41>/S-Function' incorporates:
     *  Constant: '<S35>/Constant7'
     */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_er.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "angular momentum integral error/Compute base to fixed link transform/r_sole to "
            "root_link relative transform/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_P.Constant7_Value_o[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch5[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_ai[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_er.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S41>/S-Function
    /* Start for S-Function (BlockFactory): '<S37>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_dc.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "angular momentum integral error/Jacobian/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch5[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_e0o[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_dc.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S37>/S-Function
    /* Start for S-Function (BlockFactory): '<S38>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_am.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "angular momentum integral error/Jacobian1/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch5[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_cf[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_am.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S38>/S-Function
    /* Start for S-Function (BlockFactory): '<S34>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_c4.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "CentroidalMomentum",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "angular momentum integral error/CentroidalMomentum/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Switch5[0]));
        blockInfo->setInputPort(
            {2, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.baseVel_equivalent[0]));
        blockInfo->setInputPort({3, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Add[0]));

        // Outputs
        blockInfo->setOutputPort({0, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_o[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "CentroidalMomentum"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "CentroidalMomentum"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_c4.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S34>/S-Function
    /* Start for S-Function (BlockFactory): '<S56>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_jj.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Kinematics/l_sole/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_oe[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_jj.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S56>/S-Function
    /* Start for S-Function (BlockFactory): '<S57>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_pk.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Kinematics/r_sole/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_jt[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_pk.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S57>/S-Function
    /* Start for S-Function (BlockFactory): '<S54>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_ne.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Kinematics/Jacobian l_sole/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_c4[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_ne.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S54>/S-Function
    /* Start for S-Function (BlockFactory): '<S55>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_bp.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Kinematics/Jacobian r_sole/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_b3[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_bp.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S55>/S-Function
    /* Start for S-Function (BlockFactory): '<S51>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_d4.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "DotJNu",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "l_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
                                                                      blockInfo->
                                                                      setUniqueBlockName
                                                                      (
                                                                      "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and Kinematics/Kinematics/DotJNu l_sole
/
                                                                      S-Function
                                                                      ");

                                                                      // Store the parameters in the CoderBlockInformation object
                                                                      blockInfo->
                                                                      storeRTWParameters
                                                                      (params);

                                                                      // Initialize input / output Signals
                                                                      // ---------------------------------

                                                                      // Inputs
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      0, {
                                                                      4, 4
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.w_H_b
                                                                      [0]));
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      1, {
                                                                      1, 23
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.SFunction_d
                                                                      [0]));
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      2, {
                                                                      1, 6
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.nu_b
                                                                      [0]));
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      3, {
                                                                      1, 23
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.SFunction_nr
                                                                      [0]));

                                                                      // Outputs
                                                                      blockInfo->
                                                                      setOutputPort
                                                                      (
                                                                      {
                                                                      0, {
                                                                      1, 6
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.SFunction_ej
                                                                      [0]));

                                                                      // Initialize the class
                                                                      // --------------------

                                                                      // Get the block factory
                                                                      auto
                                                                      factory =
                                                                      blockfactory::
                                                                      core::
                                                                      ClassFactorySingleton::
                                                                      getInstance
                                                                      ().
                                                                      getClassFactory
                                                                      (
                                                                      {
                                                                      "WBToolbox",
                                                                      "DotJNu"
                                                                      } );

                                                                      if
                                                                      (!factory)
                                                                      {
            bfError << "Failed to get factory object (className="
                    << "DotJNu"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      if
                                                                      (!factory->
                                                                      isValid())
                                                                      {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      // Run a dummy configureSizeAndPorts step. This is currently required for properly
                                                                      // handling optional input / outputs static variables.
                                                                      // TODO: find a better way to handle them.
                                                                      {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
                                                                      }

                                                                      // Allocate the block
                                                                      blockfactory::
                                                                      core::
                                                                      Block*
                                                                      blockPtr =
                                                                      factory->create
                                                                      ();
                                                                      factory->addRef
                                                                      ();

                                                                      // Initialize the block
                                                                      bool ok =
                                                                      blockPtr->initialize
                                                                      (blockInfo);

                                                                      // Report errors
                                                                      if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      // Call the initializeInitialConditions() method
                                                                      ok =
                                                                      blockPtr->initializeInitialConditions
                                                                      (blockInfo);

                                                                      // Report errors
                                                                      if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      // Store the block in the PWork vector
                                                                      torqueControlBalancing_DW.SFunction_PWORK_d4.blockPWork
                                                                      [0] =
                                                                      static_cast<
                                                                      void*>
                                                                      (blockPtr);
    }
    // End of S-Function Block: <S51>/S-Function
    /* Start for S-Function (BlockFactory): '<S52>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_d1.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "DotJNu",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "r_sole",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
                                                                      blockInfo->
                                                                      setUniqueBlockName
                                                                      (
                                                                      "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and Kinematics/Kinematics/DotJNu r_sole

                                                                      /S-
                                                                      Function
                                                                      ");

                                                                      // Store the parameters in the CoderBlockInformation object
                                                                      blockInfo->
                                                                      storeRTWParameters
                                                                      (params);

                                                                      // Initialize input / output Signals
                                                                      // ---------------------------------

                                                                      // Inputs
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      0, {
                                                                      4, 4
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.w_H_b
                                                                      [0]));
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      1, {
                                                                      1, 23
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.SFunction_d
                                                                      [0]));
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      2, {
                                                                      1, 6
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.nu_b
                                                                      [0]));
                                                                      blockInfo->
                                                                      setInputPort
                                                                      (
                                                                      {
                                                                      3, {
                                                                      1, 23
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.SFunction_nr
                                                                      [0]));

                                                                      // Outputs
                                                                      blockInfo->
                                                                      setOutputPort
                                                                      (
                                                                      {
                                                                      0, {
                                                                      1, 6
                                                                      },
                                                                      blockfactory::
                                                                      core::Port::
                                                                      DataType::
                                                                      DOUBLE
                                                                      }

                                                                      ,
                                                                      static_cast<
                                                                      void*>
                                                                      (&torqueControlBalancing_B.SFunction_h
                                                                      [0]));

                                                                      // Initialize the class
                                                                      // --------------------

                                                                      // Get the block factory
                                                                      auto
                                                                      factory =
                                                                      blockfactory::
                                                                      core::
                                                                      ClassFactorySingleton::
                                                                      getInstance
                                                                      ().
                                                                      getClassFactory
                                                                      (
                                                                      {
                                                                      "WBToolbox",
                                                                      "DotJNu"
                                                                      } );

                                                                      if
                                                                      (!factory)
                                                                      {
            bfError << "Failed to get factory object (className="
                    << "DotJNu"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      if
                                                                      (!factory->
                                                                      isValid())
                                                                      {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      // Run a dummy configureSizeAndPorts step. This is currently required for properly
                                                                      // handling optional input / outputs static variables.
                                                                      // TODO: find a better way to handle them.
                                                                      {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
                                                                      }

                                                                      // Allocate the block
                                                                      blockfactory::
                                                                      core::
                                                                      Block*
                                                                      blockPtr =
                                                                      factory->create
                                                                      ();
                                                                      factory->addRef
                                                                      ();

                                                                      // Initialize the block
                                                                      bool ok =
                                                                      blockPtr->initialize
                                                                      (blockInfo);

                                                                      // Report errors
                                                                      if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      // Call the initializeInitialConditions() method
                                                                      ok =
                                                                      blockPtr->initializeInitialConditions
                                                                      (blockInfo);

                                                                      // Report errors
                                                                      if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
                                                                      }

                                                                      // Store the block in the PWork vector
                                                                      torqueControlBalancing_DW.SFunction_PWORK_d1.blockPWork
                                                                      [0] =
                                                                      static_cast<
                                                                      void*>
                                                                      (blockPtr);
    }
    // End of S-Function Block: <S52>/S-Function
    /* Start for S-Function (BlockFactory): '<S50>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_hl.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "ForwardKinematics",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "com",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE "
                                      "CONTROL/Dynamics and Kinematics/Kinematics/CoM/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_dk[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_hl.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S50>/S-Function
    /* Start for S-Function (BlockFactory): '<S53>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_ay.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "Jacobian",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "com",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "Frame"));
        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Dynamics and "
            "Kinematics/Kinematics/Jacobian com/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {4, 4}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.w_H_b[0]));
        blockInfo->setInputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.SFunction_d[0]));

        // Outputs
        blockInfo->setOutputPort({0, {6, 29}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_n5[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_ay.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S53>/S-Function
    /* Start for S-Function (BlockFactory): '<S106>/MinimumJerkTrajectoryGenerator2' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator2.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(blockfactory::core::ParameterType::BOOL,
                                                  7.0,
                                                  1.0,
                                                  1.0,
                                                  "ReadExternalSettlingTime"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(blockfactory::core::ParameterType::BOOL,
                                                  8.0,
                                                  1.0,
                                                  1.0,
                                                  "ResetOnSettlingTimeChange"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "ReadInitialValue"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "ComputeFirstDerivative"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ComputeSecondDerivative"));
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 3.0, 1.0, 1.0, "SettlingTime"));
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 2.0, 1.0, 1.0, "SampleTime"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "MinimumJerkTrajectoryGenerator",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot "
                                      "State and References/Update Gains and References/Smooth "
                                      "reference CoM/MinimumJerkTrajectoryGenerator2");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {1, 3}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.pos_CoM_des[0]));
        blockInfo->setInputPort({1, {1, 1}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.smoothingTimeCoM));

        // Outputs
        blockInfo->setOutputPort(
            {0, {1, 3}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerator2[0]));
        blockInfo->setOutputPort(
            {1, {1, 3}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerato_a[0]));
        blockInfo->setOutputPort(
            {2, {1, 3}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerat_pp[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MinimumJerkTrajectoryGenerator"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MinimumJerkTrajectoryGenerator"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator2.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S106>/MinimumJerkTrajectoryGenerator2
    /* Start for S-Function (BlockFactory): '<S64>/MinimumJerkTrajectoryGenerator' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator_.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(blockfactory::core::ParameterType::BOOL,
                                                  7.0,
                                                  1.0,
                                                  1.0,
                                                  "ReadExternalSettlingTime"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(blockfactory::core::ParameterType::BOOL,
                                                  8.0,
                                                  1.0,
                                                  1.0,
                                                  "ResetOnSettlingTimeChange"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "ReadInitialValue"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "ComputeFirstDerivative"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "ComputeSecondDerivative"));
        params.storeParameter<double>(
            2.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 3.0, 1.0, 1.0, "SettlingTime"));
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 2.0, 1.0, 1.0, "SampleTime"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "MinimumJerkTrajectoryGenerator",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Robot State and References/State "
            "Machine/MinimumJerkTrajectoryGenerator");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort(
            {0, {1, 29}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.TmpSignalConversionAtMinimumJer[0]));

        // Outputs
        blockInfo->setOutputPort(
            {0, {1, 29}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.MinimumJerkTrajectoryGenerator[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MinimumJerkTrajectoryGenerator"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MinimumJerkTrajectoryGenerator"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator_.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S64>/MinimumJerkTrajectoryGenerator
    /* Start for Enabled SubSystem: '<S24>/QP One Foot' */
    /* Start for S-Function (BlockFactory): '<S26>/QP One Foot' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.QPOneFoot_PWORK.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "StopWhenFails"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 3.0, 1.0, 1.0, "UseUbA"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 2.0, 1.0, 1.0, "UseLbA"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "UseLb"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "UseUb"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "ComputeObjVal"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "QpOases",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "Desired Torques/QPSolver/QP One Foot/QP One Foot");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort(
            {0, {6, 6}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.HessianMatrixOneFoot[0]));
        blockInfo->setInputPort({1, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.gradientOneFoot[0]));
        blockInfo->setInputPort(
            {2, {19, 6}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.ConstraintsMatrixOneFoot[0]));
        blockInfo->setInputPort(
            {3, {1, 19}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.bVectorConstraintsOneFoot[0]));

        // Outputs
        blockInfo->setOutputPort({0, {1, 6}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.QPOneFoot_o1[0]));
        blockInfo->setOutputPort({1, {1, 1}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.QPOneFoot_o2));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "QpOases"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "QpOases"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.QPOneFoot_PWORK.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S26>/QP One Foot
    /* End of Start for SubSystem: '<S24>/QP One Foot' */
    /* Start for Enabled SubSystem: '<S24>/QP Two Feet' */
    /* Start for S-Function (BlockFactory): '<S27>/QP Two Feet' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.QPTwoFeet_PWORK.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 7.0, 1.0, 1.0, "StopWhenFails"));
        params.storeParameter<bool>(
            1.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 3.0, 1.0, 1.0, "UseUbA"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 2.0, 1.0, 1.0, "UseLbA"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 4.0, 1.0, 1.0, "UseLb"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 5.0, 1.0, 1.0, "UseUb"));
        params.storeParameter<bool>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::BOOL, 6.0, 1.0, 1.0, "ComputeObjVal"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "QpOases",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/Balancing Controller QP/Compute "
            "Desired Torques/QPSolver/QP Two Feet/QP Two Feet");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort(
            {0, {12, 12}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.HessianMatrixTwoFeet[0]));
        blockInfo->setInputPort({1, {1, 12}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.gradientTwoFeet[0]));
        blockInfo->setInputPort(
            {2, {38, 12}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.ConstraintsMatrixTwoFeet[0]));
        blockInfo->setInputPort(
            {3, {1, 38}, blockfactory::core::Port::DataType::DOUBLE}

            ,
            static_cast<void*>(&torqueControlBalancing_B.bVectorConstraintsTwoFeet[0]));

        // Outputs
        blockInfo->setOutputPort({0, {1, 12}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.QPTwoFeet_o1[0]));
        blockInfo->setOutputPort({1, {1, 1}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.QPTwoFeet_o2));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "QpOases"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "QpOases"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.QPTwoFeet_PWORK.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S27>/QP Two Feet
    /* End of Start for SubSystem: '<S24>/QP Two Feet' */
    /* Start for S-Function (BlockFactory): '<S7>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_le.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<double>(
            0.0,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 5.0, 1.0, 1.0, "TrajectoryReference"));

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "Torque",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "CtrlType"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "SetReferences",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/SetReferences/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs
        blockInfo->setInputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                ,
                                static_cast<void*>(&torqueControlBalancing_B.Saturation[0]));

        // Outputs

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "SetReferences"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "SetReferences"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_le.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S7>/S-Function
    /* Start for Enabled SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */
    /* Start for S-Function (BlockFactory): '<S113>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_g2.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "ControlBoardPosition",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "LimitType"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "GetLimits",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/MOMENTUM BASED TORQUE CONTROL/emergency stop: joint "
            "limits/STOP IF JOINTS HIT THE LIMITS/GetLimits/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_o1[0]));
        blockInfo->setOutputPort({1, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_o2[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetLimits"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetLimits"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_g2.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S113>/S-Function
    /* End of Start for SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */
    /* Start for Enabled SubSystem: '<S2>/Visualizer' */
    /* Start for S-Function (BlockFactory): '<S14>/S-Function' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SFunction_PWORK_f.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;

        {
            std::vector<double> valueVector;
            valueVector.reserve(3.0);
            valueVector.push_back(0.0);
            valueVector.push_back(0.0);
            valueVector.push_back(-9.81);
            params.storeParameter<double>(valueVector,
                                          blockfactory::core::ParameterMetadata(
                                              blockfactory::core::ParameterType::STRUCT_DOUBLE,
                                              2.0,
                                              1.0,
                                              3.0,
                                              "GravityVector"));
        }

        params.storeParameter<std::string>(
            "Joints Torque",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "MeasuredType"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "WBT",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "LocalName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(5.0);
            valueVector.push_back("torso");
            valueVector.push_back("left_arm");
            valueVector.push_back("right_arm");
            valueVector.push_back("left_leg");
            valueVector.push_back("right_leg");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    5.0,
                    "ControlBoardsNames"));
        }

        params.storeParameter<std::string>(
            "GetMeasurement",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "torqueControlBalancing/Configuration",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "ConfBlockName"));

        {
            std::vector<std::string> valueVector;
            valueVector.reserve(23.0);
            valueVector.push_back("torso_pitch");
            valueVector.push_back("torso_roll");
            valueVector.push_back("torso_yaw");
            valueVector.push_back("l_shoulder_pitch");
            valueVector.push_back("l_shoulder_roll");
            valueVector.push_back("l_shoulder_yaw");
            valueVector.push_back("l_elbow");
            valueVector.push_back("r_shoulder_pitch");
            valueVector.push_back("r_shoulder_roll");
            valueVector.push_back("r_shoulder_yaw");
            valueVector.push_back("r_elbow");
            valueVector.push_back("l_hip_pitch");
            valueVector.push_back("l_hip_roll");
            valueVector.push_back("l_hip_yaw");
            valueVector.push_back("l_knee");
            valueVector.push_back("l_ankle_pitch");
            valueVector.push_back("l_ankle_roll");
            valueVector.push_back("r_hip_pitch");
            valueVector.push_back("r_hip_roll");
            valueVector.push_back("r_hip_yaw");
            valueVector.push_back("r_knee");
            valueVector.push_back("r_ankle_pitch");
            valueVector.push_back("r_ankle_roll");
            params.storeParameter<std::string>(
                valueVector,
                blockfactory::core::ParameterMetadata(
                    blockfactory::core::ParameterType::STRUCT_CELL_STRING,
                    2.0,
                    1.0,
                    23.0,
                    "ControlledJoints"));
        }

        params.storeParameter<std::string>(
            "icubSim",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "RobotName"));
        params.storeParameter<std::string>(
            "model.urdf",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRUCT_STRING, 2.0, 1.0, 1.0, "UrdfFile"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/Dump and visualize/Visualizer/GetMeasurement1/S-Function");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 23}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.SFunction_bm[0]));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SFunction_PWORK_f.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S14>/S-Function
    /* End of Start for SubSystem: '<S2>/Visualizer' */
    /* Start for Enabled SubSystem: '<S8>/GAZEBO_SYNCHRONIZER' */
    /* Start for S-Function (BlockFactory): '<S116>/Simulator Synchronizer' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.SimulatorSynchronizer_PWORK.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 2.0, 1.0, 1.0, "Period"));
        params.storeParameter<std::string>(
            "/clock/rpc",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 3.0, 1.0, 1.0, "GazeboClockPort"));
        params.storeParameter<std::string>(
            "/WBT_synchronizer/rpc:o",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 4.0, 1.0, 1.0, "RpcPort"));
        params.storeParameter<std::string>(
            "SimulatorSynchronizer",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/synchronizer/GAZEBO_SYNCHRONIZER/Simulator Synchronizer");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "SimulatorSynchronizer"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "SimulatorSynchronizer"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.SimulatorSynchronizer_PWORK.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }

    // End of S-Function Block: <S116>/Simulator Synchronizer

    /* End of Start for SubSystem: '<S8>/GAZEBO_SYNCHRONIZER' */

    /* Start for Enabled SubSystem: '<S8>/REAL_TIME_SYNC' */

    /* Start for S-Function (BlockFactory): '<S117>/Real Time Synchronizer' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.RealTimeSynchronizer_PWORK.blockPWork[1] =
            static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<double>(
            0.01,
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::DOUBLE, 2.0, 1.0, 1.0, "Period"));
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "RealTimeSynchronizer",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName(
            "torqueControlBalancing/synchronizer/REAL_TIME_SYNC/Real Time Synchronizer");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "RealTimeSynchronizer"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "RealTimeSynchronizer"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.RealTimeSynchronizer_PWORK.blockPWork[0] =
            static_cast<void*>(blockPtr);
    }

    // End of S-Function Block: <S117>/Real Time Synchronizer

    /* End of Start for SubSystem: '<S8>/REAL_TIME_SYNC' */

    /* Start for S-Function (BlockFactory): '<S8>/Yarp Clock' */
    {
        // Create and store the CoderBlockInformation object
        blockfactory::coder::CoderBlockInformation* blockInfo =
            new blockfactory::coder::CoderBlockInformation();
        torqueControlBalancing_DW.YarpClock_PWORK.blockPWork[1] = static_cast<void*>(blockInfo);

        // Initialize the parameters
        // -------------------------
        blockfactory::core::Parameters params;
        params.storeParameter<std::string>(
            "WBToolbox",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 1.0, 1.0, 1.0, "libName"));
        params.storeParameter<std::string>(
            "YarpClock",
            blockfactory::core::ParameterMetadata(
                blockfactory::core::ParameterType::STRING, 0.0, 1.0, 1.0, "className"));

        // Store the block name
        blockInfo->setUniqueBlockName("torqueControlBalancing/synchronizer/Yarp Clock");

        // Store the parameters in the CoderBlockInformation object
        blockInfo->storeRTWParameters(params);

        // Initialize input / output Signals
        // ---------------------------------

        // Inputs

        // Outputs
        blockInfo->setOutputPort({0, {1, 1}, blockfactory::core::Port::DataType::DOUBLE}

                                 ,
                                 static_cast<void*>(&torqueControlBalancing_B.YarpClock));

        // Initialize the class
        // --------------------

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpClock"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpClock"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Run a dummy configureSizeAndPorts step. This is currently required for properly
        // handling optional input / outputs static variables.
        // TODO: find a better way to handle them.
        {
            // Create a new class. This object will be destroyed at the end of the scope.
            shlibpp::SharedLibraryClass<blockfactory::core::Block> blockPtr(*factory);
            auto tmpCoderBlockInfo = std::unique_ptr<blockfactory::coder::CoderBlockInformation>(
                new blockfactory::coder::CoderBlockInformation);
            tmpCoderBlockInfo->storeRTWParameters(params);
            blockPtr->configureSizeAndPorts(tmpCoderBlockInfo.get());
        }

        // Allocate the block
        blockfactory::core::Block* blockPtr = factory->create();
        factory->addRef();

        // Initialize the block
        bool ok = blockPtr->initialize(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Call the initializeInitialConditions() method
        ok = blockPtr->initializeInitialConditions(blockInfo);

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[InitializeInitialConditions]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Store the block in the PWork vector
        torqueControlBalancing_DW.YarpClock_PWORK.blockPWork[0] = static_cast<void*>(blockPtr);
    }
    // End of S-Function Block: <S8>/Yarp Clock
    /* SystemInitialize for MATLAB Function: '<S77>/MATLAB Function' */
    torqueCon_MATLABFunction_i_Init(&torqueControlBalancing_DW.sf_MATLABFunction_i);

    /* SystemInitialize for MATLAB Function: '<S78>/MATLAB Function' */
    torqueCon_MATLABFunction_g_Init(&torqueControlBalancing_DW.sf_MATLABFunction_o);

    /* SystemInitialize for MATLAB Function: '<S95>/MATLAB Function' */
    torqueControlBalancing_DW.state_not_empty = false;

    /* SystemInitialize for MATLAB Function: '<S96>/MATLAB Function' */
    torqueContr_MATLABFunction_Init(&torqueControlBalancing_DW.sf_MATLABFunction_d);

    /* SystemInitialize for MATLAB Function: '<S87>/MATLAB Function' */
    torqueCon_MATLABFunction_i_Init(&torqueControlBalancing_DW.sf_MATLABFunction_j);

    /* SystemInitialize for MATLAB Function: '<S88>/MATLAB Function' */
    torqueCon_MATLABFunction_g_Init(&torqueControlBalancing_DW.sf_MATLABFunction_c);

    /* SystemInitialize for MATLAB Function: '<S64>/STATE MACHINE' */
    torqueControlBalancing_DW.currentState_not_empty = false;
    torqueControlBalancing_DW.t_switch = 0.0;
    memset(&torqueControlBalancing_DW.w_H_fixedLink[0], 0, sizeof(real_T) << 4U);
    torqueControlBalancing_DW.w_H_fixedLink[0] = 1.0;
    torqueControlBalancing_DW.w_H_fixedLink[5] = 1.0;
    torqueControlBalancing_DW.w_H_fixedLink[10] = 1.0;
    torqueControlBalancing_DW.w_H_fixedLink[15] = 1.0;
    torqueControlBalancing_DW.yogaMovesetCounter = 1.0;

    /* SystemInitialize for MATLAB Function: '<S59>/MATLAB Function' */
    torqueContr_MATLABFunction_Init(&torqueControlBalancing_DW.sf_MATLABFunction);

    /* SystemInitialize for MATLAB Function: '<S17>/Saturate Torque Derivative' */
    torqueControlBalancing_DW.uPrev_not_empty = false;

    /* SystemInitialize for Enabled SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */
    /* InitializeConditions for UnitDelay: '<S111>/Unit Delay' */
    torqueControlBalancing_DW.UnitDelay_DSTATE_f =
        torqueControlBalancing_P.UnitDelay_InitialCondition;

    /* End of SystemInitialize for SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */

    /* SystemInitialize for Enabled SubSystem: '<S19>/STOP IF THERE ARE SPIKES IN THE ENCODERS' */
    /* InitializeConditions for UnitDelay: '<S112>/Unit Delay' */
    torqueControlBalancing_DW.UnitDelay_DSTATE =
        torqueControlBalancing_P.UnitDelay_InitialCondition_j;

    /* SystemInitialize for MATLAB Function: '<S112>/MATLAB Function' */
    torqueControlBalancing_DW.u_previous_not_empty = false;

    /* End of SystemInitialize for SubSystem: '<S19>/STOP IF THERE ARE SPIKES IN THE ENCODERS' */
}

/* Model terminate function */
void torqueControlBalancingModelClass::terminate()
{
    /* Terminate for S-Function (BlockFactory): '<S3>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "GetMeasurement"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S3>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S4>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_c.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_c.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "GetMeasurement"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S4>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S74>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_p.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_p.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S74>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S72>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_b.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_b.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S72>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S75>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_m.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_m.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S75>/S-Function

    /* Terminate for S-Function (BlockFactory): '<Root>/IMU_meas' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.IMU_meas_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.IMU_meas_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "YarpRead"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <Root>/IMU_meas

    /* Terminate for S-Function (BlockFactory): '<S70>/Neck Position' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.NeckPosition_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.NeckPosition_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "YarpRead"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S70>/Neck Position

    /* Terminate for S-Function (BlockFactory): '<S103>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_h.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_h.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S103>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S84>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_g.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_g.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S84>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S73>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_l.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_l.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S73>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S85>/S-Function' incorporates:
     *  Constant: '<S63>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_a.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_a.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S85>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S71>/Neck Position' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.NeckPosition_PWORK_j.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.NeckPosition_PWORK_j.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "YarpRead"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S71>/Neck Position

    /* Terminate for S-Function (BlockFactory): '<S104>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_k.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_k.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S104>/S-Function

    /* Terminate for S-Function (BlockFactory): '<Root>/wrench_rightFoot' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.wrench_rightFoot_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.wrench_rightFoot_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "YarpRead"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <Root>/wrench_rightFoot

    /* Terminate for S-Function (BlockFactory): '<Root>/wrench_leftFoot' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.wrench_leftFoot_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.wrench_leftFoot_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpRead"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpRead"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "YarpRead"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <Root>/wrench_leftFoot

    /* Terminate for S-Function (BlockFactory): '<S107>/MinimumJerkTrajectoryGenerator1' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator1.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator1.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MinimumJerkTrajectoryGenerator"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MinimumJerkTrajectoryGenerator"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "MinimumJerkTrajectoryGenerator"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S107>/MinimumJerkTrajectoryGenerator1

    /* Terminate for S-Function (BlockFactory): '<S68>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_j.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_j.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S68>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S69>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_jg.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_jg.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S69>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S5>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_bs.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_bs.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "GetMeasurement"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S5>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S48>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_n.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_n.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MassMatrix"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MassMatrix"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "MassMatrix"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S48>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S47>/S-Function' incorporates:
     *  Constant: '<S47>/Constant'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_hk.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_hk.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "InverseDynamics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "InverseDynamics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "InverseDynamics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S47>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S46>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_e.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_e.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "CentroidalMomentum"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "CentroidalMomentum"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "CentroidalMomentum"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S46>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S40>/S-Function' incorporates:
     *  Constant: '<S35>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_d.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_d.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S40>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S41>/S-Function' incorporates:
     *  Constant: '<S35>/Constant7'
     */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_er.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_er.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S41>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S37>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_dc.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_dc.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S37>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S38>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_am.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_am.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S38>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S34>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_c4.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_c4.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "CentroidalMomentum"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "CentroidalMomentum"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "CentroidalMomentum"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S34>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S56>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_jj.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_jj.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S56>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S57>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_pk.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_pk.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S57>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S54>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_ne.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_ne.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S54>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S55>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_bp.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_bp.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S55>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S51>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_d4.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_d4.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "DotJNu"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "DotJNu"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "DotJNu"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S51>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S52>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_d1.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_d1.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "DotJNu"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "DotJNu"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "DotJNu"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S52>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S50>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_hl.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_hl.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "ForwardKinematics"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "ForwardKinematics"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "ForwardKinematics"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S50>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S53>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_ay.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_ay.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "Jacobian"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "Jacobian"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "Jacobian"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S53>/S-Function

    /* Terminate for S-Function (BlockFactory): '<S106>/MinimumJerkTrajectoryGenerator2' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator2.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator2.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MinimumJerkTrajectoryGenerator"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MinimumJerkTrajectoryGenerator"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "MinimumJerkTrajectoryGenerator"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S106>/MinimumJerkTrajectoryGenerator2

    /* Terminate for S-Function (BlockFactory): '<S64>/MinimumJerkTrajectoryGenerator' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator_.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.MinimumJerkTrajectoryGenerator_.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "MinimumJerkTrajectoryGenerator"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "MinimumJerkTrajectoryGenerator"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "MinimumJerkTrajectoryGenerator"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S64>/MinimumJerkTrajectoryGenerator

    /* Terminate for Enabled SubSystem: '<S24>/QP One Foot' */

    /* Terminate for S-Function (BlockFactory): '<S26>/QP One Foot' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.QPOneFoot_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.QPOneFoot_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "QpOases"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "QpOases"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "QpOases"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S26>/QP One Foot

    /* End of Terminate for SubSystem: '<S24>/QP One Foot' */

    /* Terminate for Enabled SubSystem: '<S24>/QP Two Feet' */

    /* Terminate for S-Function (BlockFactory): '<S27>/QP Two Feet' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.QPTwoFeet_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.QPTwoFeet_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "QpOases"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "QpOases"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "QpOases"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S27>/QP Two Feet

    /* End of Terminate for SubSystem: '<S24>/QP Two Feet' */

    /* Terminate for S-Function (BlockFactory): '<S7>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_le.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_le.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "SetReferences"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "SetReferences"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "SetReferences"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S7>/S-Function

    /* Terminate for Enabled SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */

    /* Terminate for S-Function (BlockFactory): '<S113>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_g2.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_g2.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetLimits"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetLimits"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "GetLimits"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S113>/S-Function

    /* End of Terminate for SubSystem: '<S19>/STOP IF JOINTS HIT THE LIMITS' */

    /* Terminate for Enabled SubSystem: '<S2>/Visualizer' */

    /* Terminate for S-Function (BlockFactory): '<S14>/S-Function' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SFunction_PWORK_f.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SFunction_PWORK_f.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "GetMeasurement"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "GetMeasurement"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "GetMeasurement"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S14>/S-Function

    /* End of Terminate for SubSystem: '<S2>/Visualizer' */

    /* Terminate for Enabled SubSystem: '<S8>/GAZEBO_SYNCHRONIZER' */

    /* Terminate for S-Function (BlockFactory): '<S116>/Simulator Synchronizer' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.SimulatorSynchronizer_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.SimulatorSynchronizer_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "SimulatorSynchronizer"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "SimulatorSynchronizer"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "SimulatorSynchronizer"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S116>/Simulator Synchronizer

    /* End of Terminate for SubSystem: '<S8>/GAZEBO_SYNCHRONIZER' */

    /* Terminate for Enabled SubSystem: '<S8>/REAL_TIME_SYNC' */

    /* Terminate for S-Function (BlockFactory): '<S117>/Real Time Synchronizer' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.RealTimeSynchronizer_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.RealTimeSynchronizer_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "RealTimeSynchronizer"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "RealTimeSynchronizer"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "RealTimeSynchronizer"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S117>/Real Time Synchronizer

    /* End of Terminate for SubSystem: '<S8>/REAL_TIME_SYNC' */

    /* Terminate for S-Function (BlockFactory): '<S8>/Yarp Clock' */
    {
        // Get the CoderBlockInformation from the PWork
        blockfactory::coder::CoderBlockInformation* blockInfo = nullptr;
        blockInfo = static_cast<blockfactory::coder::CoderBlockInformation*>(
            torqueControlBalancing_DW.YarpClock_PWORK.blockPWork[1]);

        // Get the Block from the PWork
        blockfactory::core::Block* blockPtr = nullptr;
        blockPtr = static_cast<blockfactory::core::Block*>(
            torqueControlBalancing_DW.YarpClock_PWORK.blockPWork[0]);

        // Get the block factory
        auto factory = blockfactory::core::ClassFactorySingleton::getInstance().getClassFactory(
            {"WBToolbox", "YarpClock"});

        if (!factory) {
            bfError << "Failed to get factory object (className="
                    << "YarpClock"
                    << ",libName="
                    << "WBToolbox"
                    << ")";
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        if (!factory->isValid()) {
            bfError << "Factory error (" << static_cast<std::uint32_t>(factory->getStatus())
                    << "): " << factory->getError().c_str();
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Initialize]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }

        // Terminate the class
        // -------------------
        bool ok;
        ok = blockPtr->terminate(blockInfo);

        // Destroy the block
        factory->destroy(blockPtr);
        blockPtr = nullptr;

        // Decrease the counter of the factory
        factory->removeRef();
        if (factory->getReferenceCount() == 1) {
            // Delete the memory ownership of the shared pointer used in this function
            factory.reset();

            // Delete the factory object
            if (!blockfactory::core::ClassFactorySingleton::getInstance().destroyFactory(
                    {"WBToolbox", "YarpClock"})) {
                bfError << "Failed to destroy the factory";

                // Do not return since other actions need to be performed
            }
        }

        // Delete the BlockInformation object
        delete blockInfo;
        blockInfo = nullptr;

        // Report errors
        if (!ok) {
            std::string error = blockfactory::core::Log::getSingleton().getErrors();
            error = "[Terminate]" + error;

            // Trim the message if needed
            if (error.length() >= 1024) {
                error = error.substr(0, 1024 - 1);
            }

            // This shouldn't happen
            if (getRTM()->errorStatus) {
                delete getRTM()->errorStatus;
                getRTM()->errorStatus = nullptr;
            }

            getRTM()->errorStatus = new char[1024];
            sprintf(const_cast<char_T*>(getRTM()->errorStatus), "%s", error.c_str());
            return;
        }
    }

    // End of S-Function Block: <S8>/Yarp Clock
}

/* Constructor */
torqueControlBalancingModelClass::torqueControlBalancingModelClass()
{
    static const P_torqueControlBalancing_T torqueControlBalancing_P_temp = {
        /* Variable: StateMachine
         * Referenced by: '<S64>/STATE MACHINE'
         */
        {5.0,
         50.0,
         100.0,
         0.01,
         5.0,
         50.0,
         1.0,
         1.0,
         1.0,
         1,
         0,
         0,
         0,
         0,
         0,
         0,
         5.0,

         {1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 10.0},

         {1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 10.0},
         0.9,

         {0.0, 0.0, 0.0, 0.0,   0.0, 0.0,   0.0, 0.0, 0.0, 0.0,    0.0, 0.0,  0.0,
          0.0, 0.0, 0.0, 0.005, 0.0, -0.09, 0.0, 0.0, 0.0, -0.005, 0.0, 0.09, 0.0,
          0.0, 0.0, 0.0, 0.0,   0.0, 0.0,   0.0, 0.0, 0.0, 0.0,    0.0, 0.0,  0.0},

         {0.0,     -0.0348, 0.0864,  0.0,     -0.0348, 0.0864,  0.0,     0.0864,  0.0864,  0.0,
          -0.0348, 0.0864,  0.0,     0.0,     0.0779,  0.0258,  0.0,     0.0779,  0.0258,  0.0,
          0.0258,  0.0258,  0.0,     0.0779,  0.0258,  0.0,     0.0,     0.0429,  0.0152,  0.0,
          0.0429,  0.0152,  0.0,     0.0152,  0.0152,  0.0,     0.0429,  0.0152,  0.0,     0.0,
          -0.1493, 0.1253,  0.0,     -0.1493, 0.1253,  0.0,     0.1253,  0.1253,  0.0,     -0.1493,
          0.1253,  0.0,     0.0,     0.858,   0.8135,  0.0,     0.858,   0.8135,  0.0,     0.8135,
          0.8135,  0.0,     0.858,   0.8135,  0.0,     0.0,     0.2437,  0.3051,  0.0,     0.2437,
          0.3051,  0.0,     0.3051,  0.3051,  0.0,     0.2437,  0.3051,  0.0,     0.0,     0.871,
          0.7928,  0.0,     0.871,   0.7928,  0.0,     0.7928,  0.7928,  0.0,     0.871,   0.7928,
          0.0,     0.0,     -0.1493, 0.0563,  0.0,     -0.1493, 0.0563,  0.0,     0.0563,  0.0563,
          0.0,     -0.1493, 0.0563,  0.0,     0.0,     0.858,   0.6789,  0.0,     0.858,   0.6789,
          0.0,     0.6789,  0.6789,  0.0,     0.858,   0.6789,  0.0,     0.0,     0.2437,  0.334,
          0.0,     0.2437,  0.334,   0.0,     0.334,   0.334,   0.0,     0.2437,  0.334,   0.0,
          0.0,     0.871,   0.6214,  0.0,     0.871,   0.6214,  0.0,     0.6214,  0.6214,  0.0,
          0.871,   0.6214,  0.0,     0.0,     -0.0015, -0.0015, 0.0,     -0.0015, 0.0107,  0.0,
          0.0107,  0.0005,  0.0,     0.0005,  -0.0026, 0.0,     0.0,     -0.1109, -0.1109, 0.0,
          -0.1109, -0.0741, 0.0,     -0.0741, 0.0793,  0.0,     0.0793,  0.0225,  0.0,     0.0,
          -0.0001, -0.0001, 0.0,     -0.0001, -0.0001, 0.0,     -0.0001, -0.0014, 0.0,     -0.0014,
          0.0093,  0.0,     0.0,     0.0003,  0.0003,  0.0,     0.0003,  -0.012,  0.0,     -0.012,
          -0.0051, 0.0,     -0.0051, -0.002,  0.0,     0.0,     0.016,   0.016,   0.0,     0.016,
          0.0252,  0.0,     0.0252,  0.0073,  0.0,     0.0073,  0.0027,  0.0,     0.0,     0.163,
          0.163,   0.0,     0.163,   0.1369,  0.0,     0.1369,  -0.1151, 0.0,     -0.1151, -0.0277,
          0.0,     0.0,     0.0005,  0.0005,  0.0,     0.0005,  -0.0026, 0.0,     -0.0026, -0.0015,
          0.0,     -0.0015, 0.0107,  0.0,     0.0,     0.0793,  0.0793,  0.0,     0.0793,  0.0225,
          0.0,     0.0225,  -0.1109, 0.0,     -0.1109, -0.0741, 0.0,     0.0,     -0.0014, -0.0014,
          0.0,     -0.0014, 0.0093,  0.0,     0.0093,  -0.0001, 0.0,     -0.0001, -0.0001, 0.0,
          0.0,     -0.0051, -0.0051, 0.0,     -0.0051, -0.002,  0.0,     -0.002,  0.0003,  0.0,
          0.0003,  -0.012,  0.0,     0.0,     0.0073,  0.0073,  0.0,     0.0073,  0.0027,  0.0,
          0.0027,  0.016,   0.0,     0.016,   0.0252,  0.0,     0.0,     -0.1151, -0.1151, 0.0,
          -0.1151, -0.0277, 0.0,     -0.0277, 0.163,   0.0,     0.163,   0.1369,  0.0},

         {0.0,     2.0,     4.0,     6.0,     8.0,     10.0,    12.0,    14.0,    16.0,    18.0,
          20.0,    22.0,    24.0,    26.0,    28.0,    30.0,    32.0,    34.0,    36.0,    38.0,
          40.0,    42.0,    44.0,    46.0,    48.0,    50.0,    -0.079,  -0.079,  -0.0852, -0.0852,
          -0.079,  -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852,
          -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852,
          -0.0852, -0.0852, 0.2279,  0.2279,  -0.4273, -0.4273, -0.2273, -0.4273, -0.4273, -0.4273,
          -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273,
          -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, -0.4273, 0.4519,  0.4519,
          0.0821,  0.0821,  0.4519,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,
          0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,  0.0821,
          0.0821,  0.0821,  0.0821,  0.0821,  -1.1621, -1.1621, 0.1391,  0.1391,  -1.1621, 0.1391,
          0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,
          0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,
          0.6663,  0.6663,  1.4585,  1.4585,  0.6663,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,
          1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,
          1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  0.4919,  0.4965,  0.2464,  0.2464,
          0.4965,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,
          0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,
          0.2464,  0.2464,  0.9947,  0.9947,  0.3042,  0.3042,  0.9947,  0.3042,  0.3042,  0.3042,
          0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,
          0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  -1.0717, -1.0717,
          -0.4181, -0.4181, -1.0717, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181,
          -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181,
          -0.4181, -0.4181, -0.4181, -0.4181, 1.2904,  1.2904,  1.68,    1.68,    1.2904,  1.68,
          1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,
          1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,
          -0.2447, -0.2493, 0.7373,  0.7373,  -0.2493, 0.7373,  0.7373,  0.7373,  0.7373,  0.7373,
          0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,
          0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  1.0948,  1.0948,  0.3031,  0.3031,
          1.0948,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,
          0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,
          0.3031,  0.3031,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,
          0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,
          0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.206,   0.206,
          0.206,   0.3473,  0.4473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,
          0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,
          0.6473,  0.6473,  0.6473,  0.6473,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,
          0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,
          0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,
          -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741,
          -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741,
          -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1044, -0.1044, -0.1044, -0.1044,
          -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044,
          -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044,
          -0.1044, -0.1044, 0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,
          0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,
          0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.3484,  0.3714,
          0.3714,  0.3514,  0.3514,  0.3514,  0.3514,  0.3514,  0.3514,  0.3514,  0.8514,  0.8514,
          0.8514,  0.8514,  1.5514,  0.2514,  -0.3514, 0.3514,  0.8514,  0.8514,  0.8514,  0.8514,
          1.5514,  0.2514,  -0.3514, 0.3514,  0.4008,  0.9599,  0.9599,  1.3107,  1.3107,  1.3107,
          1.3107,  1.3107,  0.0107,  1.3107,  1.3107,  0.3107,  1.3107,  0.0107,  0.3107,  0.0107,
          0.3107,  1.3107,  1.3107,  0.3107,  1.3107,  0.0107,  0.3107,  0.0107,  0.3107,  1.3107,
          -0.0004, 1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,
          1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,
          1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  -0.3672, -1.6594, -1.6594, -0.0189,
          -0.0189, -0.0189, -1.6217, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189,
          -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189,
          -0.0189, -0.0189, -0.106,  -0.106,  0.5,     0.5,     0.5,     0.5,     0.5,     0.5,
          0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,
          0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     -0.0875, -0.0614,
          -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614,
          -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614,
          -0.0614, -0.0614, -0.0614, -0.0614},

         {0.0,     2.0,     4.0,     6.0,     8.0,     10.0,    12.0,    14.0,    16.0,    18.0,
          20.0,    22.0,    24.0,    26.0,    28.0,    30.0,    32.0,    34.0,    36.0,    38.0,
          40.0,    42.0,    44.0,    46.0,    48.0,    50.0,    -0.079,  -0.079,  -0.0852, -0.0852,
          -0.079,  -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852,
          -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852, -0.0852,
          -0.0852, -0.0852, -0.2279, -0.2279, 0.4273,  0.4273,  0.2273,  0.4273,  0.4273,  0.4273,
          0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,
          0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  0.4273,  -0.4519, -0.4519,
          -0.0821, -0.0821, -0.4519, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821,
          -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821, -0.0821,
          -0.0821, -0.0821, -0.0821, -0.0821, -1.0717, -1.0717, -0.4181, -0.4181, -1.0717, -0.4181,
          -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181,
          -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181, -0.4181,
          1.2904,  1.2904,  1.68,    1.68,    1.2904,  1.68,    1.68,    1.68,    1.68,    1.68,
          1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    1.68,
          1.68,    1.68,    1.68,    1.68,    1.68,    1.68,    -0.2447, -0.2493, 0.7373,  0.7373,
          -0.2493, 0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,
          0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,  0.7373,
          0.7373,  0.7373,  1.0948,  1.0948,  0.3031,  0.3031,  1.0948,  0.3031,  0.3031,  0.3031,
          0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,
          0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  0.3031,  -1.1621, -1.1621,
          0.1391,  0.1391,  -1.1621, 0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,
          0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,  0.1391,
          0.1391,  0.1391,  0.1391,  0.1391,  0.6663,  0.6663,  1.4585,  1.4585,  0.6663,  1.4585,
          1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,
          1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,  1.4585,
          0.4919,  0.4965,  0.2464,  0.2464,  0.4965,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,
          0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,
          0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.2464,  0.9947,  0.9947,  0.3042,  0.3042,
          0.9947,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,
          0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,  0.3042,
          0.3042,  0.3042,  0.3484,  0.3714,  0.3714,  0.3514,  0.3514,  0.3514,  0.3514,  0.3514,
          0.3514,  0.3514,  0.8514,  0.8514,  0.8514,  0.8514,  1.5514,  0.2514,  -0.3514, 0.3514,
          0.8514,  0.8514,  0.8514,  0.8514,  1.5514,  0.2514,  -0.3514, 0.3514,  0.4008,  0.9599,
          0.9599,  1.3107,  1.3107,  1.3107,  1.3107,  1.3107,  0.0107,  1.3107,  1.3107,  0.3107,
          1.3107,  0.0107,  0.3107,  0.0107,  0.3107,  1.3107,  1.3107,  0.3107,  1.3107,  0.0107,
          0.3107,  0.0107,  0.3107,  1.3107,  -0.0004, 1.3253,  1.3253,  1.3253,  1.3253,  1.3253,
          1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,
          1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,  1.3253,
          -0.3672, -1.6594, -1.6594, -0.0189, -0.0189, -0.0189, -1.6217, -0.0189, -0.0189, -0.0189,
          -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189,
          -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.0189, -0.106,  -0.106,  0.5,     0.5,
          0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,
          0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,     0.5,
          0.5,     0.5,     -0.0875, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614,
          -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614,
          -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, -0.0614, 0.2092,  0.2092,
          0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,
          0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,  0.2092,
          0.2092,  0.2092,  0.2092,  0.2092,  0.206,   0.206,   0.206,   0.3473,  0.4473,  0.6473,
          0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,
          0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,  0.6473,
          0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,
          0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,
          0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  0.0006,  -0.1741, -0.1741, -0.1741, -0.1741,
          -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741,
          -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741, -0.1741,
          -0.1741, -0.1741, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044,
          -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044,
          -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, -0.1044, 0.07,    0.07,
          0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,
          0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,    0.07,
          0.07,    0.07,    0.07,    0.07}},

        /* Variable: Config
         * Referenced by:
         *   '<S2>/ON_GAZEBO 1'
         *   '<S2>/ON_GAZEBO 2'
         *   '<S2>/ON_GAZEBO 4'
         *   '<S2>/ON_GAZEBO 6'
         *   '<S8>/ON_GAZEBO '
         *   '<S15>/Momentum Based Balancing Controller '
         *   '<S17>/Constant'
         *   '<S17>/Constant1'
         *   '<S19>/ON_GAZEBO 1'
         *   '<S19>/ON_GAZEBO 2'
         *   '<S22>/(transpose(T*Gamma))^{-1}*I_m*(T*Gamma)^{-1}'
         *   '<S22>/ '
         *   '<S22>/ 1'
         *   '<S22>/Gain'
         *   '<S64>/STATE MACHINE'
         *   '<S45>/Add motor reflected inertias'
         *   '<S45>/Constant'
         *   '<S70>/Get Base Rotation From IMU'
         *   '<S70>/USE_IMU4EST_BASE'
         *   '<S71>/Get Base Rotation From IMU'
         *   '<S71>/USE_IMU4EST_BASE'
         *   '<S106>/SMOOTH_DES_COM'
         *   '<S107>/SMOOTH_DES_COM2'
         *   '<S26>/Process QP output'
         *   '<S27>/Process QP output'
         *   '<S79>/USE_IMU4EST_BASE1'
         *   '<S89>/USE_IMU4EST_BASE1'
         */
        {600000.0,
         0.01,
         1,
         1,
         1,
         1,
         0,
         1,
         0,
         1,
         9.81,

         {3.0, 4.0, 4.0, 6.0, 6.0},
         0,
         0,
         1,
         0,
         0,
         0,
         0,
         1,
         0,
         1,
         0,
         1,
         1,

         {0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0067, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0067, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01,   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.01},

         {8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          5.8500000000000007e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          0.0,
          8.27e-6},

         {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
          0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
         0.0,
         0,
         2.0,
         0.0,

         {0.0, 1.0, 0.0},
         0.02,
         0.2,
         0},

        /* Variable: Gain
         * Referenced by:
         *   '<S15>/Momentum Based Balancing Controller '
         *   '<S64>/STATE MACHINE'
         */
        {{50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0,
          50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0,
          10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0},

         {0.70710678118654757, 0.70710678118654757, 0.70710678118654757, 0.70710678118654757,
          0.70710678118654757, 0.70710678118654757, 0.70710678118654757, 0.70710678118654757,
          0.70710678118654757, 0.70710678118654757, 0.70710678118654757, 0.70710678118654757,
          0.70710678118654757, 0.70710678118654757, 0.70710678118654757, 0.70710678118654757,
          0.70710678118654757, 0.70710678118654757, 0.70710678118654757, 0.70710678118654757,
          0.70710678118654757, 0.70710678118654757, 0.70710678118654757, 0.70710678118654757,
          0.70710678118654757, 0.70710678118654757, 0.31622776601683794, 0.31622776601683794,
          0.31622776601683794, 0.31622776601683794, 0.31622776601683794, 0.31622776601683794,
          0.31622776601683794, 0.31622776601683794, 0.31622776601683794, 0.31622776601683794,
          0.31622776601683794, 0.31622776601683794, 0.31622776601683794},
         0.25,
         1.0,

         {10.0,  10.0,  10.0,  30.0,  30.0,  30.0,  10.0, 10.0,  10.0,  30.0,  30.0,  30.0,  10.0,
          30.0,  30.0,  30.0,  30.0,  30.0,  30.0,  30.0, 30.0,  30.0,  30.0,  30.0,  30.0,  30.0,
          20.0,  20.0,  20.0,  30.0,  30.0,  30.0,  20.0, 20.0,  20.0,  30.0,  30.0,  30.0,  20.0,
          10.0,  10.0,  10.0,  10.0,  5.0,   10.0,  10.0, 10.0,  10.0,  10.0,  5.0,   10.0,  10.0,
          10.0,  10.0,  10.0,  10.0,  5.0,   10.0,  10.0, 10.0,  10.0,  10.0,  5.0,   10.0,  10.0,
          10.0,  10.0,  10.0,  10.0,  10.0,  20.0,  10.0, 10.0,  10.0,  10.0,  10.0,  20.0,  10.0,
          8.0,   8.0,   8.0,   10.0,  10.0,  10.0,  8.0,  8.0,   8.0,   10.0,  10.0,  10.0,  8.0,
          10.0,  10.0,  10.0,  10.0,  10.0,  10.0,  10.0, 10.0,  10.0,  10.0,  10.0,  10.0,  10.0,
          10.0,  10.0,  10.0,  10.0,  10.0,  10.0,  10.0, 10.0,  10.0,  10.0,  10.0,  10.0,  10.0,
          10.0,  10.0,  10.0,  10.0,  20.0,  20.0,  10.0, 10.0,  10.0,  10.0,  20.0,  20.0,  10.0,
          8.0,   8.0,   8.0,   10.0,  10.0,  10.0,  8.0,  8.0,   8.0,   10.0,  10.0,  10.0,  8.0,
          30.0,  30.0,  30.0,  100.0, 200.0, 100.0, 30.0, 30.0,  30.0,  100.0, 220.0, 220.0, 30.0,
          30.0,  30.0,  50.0,  200.0, 250.0, 350.0, 50.0, 50.0,  30.0,  50.0,  350.0, 350.0, 30.0,
          20.0,  20.0,  30.0,  100.0, 20.0,  20.0,  60.0, 30.0,  20.0,  30.0,  120.0, 120.0, 20.0,
          20.0,  20.0,  60.0,  400.0, 20.0,  200.0, 30.0, 60.0,  20.0,  100.0, 200.0, 200.0, 20.0,
          100.0, 100.0, 100.0, 100.0, 10.0,  10.0,  5.0,  100.0, 100.0, 100.0, 65.0,  65.0,  100.0,
          100.0, 100.0, 100.0, 100.0, 50.0,  100.0, 5.0,  100.0, 100.0, 100.0, 100.0, 100.0, 100.0,
          30.0,  30.0,  30.0,  100.0, 220.0, 220.0, 30.0, 30.0,  30.0,  100.0, 200.0, 100.0, 30.0,
          50.0,  50.0,  30.0,  50.0,  350.0, 350.0, 30.0, 30.0,  50.0,  200.0, 250.0, 350.0, 50.0,
          30.0,  30.0,  20.0,  30.0,  120.0, 120.0, 30.0, 20.0,  30.0,  100.0, 20.0,  20.0,  30.0,
          60.0,  60.0,  20.0,  100.0, 200.0, 200.0, 20.0, 20.0,  60.0,  400.0, 20.0,  200.0, 60.0,
          100.0, 100.0, 100.0, 100.0, 65.0,  65.0,  5.0,  100.0, 100.0, 100.0, 10.0,  10.0,  100.0,
          100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 5.0,  100.0, 100.0, 100.0, 50.0,  100.0, 100.0},

         {0.31622776601683794,
          0.54772255750516607,
          0.447213595499958,
          0.31622776601683794,
          0.31622776601683794,
          0.31622776601683794,
          0.282842712474619,
          0.31622776601683794,
          0.31622776601683794,
          0.31622776601683794,
          0.282842712474619,
          0.54772255750516607,
          0.54772255750516607,
          0.447213595499958,
          0.447213595499958,
          1.0,
          1.0,
          0.54772255750516607,
          0.70710678118654757,
          0.54772255750516607,
          0.7745966692414834,
          1.0,
          1.0}},

        /* Variable: Reg
         * Referenced by:
         *   '<S15>/Momentum Based Balancing Controller '
         *   '<S21>/Get Equivalent Base Velocity'
         *   '<S62>/Compute Base Velocity'
         */
        {1.0e-7, 1.0, 1.0e-5, 0.1, 0.0, 1.0e-7},

        /* Variable: Sat
         * Referenced by:
         *   '<S17>/Constant2'
         *   '<S17>/Saturation'
         *   '<S112>/index1'
         */
        {60.0, 300.0, 0.26179938779914941},

        /* Variable: ConstraintsMatrix
         * Referenced by: '<S15>/Constant'
         */
        {3.7320508075688785,
         1.0000000000000002,
         0.26794919243112281,
         -0.2679491924311227,
         -0.99999999999999911,
         -3.7320508075688745,
         -3.7320508075688807,
         -1.0000000000000011,
         -0.26794919243112292,
         0.2679491924311222,
         0.99999999999999878,
         3.7320508075688732,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         1.0,
         1.0,
         1.0,
         1.0,
         1.0,
         1.0,
         -1.0,
         -1.0,
         -1.0,
         -1.0,
         -1.0,
         -1.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         -1.2440169358562927,
         -0.45534180126147961,
         -0.33333333333333331,
         -0.33333333333333331,
         -0.45534180126147927,
         -1.2440169358562914,
         -1.2440169358562936,
         -0.45534180126147983,
         -0.33333333333333331,
         -0.33333333333333331,
         -0.45534180126147922,
         -1.2440169358562909,
         -0.013333333333333334,
         -0.013333333333333334,
         -1.0,
         -0.07,
         -0.12,
         -0.045,
         -0.05,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         -1.0,
         1.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         0.0,
         0.0,
         0.0,
         1.0,
         -1.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         -0.0,
         1.0,
         -1.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0},

        /* Variable: bVectorConstraints
         * Referenced by: '<S15>/Constant1'
         */
        {0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         0.0,
         -10.0,
         0.0,
         0.0,
         0.0,
         0.0},

        /* Mask Parameter: CompareToConstant_const
         * Referenced by: '<S80>/Constant'
         */
        0.0,

        /* Mask Parameter: CompareToConstant_const_o
         * Referenced by: '<S82>/Constant'
         */
        0.0,

        /* Mask Parameter: CompareToConstant_const_p
         * Referenced by: '<S99>/Constant'
         */
        0.0,

        /* Mask Parameter: CompareToConstant_const_pf
         * Referenced by: '<S101>/Constant'
         */
        0.0,

        /* Mask Parameter: CompareToConstant_const_h
         * Referenced by: '<S90>/Constant'
         */
        0.0,

        /* Mask Parameter: CompareToConstant_const_k
         * Referenced by: '<S92>/Constant'
         */
        0.0,

        /* Mask Parameter: CompareToConstant_const_l
         * Referenced by: '<S60>/Constant'
         */
        0.0,

        /* Expression: pi/180
         * Referenced by: '<S79>/Gain'
         */
        0.017453292519943295,

        /* Expression: pi/180
         * Referenced by: '<S89>/Gain'
         */
        0.017453292519943295,

        /* Expression: 1
         * Referenced by: '<S111>/Unit Delay'
         */
        1.0,

        /* Expression: 0.01
         * Referenced by: '<S111>/index1'
         */
        0.01,

        /* Expression: 1
         * Referenced by: '<S112>/Unit Delay'
         */
        1.0,

        /* Expression: eye(4)
         * Referenced by: '<S63>/Constant7'
         */
        {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0},

        /* Expression: zeros(3,1)
         * Referenced by: '<S79>/Constant'
         */
        {0.0, 0.0, 0.0},

        /* Expression: zeros(3,1)
         * Referenced by: '<S89>/Constant'
         */
        {0.0, 0.0, 0.0},

        /* Expression: zeros(6,1)
         * Referenced by: '<S47>/Constant'
         */
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},

        /* Expression: 0
         * Referenced by: '<S47>/Gain'
         */
        0.0,

        /* Expression: eye(4)
         * Referenced by: '<S35>/Constant7'
         */
        {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0},

        /* Expression: 0.1
         * Referenced by: '<S21>/Switch'
         */
        0.1,

        /* Expression: zeros(6,1)
         * Referenced by: '<S106>/Constant'
         */
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}}; /* Modifiable parameters */

    /* Initialize tunable parameters */
    torqueControlBalancing_P = torqueControlBalancing_P_temp;
}

/* Destructor */
torqueControlBalancingModelClass::~torqueControlBalancingModelClass()
{
    /* Currently there is no destructor body generated.*/
}

/* Real-Time Model get method */
RT_MODEL_torqueControlBalanci_T* torqueControlBalancingModelClass::getRTM()
{
    return (&torqueControlBalancing_M);
}
